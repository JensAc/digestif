comments = [[
Extracted from the PGF manual version 3.1.9a
URL: https://github.com/pgf-tikz/pgf/
Original license: GNU FDL v1.2+ or LPPL 1.3+
]]
package = {
   documentation = "texdoc:generic/pgf/pgfmanual.pdf",
   name = "tikz"
}
commands = {
   afterdecoration = {
      arguments = {
         {
            meta = "after code"
         }
      },
      details = [[
Defines ⟨after code⟩ as commands to be executed after the decoration has
been applied to the current segment. This command can be omitted.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.afterdecoration"
   },
   anchor = {
      arguments = {
         {
            meta = "name"
         },
         {
            meta = "code"
         }
      },
      details = [[
This command declares an anchor named ⟨name⟩. Unlike for saved anchors,
the ⟨code⟩ will not be executed each time a node is declared. Rather,
the ⟨code⟩ is only executed when the anchor is specifically requested;
either for anchoring the node during its creation or as a position in
the shape referenced later on.

The ⟨name⟩ is a quite arbitrary string that is not "passed down" to the
system level. Thus, names like south or 1 or :: would all be fine.

A saved anchor is not automatically also a normal anchor. If you wish to
give the users access to a saved anchor you must declare a normal anchor
that just returns the position of the saved anchor.

When the ⟨code⟩ is executed, all saved anchor macros will be defined.
Thus, you can reference them in your ⟨code⟩. The effect of the ⟨code⟩
should be to set the values of \pgf@x and \pgf@y to the coordinates of
the anchor.

Let us consider some example for the simple rectangle shape. First, we
would like to make the upper right corner publicly available, for
example as north east:

    \anchor{north east}{\upperrightcorner}

The \upperrightcorner macro will set \pgf@x and \pgf@y to the
coordinates of the upper right corner. Thus, \pgf@x and \pgf@y will have
exactly the right values at the end of the anchor's code.

Next, let us define a north west anchor. For this anchor, we can negate
the \pgf@x variable:

    \anchor{north west}{
      \upperrightcorner
      \pgf@x=-\pgf@x
    }

Finally, it is a good idea to always define a center anchor, which will
be the default location for a shape.

    \anchor{center}{\pgfpointorigin}

You might wonder whether we should not take into consideration that the
node is not placed at the origin, but has been shifted somewhere.
However, the anchor positions are always specified in the shape's
"private" coordinate system. The "outer" transformation that has been
applied to the shape upon its creation is applied automatically to the
coordinates returned by the anchor's ⟨code⟩.

Our simple rectangle only has one text label (node part) called text.
This is the default situation, so we do not need to do anything. For the
text node part we must set up a text anchor. Upon creation of a node,
this anchor will be made to coincide with the left endpoint of the
baseline of the text label (within the private coordinate system of the
shape). By default, the text anchor is at the origin, but you may change
this. For example, we would say

    \anchor{text}{%
      \upperrightcorner%
      \pgf@x=-\pgf@x%
      \pgf@y=-\pgf@y%
    }

to center the text label on the origin in the shape coordinate space.
Note that we could not have written the following:

    \anchor{text}{\pgfpoint{-.5\wd\pgfnodeparttextbox}{-.5\ht\pgfnodeparttextbox}}

Do you see why this is wrong? The problem is that the box
\pgfnodeparttextbox will most likely not have the correct size when the
anchor is computed. After all, the anchor position might be recomputed
at a time when several other nodes have been created.

If a shape has several node parts, we would have to define an anchor for
each part.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.anchor"
   },
   anchorborder = {
      arguments = {
         {
            meta = "code"
         }
      },
      details = [[
A border anchor is an anchor point on the border of the shape. What
exactly is considered as the "border" of the shape depends on the shape.

When the user requests a point on the border of the shape using the
\pgfpointshapeborder command, the ⟨code⟩ will be executed to discern
this point. When the execution of the ⟨code⟩ starts, the dimensions
\pgf@x and \pgf@y will have been set to a location $p$ in the shape's
coordinate system, and relative to the anchor center. Note that
\pgfpointshapeborder will produce an error if the shape does not contain
the center anchor.

It is now the job of the ⟨code⟩ to set up \pgf@x and \pgf@y such that
they specify the point on the shape's border that lies on a straight
line from the shape's center to the point $p$. Usually, this is a
somewhat complicated computation, involving many case distinctions and
some basic math. Note that the output coordinates must be returned in
the shape's coordinate system, no longer relative to the center anchor.
While these different points of reference are only noticeable if the
center anchor is not at the origin of the shape's coordinate system, it
implies that "doing nothing" as a border anchor, i.e., returning the
point that was fed to \pgfpointshapeborder requires adding the center
anchor to the input coordinates.

For our simple rectangle we must compute a point on the border of a
rectangle whose one corner is the origin (ignoring the depth for
simplicity) and whose other corner is \upperrightcorner. The following
code might be used:

    \anchorborder{%
      % Call a function that computes a border point. Since this
      % function will modify dimensions like \pgf@x, we must move them to
      % other dimensions.
      \@tempdima=\pgf@x
      \@tempdimb=\pgf@y
      \pgfpointborderrectangle{\pgfpoint{\@tempdima}{\@tempdimb}}{\upperrightcorner}
    }
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.anchorborder"
   },
   arrow = {
      arguments = {
         {
            delimiters = {
               "[",
               "]"
            },
            keys = "$ref:tikz#/keys/tikz",
            meta = "options",
            optional = true
         },
         {
            meta = "arrow end tip"
         }
      },
      details = [[
This command simply draws the ⟨arrow end tip⟩ at the origin, pointing
right. This is exactly what you need when you want to draw an arrow tip
as a marking.

The ⟨options⟩ can only be given when TikZ is used. In this case, they
are executed in a scope that contains the arrow tip.

    \begin{tikzpicture}[decoration={
        markings,% switch on markings
        mark=at position 1cm  with {\node[red]{1cm};},
        mark=at position .75  with {\arrow[blue,line width=2mm]{>}},
        mark=at position -1cm with {\arrowreversed[black]{stealth}}}
        ]
      \draw [help lines] grid (3,2);
      \draw [postaction={decorate}] (0,0) -- (3,1) arc (0:180:1.5 and 1);
    \end{tikzpicture}

Here is a more useful example:

    \begin{tikzpicture}[decoration={
        markings,% switch on markings
        mark=between positions 0 and .75 step 4mm with {\arrow{stealth}},
        mark=between positions .75 and 1 step 4mm with {\arrowreversed{stealth}}}
        ]
      \draw [help lines] grid (3,2);
      \draw [postaction={decorate}] (0,0) -- (3,1) arc (0:180:1.5 and 1);
    \end{tikzpicture}
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.arrow"
   },
   arrowreversed = {
      arguments = {
         {
            delimiters = {
               "[",
               "]"
            },
            keys = "$ref:tikz#/keys/tikz",
            meta = "options",
            optional = true
         },
         {
            meta = "arrow end tip"
         }
      },
      details = [[
As above, only the arrow end tip is flipped and points in the other
direction.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.arrowreversed"
   },
   attribute = {
      arguments = {
         {
            meta = "attribute name"
         },
         {
            literal = "="
         },
         {
            meta = "initial value"
         },
         {
            literal = ";"
         }
      },
      details = [[
This command can only be given inside the body of an \pgfooclass
command. It declares the attribute named ⟨attribute name⟩. This name,
like method or class names, can be quite arbitrary, but should not
contain periods. Valid names are an_ attribute? or my attribute.

You can optionally specify an ⟨initial value⟩ for the attribute; if none
is given, the empty string is used automatically. The initial value is
the value that the attribute will have just after the object has been
created and before the constructor is called.

    \pgfooclass{stamp}{
      % This is the class stamp

      \attribute text;
      \attribute rotation angle = 20;

      \method stamp(#1) {
        \pgfooset{text}{#1} % Set the text
      }

      \method apply(#1,#2) {
        \pgfoothis.shift origin(#1,#2)

        % Draw the stamp:
        \node [rotate=\pgfoovalueof{rotation angle},font=\huge]
          {\pgfoovalueof{text}};
      }

      \method shift origin(#1,#2) { ... }

      \method set rotation (#1) {
        \pgfooset{rotation angle}{#1}
      }
    }
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.attribute"
   },
   backgroundpath = {
      arguments = {
         {
            meta = "code"
         }
      },
      details = [[
This command specifies the path that "makes up" the background of the
shape. Note that the shape cannot prescribe what is going to happen with
the path: It might be drawn, shaded, filled, or even thrown away. If you
want to specify that something should "always" happen when this shape is
drawn (for example, if the shape is a stop-sign, we always want it to be
filled with a red color), you can use commands like
\beforebackgroundpath, explained below.

When the ⟨code⟩ is executed, all saved anchors will be in effect. The
⟨code⟩ should contain path construction commands.

For our simple rectangle, the following code might be used:

    \backgroundpath{
      \pgfpathrectanglecorners
        {\upperrightcorner}
        {\pgfpointscale{-1}{\upperrightcorner}}
    }

As the name suggests, the background path is used "behind" the text
labels. Thus, this path is used first, then the text labels are drawn,
possibly obscuring part of the path.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.backgroundpath"
   },
   beforebackgroundpath = {
      arguments = {
         {
            meta = "code"
         }
      },
      details = [[
This command works like \behindbackgroundpath, only the ⟨code⟩ is
executed after the background path has been used, but before the texts
label are drawn.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.beforebackgroundpath"
   },
   beforedecoration = {
      arguments = {
         {
            meta = "before code"
         }
      },
      details = [[
Defines ⟨before code⟩ as (typically) PGF commands to be executed before
the decoration is applied to the current segment. This command can be
omitted. If you wish to set up some decoration specific parameters such
as segment length, or segment amplitude, then they can be set in ⟨before
code⟩.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.beforedecoration"
   },
   beforeforegroundpath = {
      arguments = {
         {
            meta = "code"
         }
      },
      details = [[
This ⟨code⟩ is executed at the very end.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.beforeforegroundpath"
   },
   behindbackgroundpath = {
      arguments = {
         {
            meta = "code"
         }
      },
      details = [[
Unlike the previous two commands, ⟨code⟩ should not only construct a
path, it should also use this path in whatever way is appropriate. For
example, the ⟨code⟩ might fill some area with a uniform color.

Whatever the ⟨code⟩ does, it does it first. This means that any drawing
done by ⟨code⟩ will be even behind the background path.

Note that the ⟨code⟩ is protected with a {pgfscope}.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.behindbackgroundpath"
   },
   behindforegroundpath = {
      arguments = {
         {
            meta = "code"
         }
      },
      details = [[
The ⟨code⟩ is executed after the text labels have been drawn, but before
the foreground path is used.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.behindforegroundpath"
   },
   breakforeach = {
      details = [[
If this command is given inside a \foreach command, no further
executions of the ⟨commands⟩ will occur. However, the current execution
of the ⟨commands⟩ is continued normally, so it is probably best to use
this command only at the end of a \foreach command.

    \begin{tikzpicture}
      \foreach \x in {1,...,4}
        \foreach \y in {1,...,4}
        {
          \fill[red!50] (\x,\y) ellipse (3pt and 6pt);

          \ifnum \x<\y
            \breakforeach
          \fi
        }
    \end{tikzpicture}
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.breakforeach"
   },
   calendar = {
      arguments = {
         {
            meta = "calendar specification"
         },
         {
            literal = ";"
         }
      },
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.calendar"
   },
   chainin = {
      arguments = {
         {
            delimiters = {
               "(",
               ")"
            },
            meta = "existing name"
         },
         {
            delimiters = {
               "[",
               "]"
            },
            keys = "$ref:tikz#/keys/tikz",
            meta = "options",
            optional = true
         }
      },
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.chainin"
   },
   clip = {
      action = "tikzpath",
      arguments = {
         {
            delimiters = {
               "",
               ";"
            },
            meta = "specification"
         }
      },
      details = [[
Inside {tikzpicture} this is an abbreviation for \path[clip].
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.clip"
   },
   colorcurrentmixin = {
      details = [[
Expands to the current accumulated mix-in. Each nesting of a colormixin
adds a mix-in to this list.

    \begin{minipage}{\linewidth-6pt}\raggedright
    \begin{colormixin}{75!white}
      \colorcurrentmixin\ should be ``!75!white''\par
      \begin{colormixin}{75!black}
        \colorcurrentmixin\ should be ``!75!black!75!white''\par
        \begin{colormixin}{50!white}
          \colorcurrentmixin\ should be ``!50!white!75!black!75!white''\par
        \end{colormixin}
      \end{colormixin}
    \end{colormixin}
    \end{minipage}
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.colorcurrentmixin"
   },
   coordinate = {
      action = "tikzpath",
      arguments = {
         {
            delimiters = {
               "",
               ";"
            },
            meta = "specification"
         }
      },
      details = [[
Inside {tikzpicture} this is an abbreviation for \path coordinate.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.coordinate"
   },
   datavisualization = {
      action = "tikzpath",
      arguments = {
         {
            delimiters = {
               "",
               ";"
            },
            meta = "specification"
         }
      },
      details = [[
This command is available only inside a {tikzpicture} environment.

The ⟨data visualization options⟩ are used to configure the data
visualization, that is, how the data is to be depicted. The options are
executed with the path prefix /tikz/data visualization. This means that
normal TikZ options like thin or red cannot be used here. Rather, a
large number of options specific to data visualizations are available.

As a minimum, you should specify at least two options: First, you should
use an option that selects an axis system that is appropriate for your
plot. Typical possible keys are school book axes or scientific axes,
detailed information on them can be found in Section ??.

Second, you use an option to select how the data should be visualized.
This is done using a key like visualize as line which will, as the name
suggests, visualize the data by connecting data points in the plane
using a line. Similarly, visualize as smooth cycle will try to fit a
smooth cycle through the data points. Detailed information on possible
visualizers can be found in Section ??.

Following these options, the ⟨data specification⟩ is used to provide the
actual to-be-visualized data. The syntax is somewhat similar to commands
like \path: The ⟨data specification⟩ is a sequence of keywords followed
by local options and parameters, terminated with a semicolon. (Indeed,
like for the \path command, the ⟨data visualizers options⟩ need not be
specified at the beginning, but additional option surrounded by square
brackets may be given anywhere inside the ⟨data specification⟩.)

The different possible keywords inside the ⟨data specification⟩ are
explained in the following.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.datavisualization"
   },
   decoration = {
      arguments = {
         {
            meta = "name"
         }
      },
      details = [[
This sets the decoration for the current state to ⟨name⟩. If this
command is omitted, the moveto decoration will be used.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.decoration"
   },
   deferredanchor = {
      arguments = {
         {
            meta = "name"
         },
         {
            meta = "code"
         }
      },
      details = [[
This command declares an anchor named ⟨name⟩. It works like \anchor.
However, unlike for anchors declared by \anchor, ⟨name⟩ will not be
expanded during the shape declaration (i.e. not during
\pgfdeclareshape). Rather, the ⟨name⟩ is expanded when the node is
actually used (with \pgfnode or more likely with \node). This may be
useful if the anchor name is context dependent (depending, for example,
on the value of a key).

    \makeatletter
    \def\foo{foo}
    \pgfdeclareshape{simple shape}{%
      \savedanchor{\center}{%
        \pgfpointorigin}
      \anchor{center}{\center}
      \savedanchor{\anchorfoo}{%
        \pgf@x=1cm
        \pgf@y=0cm}
      \deferredanchor{anchor \foo}{\anchorfoo}}

    \begin{tikzpicture}
      \node[simple shape] (Test1) at (0,0) {};
      \fill (Test1.anchor foo) circle (2pt) node[below] {anchor foo anchor};
      %
      \def\foo{bar}
      \node[simple shape] (Test2) at (2,2) {};
      \fill (Test2.anchor bar) circle (2pt) node[below] {anchor bar anchor};
    \end{tikzpicture}
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.deferredanchor"
   },
   draw = {
      action = "tikzpath",
      arguments = {
         {
            delimiters = {
               "",
               ";"
            },
            meta = "specification"
         }
      },
      details = [[
Inside {tikzpicture} this is an abbreviation for \path[draw].
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.draw"
   },
   fill = {
      action = "tikzpath",
      arguments = {
         {
            delimiters = {
               "",
               ";"
            },
            meta = "specification"
         }
      },
      details = [[
Inside {tikzpicture} this is an abbreviation for \path[fill].
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.fill"
   },
   filldraw = {
      action = "tikzpath",
      arguments = {
         {
            delimiters = {
               "",
               ";"
            },
            meta = "specification"
         }
      },
      details = [[
Inside {tikzpicture} this is an abbreviation for \path[fill,draw].
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.filldraw"
   },
   foreach = {
      arguments = {
         {
            literal = " "
         },
         {
            meta = "variables"
         },
         {
            literal = " "
         }
      },
      details = [[
The syntax of this command is a bit complicated, so let us go through it
step-by-step.

In the easiest case, ⟨variables⟩ is a single TeX-command like \x or
\point. (If you want to have some fun, you can also use active
characters. If you do not know what active characters are, you are
blessed.)

Still in the easiest case, ⟨options⟩ will be omitted. The keys for
customizing this command will be discussed below.

Again, in the easiest case, ⟨list⟩ is either a comma-separated list of
values surrounded by curly braces or it is the name of a macro that
contain such a list of values. Anything can be used as a value, but
numbers are most likely.

Finally, in the easiest case, ⟨commands⟩ is some TeX-text in curly
braces.

With all these assumptions, the \foreach statement will execute the
⟨commands⟩ repeatedly, once for every element of the ⟨list⟩. Each time
the ⟨commands⟩ are executed, the ⟨variable⟩ will be set to the current
value of the list item.

    \foreach \x in {1,2,3,0} {[\x]}

    \def\mylist{1,2,3,0}
    \foreach \x in \mylist {[\x]}

Note that in each execution of ⟨commands⟩ the ⟨commands⟩ are put in a
TeX group. This means that local changes to counters inside ⟨commands⟩
do not persist till the next iteration. For instance, if you add 1 to a
counter inside ⟨commands⟩ locally, then in the next iteration the
counter will have the same value it had at the beginning of the first
iteration. You have to add \global if you wish changes to persist from
iteration to iteration.

Syntax for the commands. Let us move on to a more complicated setting.
The first complication occurs when the ⟨commands⟩ are not some text in
curly braces. If the \foreach statement does not encounter an opening
brace, it will instead scan everything up to the next semicolon and use
this as ⟨commands⟩. This is most useful in situations like the
following:

    \tikz
      \foreach \x in {0,1,2,3}
        \draw (\x,0) circle (0.2cm);

However, the "reading till the next semicolon" is not the whole truth.
There is another rule: If a \foreach statement is directly followed by
another \foreach statement, this second foreach statement is collected
as ⟨commands⟩. This allows you to write the following:

    \begin{tikzpicture}
      \foreach \x in {0,1,2,3}
        \foreach \y in {0,1,2,3}
          {
            \draw (\x,\y) circle (0.2cm);
            \fill (\x,\y) circle (0.1cm);
          }
    \end{tikzpicture}

The dots notation. The second complication concerns the ⟨list⟩. If this
⟨list⟩ contains the list item "...", this list item is replaced by the
"missing values". More precisely, the following happens:

Normally, when a list item ... is encountered, there should already have
been two list items before it, which where numbers. Examples of numbers
are 1, -10, or -0.24. Let us call these numbers $x$ and $y$ and let
$d := y-x$ be their difference. Next, there should also be one number
following the three dots, let us call this number $z$.

In this situation, the part of the list reading "$x$,$y$,...,$z$" is
replaced by "$x$, $x+d$, $x+2d$, $x+3d$, ..., $x+md$", where the last
dots are semantic dots, not syntactic dots. The value $m$ is the largest
number such that $x + md \le z$ if $d$ is positive or such that
$x+md \ge
    z$ if $d$ is negative.

Perhaps it is best to explain this by some examples: The following
⟨list⟩ have the same effects:

\foreach \x in {1,2,...,6} {\x, } yields in 1,2,...,6 ,

\foreach \x in {1,2,3,...,6} {\x, } yields in 1,2,3,...,6 ,

\foreach \x in {1,3,...,11} {\x, } yields in 1,3,...,11 ,

\foreach \x in {1,3,...,10} {\x, } yields in 1,3,...,10 ,

\foreach \x in {0,0.1,...,0.5} {\x, } yields in 0,0.1,...,0.5 ,

\foreach \x in {a,b,9,8,...,1,2,2.125,...,2.5} {\x, } yields in
a,b,9,8,...,1,2,2.125,...,2.5 ,

As can be seen, for fractional steps that are not multiples of $2^{-n}$
for some small $n$, rounding errors can occur pretty easily. Thus, in
the second last case, 0.5 should probably be replaced by 0.501 for
robustness.

There is another special case for the ... statement: If the ... is used
right after the first item in the list, that is, if there is an $x$, but
no $y$, the difference $d$ obviously cannot be computed and is set to
$1$ if the number $z$ following the dots is larger than $x$ and is set
to $-1$ if $z$ is smaller:

\foreach \x in {1,...,6} {\x, } yields in 1,...,6 ,

\foreach \x in {9,...,3.5} {\x, } yields in 9,...,3.5 ,

There is a yet another special case for the ... statement, in that it
can indicate an alphabetic character sequence:

\foreach \x in {a,...,m} {\x, } yields in a,...,m ,

\foreach \x in {Z,X,...,M} {\x, } yields in Z,X,...,M ,

A final special case for the ... statement is contextual replacement. If
the ... is used in some context, for example, sin(...), this context
will be interpreted correctly, provided that the list items prior to the
... statement have exactly the same pattern, except that, instead of
dots, they have a number or a character:

\foreach \x in {2^1,2^...,2^7} {\textbackslash x, } yields in
2^1,2^...,2^7 $\x$,

\foreach \x in {0\pi,0.5\pi,...\pi,3\pi} {\textbackslash x, } yields in
0,0.5,...,3 $\x$,

\foreach \x in {A_ 1,..._ 1,H_ 1} {\textbackslash x, } yields in
A_1,..._1,H_1 $\x$,

Special handling of pairs. Different list items are separated by commas.
However, this causes a problem when the list items contain commas
themselves as pairs like (0,1) do. In this case, you should put the
items containing commas in braces as in {(0,1)}. However, since pairs
are such a natural and useful case, they get a special treatment by the
\foreach statement. When a list item starts with a ( everything up to
the next ) is made part of the item. Thus, we can write things like the
following:

    \tikz
      \foreach \position in {(0,0), (1,1), (2,0), (3,1)}
        \draw \position rectangle +(.25,.5);

Using the foreach-statement inside paths. TikZ allows you to use foreach
and \foreach (both have the same effect) inside a path construction. In
such a case, the ⟨commands⟩ must be path construction commands. Here are
two examples:

    \tikz
      \draw (0,0)
        foreach \x in {1,...,3}
          { -- (\x,1) -- (\x,0) }
        ;

    \tikz \draw foreach \p in {1,...,3} {(\p,1)--(\p,3) (1,\p)--(3,\p)};

Note that the node and pic path commands also support the foreach
statement in special ways.

Multiple variables. You will often wish to iterate over two variables at
the same time. Since you can nest \foreach loops, this is normally
straight-forward. However, you sometimes wish variables to iterate
"simultaneously". For example, we might be given a list of edges that
connect two coordinates and might wish to iterate over these edges.
While doing so, we would like the source and target of the edges to be
set to two different variables.

To achieve this, you can use the following syntax: The ⟨variables⟩ may
not only be a single TeX-variable. Instead, it can also be a list of
variables separated by slashes (/). In this case the list items can also
be lists of values separated by slashes.

Assuming that the ⟨variables⟩ and the list items are lists of values,
each time the ⟨commands⟩ are executed, each of the variables in
⟨variables⟩ is set to one part of the list making up the current list
item. Here is an example to clarify this:

\foreach \x / \y in {1/2,a/b} {“\x\and \y”} yields / in 1/2,a/b " and ".

If some entry in the ⟨list⟩ does not have "enough" slashes, the last
entry will be repeated. Here is an example:

    \begin{tikzpicture}
      \foreach \x/\xtext in {0,...,3,2.72 / e}
        \draw (\x,0) node{$\xtext$};
    \end{tikzpicture}

Here are more useful examples:

    \begin{tikzpicture}
      % Define some coordinates:
      \path[nodes={circle,fill=yellow!80!black,draw}]
        (0,0)    node(a) {a}
        (2,0.55) node(b) {b}
        (1,1.5)  node(c) {c}
        (2,1.75) node(d) {d};

      % Draw some connections:
      \foreach \source/\target in {a/b, b/c, c/a, c/d}
        \draw (\source) .. controls +(.75cm,0pt) and +(-.75cm,0pt)..(\target);
    \end{tikzpicture}

    \begin{tikzpicture}
      % Let's draw circles at interesting points:
      \foreach \x / \y / \r in {0 / 0 / 2mm, 1 / 1 / 3mm, 2 / 0 / 1mm}
        \draw (\x,\y) circle (\r);

      % Same effect
      \foreach \center/\r in {{(0,0)/2mm}, {(1,1)/3mm}, {(2,0)/1mm}}
        \draw[yshift=2.5cm] \center circle (\r);
    \end{tikzpicture}

    \begin{tikzpicture}[line cap=round,line width=3pt]
      \filldraw [fill=yellow!80!black] (0,0) circle (2cm);

      \foreach \angle / \label in
        {0/3, 30/2, 60/1, 90/12, 120/11, 150/10, 180/9,
         210/8, 240/7, 270/6, 300/5, 330/4}
      {
        \draw[line width=1pt] (\angle:1.8cm) -- (\angle:2cm);
        \draw (\angle:1.4cm) node{\textsf{\label}};
      }

      \foreach \angle in {0,90,180,270}
        \draw[line width=2pt] (\angle:1.6cm) -- (\angle:2cm);

      \draw (0,0) -- (120:0.8cm); % hour
      \draw (0,0) -- (90:1cm);    % minute
    \end{tikzpicture}%

    \tikz[shading=ball]
      \foreach \x / \cola in {0/red,1/green,2/blue,3/yellow}
        \foreach \y / \colb in {0/red,1/green,2/blue,3/yellow}
          \shade[ball color=\cola!50!\colb] (\x,\y) circle (0.4cm);

Options to customize the foreach-statement.

The keys described below can be used in the ⟨options⟩ argument to the
\foreach command. They all have the path /pgf/foreach/, however, the
path is set automatically when ⟨options⟩ are parsed, so it does not have
to be explicitly stated.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.foreach"
   },
   foregroundpath = {
      arguments = {
         {
            meta = "code"
         }
      },
      details = [[
This command works like \backgroundpath, only it is invoked after the
text labels have been drawn. This means that this path can possibly
obscure (part of) the text labels.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.foregroundpath"
   },
   graph = {
      action = "tikzpath",
      arguments = {
         {
            delimiters = {
               "",
               ";"
            },
            meta = "specification"
         }
      },
      details = [[
Inside a {tikzpicture} this is an abbreviation for \path graph.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.graph"
   },
   ifdate = {
      arguments = {
         {
            meta = "tests"
         },
         {
            meta = "code"
         },
         {
            meta = "else code"
         }
      },
      details = [[
[ifdate] This command has the same effect as calling \pgfcalendarifdate
for the current date.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.ifdate"
   },
   inheritanchor = {
      arguments = {
         {
            literal = "[from="
         },
         {
            meta = "another shape name"
         },
         {
            literal = "]"
         },
         {
            meta = "name"
         }
      },
      details = [[
Inherits the code of one specific anchor named ⟨name⟩ from ⟨another
shape name⟩. Thus, unlike saved anchors, which must be inherited
collectively, normal anchors can and must be inherited individually.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.inheritanchor"
   },
   inheritanchorborder = {
      arguments = {
         {
            literal = "[from="
         },
         {
            meta = "another shape name"
         },
         {
            literal = "]"
         }
      },
      details = [[
Inherits the border anchor code from ⟨another shape name⟩.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.inheritanchorborder"
   },
   inheritbackgroundpath = {
      arguments = {
         {
            literal = "[from="
         },
         {
            meta = "another shape name"
         },
         {
            literal = "]"
         }
      },
      details = [[
Inherits the background path code from ⟨another shape name⟩.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.inheritbackgroundpath"
   },
   inheritbeforebackgroundpath = {
      arguments = {
         {
            literal = "[from="
         },
         {
            meta = "another shape name"
         },
         {
            literal = "]"
         }
      },
      details = [[
Inherits the before background path code from ⟨another shape name⟩.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.inheritbeforebackgroundpath"
   },
   inheritbeforeforegroundpath = {
      arguments = {
         {
            literal = "[from="
         },
         {
            meta = "another shape name"
         },
         {
            literal = "]"
         }
      },
      details = [[
Inherits the before foreground path code from ⟨another shape name⟩.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.inheritbeforeforegroundpath"
   },
   inheritbehindbackgroundpath = {
      arguments = {
         {
            literal = "[from="
         },
         {
            meta = "another shape name"
         },
         {
            literal = "]"
         }
      },
      details = [[
This command can be used to inherit the code used for the drawings
behind the background path from ⟨another shape name⟩.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.inheritbehindbackgroundpath"
   },
   inheritbehindforegroundpath = {
      arguments = {
         {
            literal = "[from="
         },
         {
            meta = "another shape name"
         },
         {
            literal = "]"
         }
      },
      details = [[
Inherits the behind foreground path code from ⟨another shape name⟩.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.inheritbehindforegroundpath"
   },
   inheritforegroundpath = {
      arguments = {
         {
            literal = "[from="
         },
         {
            meta = "another shape name"
         },
         {
            literal = "]"
         }
      },
      details = [[
Inherits the foreground path code from ⟨another shape name⟩.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.inheritforegroundpath"
   },
   inheritsavedanchors = {
      arguments = {
         {
            literal = "[from="
         },
         {
            meta = "another shape name"
         },
         {
            literal = "]"
         }
      },
      details = [[
This command allows you to inherit the code for saved anchors from
⟨another shape name⟩. The idea is that if you wish to create a new shape
that is just a small modification of a another shape, you can recycle
the code used for ⟨another shape name⟩.

The effect of this command is the same as if you had called \savedanchor
and \saveddimen for each saved anchor or saved dimension declared in
⟨another shape name⟩. Thus, it is not possible to "selectively" inherit
only some saved anchors, you always have to inherit all saved anchors
from another shape. However, you can inherit the saved anchors of more
than one shape by calling this command several times.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.inheritsavedanchors"
   },
   jobname = {
      details = [[
The value of \jobname is one of \tikzexternalrealjob or
\pgfactualjobname, depending on the configuration. In short: if
auxiliary file support (\label and \ref) is activated,
\jobname=\tikzexternalrealjob (since that's the base file name of
auxiliary files).
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.jobname"
   },
   matrix = {
      action = "tikzpath",
      arguments = {
         {
            delimiters = {
               "",
               ";"
            },
            meta = "specification"
         }
      },
      details = [[
Inside {tikzpicture} this is an abbreviation for \path node[matrix].
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.matrix"
   },
   method = {
      arguments = {
         {
            meta = "method name"
         },
         {
            delimiters = {
               "(",
               ")"
            },
            meta = "parameter list"
         },
         {
            meta = "method body"
         }
      },
      details = [[
This macro, which is only defined inside a class definition, defines a
new method named ⟨method name⟩. Just like class names, method names can
contain spaces and other characters, so ⟨method names⟩ like
put_ stamp_ here or put stamp here are both legal.

Three method names are special: First, a method having either the same
name as the class or having the name init is called the constructor of
the class. There are (currently) no destructors; objects simply become
"undefined" at the end of the scope in which they have been created. The
other two methods are called get id and get handle, which are always
automatically defined and which you cannot redefine. They are discussed
in Section ??.

Overloading of methods by differing numbers of parameters is not
possible, that is, it is illegal to have two methods inside a single
class with the same name (despite possibly different parameter lists).
However, two different classes may contain a method with the same name,
that is, classes form namespaces for methods. Also, a class can
(re)implement a method from a superclass.

The ⟨method name⟩ must be followed by a ⟨parameter list⟩ in parentheses,
which must be present even when the ⟨parameter list⟩ is empty. The
⟨parameter list⟩ is actually a normal TeX parameter list that will be
matched against the parameters inside the parentheses upon method
invocation and, thus, could be something like # 1# 2 foo # 3 bar., but a
list like # 1,# 2,# 3 is more customary. By setting the parameter list
to just # 1 and then calling, say, \pgfkeys{# 1} at the beginning of a
method, you can implement Objective-C-like named parameters.

When a method is called, the ⟨body⟩ of the method will be executed. The
main difference to a normal macro is that while the ⟨body⟩ is executed,
a special macro called \pgfoothis is set up in such a way that it
references the object for which the method is executed.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.method"
   },
   n = {
      arguments = {
         {
            meta = "number register"
         }
      },
      details = [[
When this macro is used on the left-hand side of an =-sign in a let
operation, it has no effect and is just there for readability. When the
macro is used on the right-hand side of an =-sign or in the body of the
let operation, then it expands to the value stored in the ⟨number
register⟩. This will either be a dimensionless number like 2.0 or a
dimension like 5.6pt.

For instance, if we say let \n1={1pt+2pt}, \n2={1+2} in ..., then inside
the ... part the macro \n1 will expand to 3pt and \n2 expands to 3.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.n"
   },
   node = {
      action = "tikzpath",
      arguments = {
         {
            delimiters = {
               "",
               ";"
            },
            meta = "specification"
         }
      },
      details = [[
Inside {tikzpicture} this is an abbreviation for \path node.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.node"
   },
   nodepart = {
      action = "tikzpath",
      arguments = {
         {
            delimiters = {
               "",
               ";"
            },
            meta = "specification"
         }
      },
      details = [[
This command can only be used inside the ⟨text⟩ argument of a node path
operation. It works a little bit like a \part command in LaTeX. It will
stop the typesetting of whatever node part was typeset until now and
then start putting all following text into the node part named ⟨part
name⟩ -- until another \partname is encountered or until the node ⟨text⟩
ends. The ⟨options⟩ will be local to this part.

    \begin{tikzpicture}
      \node [circle split,draw,double,fill=red!20]
      {
        % No \nodepart has been used, yet. So, the following is put in the
        % ``text'' node part by default.
        $q_1$
        \nodepart{lower} % Ok, end ``text'' part, start ``output'' part
        $00$
      }; % output part ended.
    \end{tikzpicture}

You will have to lookup which parts are defined by a shape.

The following styles influences node parts:
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.nodepart"
   },
   nodeparts = {
      arguments = {
         {
            meta = "list of node parts"
         }
      },
      details = [[
This command declares which parts make up nodes of this shape. A node
part is a (possibly empty) text label that is drawn when a node of the
shape is created.

By default, a shape has just one node part called text. However, there
can be several node parts. For example, the circle split shape has two
parts: the text part, which shows that the upper text, and a lower part,
which shows the lower text. For the circle split shape the \nodeparts
command was called with the argument {text,lower}.

When a multipart node is created, the text labels are drawn in the
sequences listed in the ⟨list of node parts⟩. For each node part, you
must have declared one anchor and the TeX-box of the part is placed at
this anchor. For a node part called XYZ the TeX-box \pgfnodepartXYZbox
is placed at anchor XYZ.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.nodeparts"
   },
   p = {
      arguments = {
         {
            meta = "point register"
         }
      },
      details = [[
When this macro is used on the left-hand side of an =-sign in a let
operation, it has no effect and is just there for readability. When the
macro is used on the right-hand side of an =-sign or in the body of the
let operation, then it expands to the $x$-part (measured in TeX points)
of the coordinate stored in the ⟨register⟩, followed, by a comma,
followed by the $y$-part.

For instance, if we say let \p1=(1pt,1pt+2pt) in ..., then inside the
... part the macro \p1 will expand to exactly the seven characters
"1pt,3pt". This means that you when you write (\p1), this expands to
(1pt,3pt), which is presumably exactly what you intended.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.p"
   },
   path = {
      action = "tikzpath",
      arguments = {
         {
            delimiters = {
               "",
               ";"
            },
            meta = "specification"
         }
      },
      details = [[
This command is available only inside a {tikzpicture} environment.

The ⟨specification⟩ is a long stream of path operations. Most of these
path operations tell TikZ how the path is built. For example, when you
write –(0,0), you use a line-to operation and it means "continue the
path from wherever you are to the origin".

At any point where TikZ expects a path operation, you can also give some
graphic options, which is a list of options in brackets, such as
[rounded corners]. These options can have different effects:

1.  Some options take "immediate" effect and apply to all subsequent
    path operations on the path. For example, the rounded corners option
    will round all following corners, but not the corners "before" and
    if the sharp corners is given later on the path (in a new set of
    brackets), the rounding effect will end.

        \tikz \draw (0,0) -- (1,1)
                   [rounded corners] -- (2,0) -- (3,1)
                   [sharp corners] -- (3,0) -- (2,1);

    Another example are the transformation options, which also apply
    only to subsequent coordinates.

2.  The options that have immediate effect can be "scoped" by putting
    part of a path in curly braces. For example, the above example could
    also be written as follows:

        \tikz \draw (0,0) -- (1,1)
                   {[rounded corners] -- (2,0) -- (3,1)}
                   -- (3,0) -- (2,1);

3.  Some options only apply to the path as a whole. For example, the
    color= option for determining the color used for, say, drawing the
    path always applies to all parts of the path. If several different
    colors are given for different parts of the path, only the last one
    (on the outermost scope) "wins":

        \tikz \draw (0,0) -- (1,1)
                   [color=red] -- (2,0) -- (3,1)
                   [color=blue] -- (3,0) -- (2,1);

    Most options are of this type. In the above example, we would have
    had to "split up" the path into several \path commands:

        \tikz{\draw (0,0) -- (1,1);
              \draw [color=red] (1,1) -- (2,0) -- (3,1);
              \draw [color=blue] (3,1) -- (3,0) -- (2,1);}

By default, the \path command does "nothing" with the path, it just
"throws it away". Thus, if you write \path(0,0)–(1,1);, nothing is drawn
in your picture. The only effect is that the area occupied by the
picture is (possibly) enlarged so that the path fits inside the area. To
actually "do" something with the path, an option like draw or fill must
be given somewhere on the path. Commands like \draw do this implicitly.

Finally, it is also possible to give node specifications on a path. Such
specifications can come at different locations, but they are always
allowed when a normal path operation could follow. A node specification
starts with node. Basically, the effect is to typeset the node's text as
normal TeX text and to place it at the "current location" on the path.
The details are explained in Section ??.

Note, however, that the nodes are not part of the path in any way.
Rather, after everything has been done with the path what is specified
by the path options (like filling and drawing the path due to a fill and
a draw option somewhere in the ⟨specification⟩), the nodes are added in
a post-processing step.

Note: When scanning for path operations TikZ expands tokens looking for
valid path operations. This however implies that these tokens has to be
fully expandable up to the point where it results in a valid path
operation.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.path"
   },
   pattern = {
      action = "tikzpath",
      arguments = {
         {
            delimiters = {
               "",
               ";"
            },
            meta = "specification"
         }
      },
      details = [[
Inside {tikzpicture} this is an abbreviation for \path[pattern].
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.pattern"
   },
   pic = {
      action = "tikzpath",
      arguments = {
         {
            delimiters = {
               "",
               ";"
            },
            meta = "specification"
         }
      },
      details = [[
Inside {tikzpicture} this is an abbreviation for \path pic.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.pic"
   },
   rule = {
      arguments = {
         {
            literal = "{"
         },
         {
            meta = "head"
         }
      },
      details = [[
Declare a rule. ⟨head⟩ should consist of a single symbol, which need not
have been declared using \symbol or exist as a default symbol (in fact,
the more interesting L-systems depend on using symbols with no
corresponding code, to control the "growth" of the system). ⟨body⟩
consists of a string of symbols, which again need not necessarily have
any code associated with them.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.rule"
   },
   savedanchor = {
      arguments = {
         {
            meta = "command"
         },
         {
            meta = "code"
         }
      },
      details = [[
This command declares a saved anchor. The argument ⟨command⟩ should be a
TeX macro name like \centerpoint.

The ⟨code⟩ will be executed each time \pgfnode (or \pgfmultipartnode) is
called to create a node of the shape ⟨shape name⟩. When the ⟨code⟩ is
executed, the TeX-boxes of the node parts will contain the text labels
of the node. Possibly, these box are void. For example, if there is just
a text part, the node \pgfnodeparttextbox will be set up when the ⟨code⟩
is executed.

The ⟨code⟩ can use the width, height, and depth of the box(es) to
compute the location of the saved anchor. In addition, the ⟨code⟩ can
take into account the values of dimensions like \pgfshapeminwidth or
\pgfshapeinnerxsep. Furthermore, the ⟨code⟩ can take into consideration
the values of any further shape-specific variables that are set at the
moment when \pgfnode is called.

The net effect of the ⟨code⟩ should be to set the two TeX dimensions
\pgf@x and \pgf@y. One way to achieve this is to say \pgfpoint{⟨x
value⟩}{⟨y value⟩} at the end of the ⟨code⟩, but you can also just set
these variables. The values that \pgf@x and \pgf@y have after the code
has been executed, let us call them $x$ and $y$, will be recorded and
stored together with the node that is created by the command \pgfnode.

The macro ⟨command⟩ is defined to be \pgfpoint{$x$}{$y$}. However, the
⟨command⟩ is only locally defined while anchor positions are being
computed. Thus, it is possible to use very simple names for ⟨command⟩,
like \center or \a, without causing a name-clash. (To be precise, very
simple ⟨command⟩ names will clash with existing names, but only locally
inside the computation of anchor positions; and we do not need the
normal \center command during these computations.)

For our simple rectangle shape, we will need only one saved anchor: The
upper right corner. The lower left corner could either be the origin or
the "mirrored" upper right corner, depending on whether we want the text
label to have its lower left corner at the origin or whether the text
label should be centered on the origin. Either will be fine, for the
final shape this will make no difference since the shape will be shifted
anyway. So, let us assume that the text label is centered on the origin
(this will be specified later on using the text anchor). We get the
following code for the upper right corner:

    \savedanchor{\upperrightcorner}{
      \pgf@y=.5\ht\pgfnodeparttextbox % height of the box, ignoring the depth
      \pgf@x=.5\wd\pgfnodeparttextbox % width of the box
    }

If we wanted to take, say, the \pgfshapeminwidth into account, we could
use the following code:

    \savedanchor{\upperrightcorner}{
      \pgf@y=.\ht\pgfnodeparttextbox % height of the box
      \pgf@x=.\wd\pgfnodeparttextbox % width of the box
      \setlength{\pgf@xa}{\pgfshapeminwidth}
      \ifdim\pgf@x<.5\pgf@xa
        \pgf@x=.5\pgf@xa
      \fi
    }

Note that we could not have written .5\pgfshapeminwidth since the
minimum width is stored in a "plain text macro", not as a real
dimension. So if \pgfshapeminwidth depth were 2cm, writing
.5\pgfshapeminwidth would yield the same as .52cm.

In the "real" rectangle shape the code is somewhat more complex, but you
get the basic idea.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.savedanchor"
   },
   saveddimen = {
      arguments = {
         {
            meta = "command"
         },
         {
            meta = "code"
         }
      },
      details = [[
This command is similar to \savedanchor, only instead of setting
⟨command⟩ to \pgfpoint{$x$}{$y$}, the ⟨command⟩ is set just to (the
value of) $x$.

In the simple rectangle shape we might use a saved dimension to store
the depth of the shape box.

    \saveddimen{\depth}{
      \pgf@x=\dp\pgfnodeparttextbox
    }
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.saveddimen"
   },
   savedmacro = {
      arguments = {
         {
            meta = "command"
         },
         {
            meta = "code"
         }
      },
      details = [[
This command is similar to \saveddimen, only at some point in ⟨code⟩,
⟨command⟩ should be defined appropriately, (this could be a value, or
some text).

In the regular polygon shape, a saved macro is used to store the number
of sides of the polygon.

    \savedmacro{\sides}{\let\sides\pgfpolygonsides}
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.savedmacro"
   },
   scoped = {
      arguments = {
         {
            meta = "animations spec"
         },
         {
            delimiters = {
               "[",
               "]"
            },
            keys = "$ref:tikz#/keys/tikz",
            meta = "options",
            optional = true
         },
         {
            meta = "path command"
         }
      },
      details = [[
This command works like \tikz, only you can use it inside a
{tikzpicture}. It will take the following ⟨path command⟩ and put it
inside a {scope} with the ⟨options⟩ set. The ⟨path command⟩ may either
be a single command ended by a semicolon or it may contain multiple
commands, but then they must be surrounded by curly braces.

    \begin{tikzpicture}
      \node [fill=white] at (1,1) {Hello world};
      \scoped [on background layer]
        \draw (0,0) grid (3,2);
    \end{tikzpicture}
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.scoped"
   },
   shade = {
      action = "tikzpath",
      arguments = {
         {
            delimiters = {
               "",
               ";"
            },
            meta = "specification"
         }
      },
      details = [[
Inside {tikzpicture} this is an abbreviation for \path[shade].
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.shade"
   },
   shadedraw = {
      action = "tikzpath",
      arguments = {
         {
            delimiters = {
               "",
               ";"
            },
            meta = "specification"
         }
      },
      details = [[
Inside {tikzpicture} this is an abbreviation for \path[shade,draw].
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.shadedraw"
   },
   spy = {
      arguments = {
         {
            delimiters = {
               "[",
               "]"
            },
            keys = "$ref:tikz#/keys/tikz",
            meta = "options",
            optional = true
         },
         {
            literal = "on"
         },
         {
            meta = "coordinate"
         }
      },
      details = [[
This command can only be used inside a spy scope. Let us start with the
syntax:

-   The \spy command is not a special case of \path. Rather, it has a
    small parser of its own.

-   Following the optional ⟨options⟩, you must write on, followed by a
    coordinate. This coordinate will be the center of the area that is
    to be magnified.

-   Following the ⟨coordinate⟩, you must write in node followed by some
    ⟨node options⟩. The syntax for these options is the same as for a
    normal node path command, such as [left] or (foo) [red] at (bar).
    However, ⟨node options⟩ are not followed by a curly brace. Rather,
    the ⟨node options⟩ must directly be followed by a semicolon.

The effect of this command is the following: The ⟨options⟩,
⟨coordinate⟩, and ⟨node options⟩ are stored internally till the end of
the current spy scope. This means that, in particular, you can reference
any node inside the spy scope, even if it is not yet defined when the
\spy command is given. At the end of the current spy scope, two nodes
are created, called the spy-in node and the spy-on node.

-   The spy-in node is the node that contains a magnified part of the
    picture (the node in which we see on what we spy). This node is,
    indeed, a normal TikZ node, so you can use all standard options to
    style this node. In particular, you can specify a shape or a border
    color or a drop shadow or whatever. The only thing that is special
    about this node is that instead of containing some normal text, its
    "text" is the magnified picture.

    To be precise, the picture of the spy scope is scaled by a certain
    factor, specified by the lens or magnification options discussed
    below, and is shifted in such a way that the ⟨coordinate⟩ lies at
    the center of the spy-on node.

-   The spy-on node is a node that is centered on the ⟨coordinate⟩ and
    whose size reflects exactly the area shown inside the spy-in node
    (the node containing on what we spy).

Let us now go over what happens in detail when the two nodes are
created:

1.  A scope is started. Two sets of options are used with this scope:
    First, the options passed to the enclosing spy scope and then the
    ⟨options⟩ (which will, thus, overrule the options of the spy scope).

2.  Then, the spy-on node is created. However, we will first discuss the
    spy-in node.

3.  The spy-in node is created after the spy-on node (and, hence, will
    cover the spy-on node in case they overlap). When this node is
    created, the ⟨node options⟩ are used in addition to the effect
    caused by the ⟨options⟩ and the options of the {spy scope}.
    Additionally, the following style is used:

    The position of the node (the at option) is set to the ⟨coordinate⟩
    by default, so that it will cover the to-be-magnified area. You can
    change this by providing the at option yourself:

        \begin{tikzpicture}
          [spy using outlines={circle, magnification=3, size=1cm}]

          \draw [decoration=Koch curve type 1]
            decorate{ decorate{ decorate{ (0,0) -- (2,0) }}};

          \spy [red]  on (1.6,0.3) in node;
          \spy [blue] on (1,1)     in node at (1,-1);
        \end{tikzpicture}

    No "text" can be specified for the node. Rather, the "text" shown
    inside this node is the picture of the current spy scope, but
    canvas-transformed according to the following key:

    Since the most common transformation is undoubtedly a simple
    scaling, there is a special style for this:

    Now, usually the size of a node is determined in such a way that it
    "fits" around the text of the node. For a spy-on node this is not a
    good approach since the "text" of this node would contain "the whole
    picture". Because of this, TikZ acts as if the "text" of the node
    has zero size. You must then use keys like minimum size to cause the
    node to have a certain size. Note that the key size is an
    abbreviation for minimum size inside a spy scope.

    You can name the spy-on node in the usual ways. Additionally, the
    node is (also) always named tikzspyinnode. Following the spy scope,
    you can use this node like any other node:

        \begin{tikzpicture}
          \begin{scope}
            [spy using outlines={circle, magnification=3, size=2cm, connect spies}]

            \draw [decoration=Koch curve type 1]
              decorate{ decorate{ decorate{ (0,0) -- (2,0) }}};

            \spy [red] on (1.6,0.3) in node (a) [left] at (3.5,-1.25);

            \spy [blue, size=1cm] on (1,1) in node (b) [right] at (0,-1.25);
          \end{scope}
          \draw [ultra thick, green!50!black] (b) -- (a.north west);
        \end{tikzpicture}

4.  Once both nodes have been created, the current value of the
    following key is used to connect them:

Returning to the creation of the spy-in node: This node is centered on
⟨coordinate⟩ (more precisely, its anchor is set to center and the at
option is set to ⟨coordinate⟩). Its size and shape are initially
determined in the same way as the size and shape of the spy-on node
(unless, of course, you explicitly provide a different shape for, say,
the spy-on node locally, which is not really a good idea). Then,
additionally, the inverted transformation done by the lens option is
applied, resulting in a node whose size and shape exactly corresponds to
the area in the picture that is shown in the spy-on node.

    \begin{tikzpicture}
      [spy using outlines={lens={scale=3,rotate=20}, size=2cm, connect spies}]

      \draw [decoration=Koch curve type 1]
        decorate{ decorate{ decorate{ (0,0) -- (2,0) }}};

      \spy [red] on (1.6,0.3) in node at (2.5,-1.25);
    \end{tikzpicture}

Like for the spy-in node, a style can be used to format the spy-on node:

The spy-on node is named tikzspyonnode (but, as always, this node is
only available after the spy scope). If you have multiple spy-on nodes
and you would like to access all of them, you need to use the name key
inside the every spy on node style.

The inner sep and outer sep of both spy-in and spy-on nodes are set to
0pt.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.spy"
   },
   state = {
      arguments = {
         {
            meta = "name"
         },
         {
            delimiters = {
               "[",
               "]"
            },
            keys = "$ref:tikz#/keys/tikz",
            meta = "options",
            optional = true
         },
         {
            meta = "code"
         }
      },
      details = [[
Declares the state ⟨name⟩ inside the current meta-decoration automaton.
Unlike decorations, states in meta-decorations are not executed within a
group, which makes the persistent computation options superfluous.
Consider using an initial state with width=0pt to do precalculations
that could speed the execution of the meta-decoration.

The ⟨options⟩ are executed with the key path set to
/pgf/meta-decorations automaton/, and the following keys are defined for
this path:

The code in ⟨code⟩ is quite different from the code in a decoration
state. In almost all cases only the following three macros will be
required:

There are some macros that may be useful when creating meta-decorations
(note that they are all macros):
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.state"
   },
   symbol = {
      arguments = {
         {
            meta = "name"
         },
         {
            meta = "code"
         }
      },
      details = [[
This defines a symbol called ⟨name⟩ for a specific L-system, and
associates it with ⟨code⟩.

A symbol should consist of a single alpha-numeric character (i.e., A-Z,
a-z or 0-9). The symbols F, f, +, -, [ and ] are available by default so
do not need to be defined for each L-system. However, if you are feeling
adventurous, they can be redefined for specific L-systems if required.
The L-system treats the default symbols as follows (the commands they
execute are described below):

-   F move forward a certain distance, drawing a line. Uses
    \pgflsystemdrawforward.

-   f move forward a certain distance, without drawing a line. Uses
    \pgflsystemmoveforward.

-   + turn left by some angle. Uses \pgflsystemturnleft.

-   - turn right by some angle. Uses \pgflsystemturnright.

-   [ save the current state (i.e., the position and direction). Uses
    \pgflsystemsavestate.

-   ] restore the last saved state. Uses \pgflsystemrestorestate.

The symbols [ and ] act like a stack: [ pushes the state of the L-system
on to the stack, and ] pops a state off the stack.

When ⟨code⟩ is executed, the transformation matrix is set up so that the
origin is at the current position and the positive x-axis "points
forward", so \pgfpathlineto{\pgfpoint{1cm}{0cm}} draws a line 1cm
forward.

The following keys can alter the production of an L-system. However,
they do not store values in themselves.

For speed and convenience, when the code for a symbol is executed, the
following commands are available.

The following commands may be useful if you wish to define your own
symbols.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.symbol"
   },
   tikz = {
      arguments = {
         {
            meta = "animations spec"
         },
         {
            delimiters = {
               "[",
               "]"
            },
            keys = "$ref:tikz#/keys/tikz",
            meta = "options",
            optional = true
         },
         {
            meta = "path commands"
         }
      },
      details = [[
This command places the ⟨path commands⟩ inside a {tikzpicture}
environment. The ⟨path commands⟩ may contain paragraphs and fragile
material (like verbatim text).

If there is only one path command, it need not be surrounded by curly
braces, if there are several, you need to add them (this is similar to
the \foreach statement and also to the rules in programming languages
like Java or C concerning the placement of curly braces).

\tikz{\draw (0,0) rectangle (2ex,1ex);} yields [PICTURE]

\tikz \draw (0,0) rectangle (2ex,1ex); yields [PICTURE]
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikz"
   },
   tikzaliascoordinatesystem = {
      arguments = {
         {
            meta = "new name"
         },
         {
            meta = "old name"
         }
      },
      details = [[
Creates an alias of ⟨old name⟩.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzaliascoordinatesystem"
   },
   tikzappendtofigurename = {
      arguments = {
         {
            meta = "suffix"
         }
      },
      details = [[
Appends ⟨suffix⟩ to the actual value of figure name.

It is a shortcut for \tikzset{external/figure name/.add={}{suffix}} (a
shortcut which is also supported if TikZ is not installed, see below).
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzappendtofigurename"
   },
   tikzdeclarecoordinatesystem = {
      arguments = {
         {
            meta = "name"
         },
         {
            meta = "code"
         }
      },
      details = [[
This command declares a new coordinate system named ⟨name⟩ that can
later on be used by writing (⟨name⟩ cs:⟨arguments⟩). When
TikZ encounters a coordinate specified in this way, the ⟨arguments⟩ are
passed to ⟨code⟩ as argument # 1.

It is now the job of ⟨code⟩ to make sense of the ⟨arguments⟩. At the end
of ⟨code⟩, the two TeX dimensions \pgf@x and \pgf@y should be have the
$x$- and $y$-canvas coordinate of the coordinate.

It is not necessary, but customary, to parse ⟨arguments⟩ using the
key--value syntax. However, you can also parse it in any way you like.

In the following example, a coordinate system cylindrical is defined.

    \makeatletter
    \define@key{cylindricalkeys}{angle}{\def\myangle{#1}}
    \define@key{cylindricalkeys}{radius}{\def\myradius{#1}}
    \define@key{cylindricalkeys}{z}{\def\myz{#1}}
    \tikzdeclarecoordinatesystem{cylindrical}%
    {%
      \setkeys{cylindricalkeys}{#1}%
      \pgfpointadd{\pgfpointxyz{0}{0}{\myz}}{\pgfpointpolarxy{\myangle}{\myradius}}
    }
    \begin{tikzpicture}[z=0.2pt]
      \draw [->] (0,0,0) -- (0,0,350);
      \foreach \num in {0,10,...,350}
        \fill (cylindrical cs:angle=\num,radius=1,z=\num) circle (1pt);
    \end{tikzpicture}
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzdeclarecoordinatesystem"
   },
   tikzdeclarepattern = {
      arguments = {
         {
            meta = "config"
         }
      },
      details = [[
A pattern declared with \pgfdeclarepattern can only execute PGF code.
This command extends the functionality to also allow TikZ code. All the
same keys of \pgfdeclarepattern are valid, but some of them have been
overloaded to give a more natural TikZ syntax.

In addition to the overloaded keys, some new keys have been added.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzdeclarepattern"
   },
   tikzdvdeclarestylesheetcolorseries = {
      arguments = {
         {
            meta = "name"
         },
         {
            meta = "color model"
         },
         {
            meta = "initial color"
         },
         {
            meta = "step"
         }
      },
      details = [[
This command creates a new style sheet using \pgfdvdeclarestylesheet.
This style sheet will only have a default style setup that maps numbers
to the color in the color series starting with ⟨initial color⟩ and
having a stepping of ⟨step⟩. Note that when the value of the attribute
is 1, which it is the first data set, the second color in the color
series is used (since counting starts at 0 for color series). Thus, in
general, you need to start the ⟨initial color⟩ "one early".

        data point [x=2, y=2,       set=normal]
        data point [x=0, y=1,       set=heated]
        data point [x=2, y=1,       set=heated]
        data point [x=0.5, y=1.5,   set=critical]
        data point [x=2.25, y=1.75, set=critical]
    };},
    ]
    \tikzdvdeclarestylesheetcolorseries{greens}{hsb}{0.3,1.3,0.8}{0,-.4,-.1}
    \tikz \datavisualization [
      school book axes,
      visualize as line=normal,
      visualize as line=heated,
      visualize as line=critical,
      style sheet=greens]
    data group {lines};
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzdvdeclarestylesheetcolorseries"
   },
   tikzexternaldisable = {
      details = [[
Allows to disable the complete externalization. While export next will
still collect the contents of picture environments, this command
uninstalls the hooks for the external library completely. Thus, nested
picture environments or environments where \end{tikzpicture} is not
directly reachable won't produce compilation failures -- although it is
not possible to externalize them automatically.

The externalization remains disabled until the end of the next TeX group
(or environment) or until the next call to \tikzexternalenable.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzexternaldisable"
   },
   tikzexternalenable = {
      details = [[
Re-enables a previously running externalization after
\tikzexternaldisable.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzexternalenable"
   },
   tikzexternalfiledependsonfile = {
      arguments = {
         {
            meta = "external graphics"
         },
         {
            meta = "file name"
         }
      },
      details = [[
A variant of \tikzpicturedependsonfile which adds a dependency for an
⟨external graphics⟩. The argument ⟨external graphics⟩ must be the path
as it would have been generated by the external library, i.e. without
file extension but including any prefixes.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzexternalfiledependsonfile"
   },
   tikzexternalize = {
      arguments = {
         {
            delimiters = {
               "[",
               "]"
            },
            meta = "optional arguments",
            optional = true
         }
      },
      details = [[
This command activates the externalization. It installs commands to
replace every TikZ-picture. It needs to be called before
\begin{document} because it may need to install its separate shipout
routine.

The ⟨optional arguments⟩ can be any of the keys described below.

Note that the generation/modification of auxiliary files like .aux, .toc
etc. is usually suppressed while a single image is externalized (details
for \label support follow).

It is also possible to write \tikzexternalize{main job name} if the
argument is delimited by curly braces. This case is mainly for backwards
compatibility and is no longer necessary. Since it might be useful in
rare circumstances, it is documented in section ??.

A detailed description about the process of externalization is provided
in section ??.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzexternalize"
   },
   tikzexternalrealjob = {
      details = [[
After the library is loaded, this macro will always contain the correct
main job's name (in the example above, it is main). It is to be used
instead of \jobname when the externalization is in effect.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzexternalrealjob"
   },
   tikzfading = {
      arguments = {
         {
            delimiters = {
               "[",
               "]"
            },
            keys = "$ref:tikz#/keys/tikz",
            meta = "options",
            optional = true
         }
      },
      details = [[
This command is used to define a fading similarly to the way a shading
is defined. In the ⟨options⟩ you should

1.  use the name=⟨name⟩ option to set a name for the fading,

2.  use the shading option to set the name of the shading that you wish
    to use,

3.  extra options for setting the colors of the shading (typically you
    will set them to the color transparent!⟨percentage⟩).

Then, a new fading named ⟨name⟩ will be created based on the shading.

    \tikzfading[name=fade right,
                left color=transparent!0,
                right color=transparent!100]

    % Now we use the fading in another picture:
    \begin{tikzpicture}
      % Background
      \fill [black!20] (-1.2,-1.2) rectangle (1.2,1.2);
      \path [pattern=checkerboard,pattern color=black!30]
                       (-1.2,-1.2) rectangle (1.2,1.2);

      \fill [red,path fading=fade right] (-1,-1) rectangle (1,1);
    \end{tikzpicture}

    \tikzfading[name=fade out,
                inner color=transparent!0,
                outer color=transparent!100]

    % Now we use the fading in another picture:
    \begin{tikzpicture}
      % Background
      \fill [black!20] (-1.2,-1.2) rectangle (1.2,1.2);
      \path [pattern=checkerboard,pattern color=black!30]
                       (-1.2,-1.2) rectangle (1.2,1.2);

      \fill [blue,path fading=fade out] (-1,-1) rectangle (1,1);
    \end{tikzpicture}
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzfading"
   },
   tikzgraphforeachcolorednode = {
      arguments = {
         {
            meta = "color name"
         },
         {
            meta = "macro"
         }
      },
      details = [[
When this command is called inside ⟨code⟩, the following will happen:
TikZ will iterate over all nodes inside the just-specified group that
have the color ⟨color name⟩. The order in which they are iterated over
is the order in which they appear inside the group specification (if a
node is encountered several times inside the specification, only the
first occurrence counts). Then, for each node the ⟨macro⟩ is executed
with the node's name as the only argument.

In the following example we use an operator to connect every node
colored all inside the subgroup to he node root.

    \def\myconnect#1{\tikzset{graphs/new ->={root}{#1}{}{}}}

    \begin{tikzpicture}
      \node (root) at (-1,-1) {root};

      \graph {
        x,
        {
          [operator=\tikzgraphforeachcolorednode{all}{\myconnect}]
          a, b, c
        }
      };
    \end{tikzpicture}
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzgraphforeachcolorednode"
   },
   tikzgraphnodefullname = {
      details = [[
This macro contains the concatenation of the above two.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzgraphnodefullname"
   },
   tikzgraphnodename = {
      details = [[
This macro expands to the name of the current node without the path.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzgraphnodename"
   },
   tikzgraphnodepath = {
      details = [[
This macro expands to the current path of the node. These paths result
from the use of the name key as described above.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzgraphnodepath"
   },
   tikzgraphnodetext = {
      details = [[
This macro expands to the ⟨text⟩ to the right of the double underscore
or slash in a direct node specification or, if there is no slash, to the
⟨node name⟩.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzgraphnodetext"
   },
   tikzgraphpreparecolor = {
      arguments = {
         {
            meta = "color name"
         },
         {
            meta = "counter"
         },
         {
            meta = "prefix"
         }
      },
      details = [[
This command is used to "prepare" the nodes of a certain color for
random access. The effect is the following: It is counted how many nodes
there are having color ⟨color name⟩ in the current group and the result
is stored in ⟨counter⟩. Next, macros named ⟨prefix⟩1, ⟨prefix⟩2, and so
on are defined, that store the names of the first, second, third, and so
on node having the color ⟨color name⟩.

The net effect is that after you have prepared a color, you can quickly
iterate over them. This is especially useful when you iterate over
several color at the same time.

As an example, let us create an operator then adds a zig-zag path
between two color classes:

    \newcount\leftshorecount   \newcount\rightshorecount
    \newcount\mycount          \newcount\myothercount
    \def\zigzag{
      \tikzgraphpreparecolor{left shore}\leftshorecount{left shore prefix}
      \tikzgraphpreparecolor{right shore}\rightshorecount{right shore prefix}
      \mycount=0\relax
      \loop
        \advance\mycount by 1\relax%
        % Add the "forward" edge
        \tikzgraphsset{new ->=
          {\csname left shore prefix\the\mycount\endcsname}
          {\csname right shore prefix\the\mycount\endcsname}{}{}}
        \myothercount=\mycount\relax%
        \advance\myothercount by1\relax%
        \tikzgraphsset{new <-=
          {\csname left shore prefix\the\myothercount\endcsname}
          {\csname right shore prefix\the\mycount\endcsname}{}{}}
      \ifnum\myothercount<\leftshorecount\relax
      \repeat
    }
    \begin{tikzpicture}
      \graph [color class=left shore, color class=right shore]
      { [operator=\zigzag]
        { [left shore, Cartesian placement]                      a, b, c },
        { [right shore, Cartesian placement, nodes={xshift=1cm}] d, e, f }
      };
    \end{tikzpicture}

Naturally, in order to turn the above code into a usable operator, some
more code would be needed (like default values and taking care of shores
of different sizes).
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzgraphpreparecolor"
   },
   tikzgraphsset = {
      arguments = {
         {
            keys = "$ref:tikz#/keys/tikz",
            meta = "options"
         }
      },
      details = [[
Executes the ⟨options⟩ with the path prefix /tikz/graphs.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzgraphsset"
   },
   tikzifexternalizing = {
      arguments = {
         {
            meta = "true code"
         },
         {
            meta = "false code"
         }
      },
      details = [[
This command can be used to check whether an image is currently written
to its separate graphics file (if the "grab" procedure is running). If
so, the {true code} will be executed. If not, that means if the main
document is being typeset normally, the {false code} will be invoked.

This command must be used after \tikzexternalize.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzifexternalizing"
   },
   tikzifexternalizingnext = {
      arguments = {
         {
            meta = "true code"
         },
         {
            meta = "false code"
         }
      },
      details = [[
Like \tikzifexternalizing, but this variant also checks if the next
following figure is the one which is about to be written to its separate
graphics file.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzifexternalizingnext"
   },
   tikzinputsegmentfirst = {
      details = [[
The first point on the current input segment path.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzinputsegmentfirst"
   },
   tikzinputsegmentlast = {
      details = [[
The last point on the current input segment path.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzinputsegmentlast"
   },
   tikzinputsegmentsupporta = {
      details = [[
The first support on the curveto input segment path.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzinputsegmentsupporta"
   },
   tikzinputsegmentsupportb = {
      details = [[
The second support on the curveto input segment path.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzinputsegmentsupportb"
   },
   tikzlastnode = {
      details = [[
Expands to the last node on the path.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzlastnode"
   },
   tikzmath = {
      details = [[
This command process a series of ⟨statements⟩ which can represent
assignments, function definitions, conditional evaluation, and
iterations. It provides, in effect, a miniature mathematical language to
perform basic mathematical operations. Perhaps the most important thing
to remember is that every statement should end with a semi-colon. This
is likely to be the most common reason why the \tikzmath command fails.

    \tikzmath{
      % Adapted from http://www.cs.northwestern.edu/academics/courses/110/html/fib_rec.html
      function fibonacci(\n) {
        if \n == 0 then {
          return 0;
        } else {
           return fibonacci2(\n, 0, 1);
         };
      };
      function fibonacci2(\n, \p, \q) {
        if \n == 1 then {
          return \q;
        } else {
          return fibonacci2(\n-1, \q, \p+\q);
        };
      };
      int \f, \i;
      for \i in {0,1,...,20} {
        \f = fibonacci(\i);
        print {\f, };
      };
    }
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzmath"
   },
   tikzpicturedependsonfile = {
      arguments = {
         {
            meta = "file name"
         }
      },
      details = [[
Adds a dependency for the next picture which is about to be
externalized. If the command is invoked within a picture environment, it
adds a dependency for the surrounding picture. Dependencies are written
into ⟨target file⟩.dep in the format

⟨target file⟩.\tikzexternalimgextension: ⟨file name⟩.

The effect is that if ⟨file name⟩ changes, the external graphics
associated with the picture shall be remade.

This command uses the contents of \tikzexternalimgextension to check for
graphics. If you encounter difficulties with image extensions, consider
redefining this macro (after \tikzexternalize).

Limitations:

this command is currently only supported for mode=list and make and the
generated makefile.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzpicturedependsonfile"
   },
   tikzrdfhashmark = {
      details = [[
Expands to #  with catcode 11.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzrdfhashmark"
   },
   tikzset = {
      arguments = {
         {
            keys = "$ref:tikz#/keys/tikz",
            meta = "options"
         }
      },
      details = [[
This command will process the ⟨options⟩ using the \pgfkeys command,
documented in detail in Section ??, with the default path set to /tikz.
Under normal circumstances, the ⟨options⟩ will be lists of
comma-separated pairs of the form ⟨key⟩=⟨value⟩, but more fancy things
can happen when you use the power of the pgfkeys mechanism, see
Section ?? once more.

When a pair ⟨key⟩=⟨value⟩ is processed, the following happens:

1.  If the ⟨key⟩ is a full key (starts with a slash) it is handled
    directly as described in Section ??.

2.  Otherwise (which is usually the case), it is checked whether
    /tikz/⟨key⟩ is a key and, if so, it is executed.

3.  Otherwise, it is checked whether /pgf/⟨key⟩ is a key and, if so, it
    is executed.

4.  Otherwise, it is checked whether ⟨key⟩ is a color and, if so,
    color=⟨key⟩ is executed.

5.  Otherwise, it is checked whether ⟨key⟩ contains a dash and, if so,
    arrows=⟨key⟩ is executed.

6.  Otherwise, it is checked whether ⟨key⟩ is the name of a shape and,
    if so, shape=⟨key⟩ is executed.

7.  Otherwise, an error message is printed.

Note that by the above description, all keys starting with /tikz and
also all keys starting with /pgf can be used as ⟨key⟩s in an ⟨options⟩
list.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzset"
   },
   tikzsetexternalprefix = {
      arguments = {
         {
            meta = "file name prefix"
         }
      },
      details = [[
Assigns a common prefix used by all file names. For example,

    \tikzsetexternalprefix{figures/}

will prepend figures/ to every external graphics file name.

Please note that \tikzsetexternalprefix is the only way to assign a
prefix in case you want to prepare your document for environments where
PGF is not installed (see section ??).
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzsetexternalprefix"
   },
   tikzsetfigurename = {
      arguments = {
         {
            meta = "name"
         }
      },
      details = [[
Changes the names of all following figures. It is possible to change
figure name during the document either using
\tikzset{external/figure name={name}} or with this command. A unique
counter will be used for each different {name}, and each counter will
start at $0$.

The value of prefix will be applied after figure name has been
evaluated.

    \documentclass{article}
    % main document, called main.tex
    \usepackage{tikz}

    \usetikzlibrary{external}
    \tikzexternalize % activate

    \begin{document}

    \begin{tikzpicture} % will be written to 'main-figure0.pdf'
      \node {root}
        child {node {left}}
        child {node {right}
          child {node {child}}
          child {node {child}}
        };
    \end{tikzpicture}

    {
      \tikzsetfigurename{subset_}
      A simple image is \tikz \fill (0,0) circle(5pt);. % will be written to 'subset_0.pdf'

      \begin{tikzpicture} % will be written to 'subset_1.pdf'
         \draw[help lines] (0,0) grid (5,5);
      \end{tikzpicture}
    }% here, the old file name will be restored:

    \begin{tikzpicture} % will be written to 'main-figure1.pdf'
       \draw (0,0) -- (5,5);
    \end{tikzpicture}
    \end{document}

The scope of figure name ends with the next closing brace.

Remark: Use \tikzset{external/figure name/.add={prefix_ }{_ suffix_ }}
to add a prefix_  and a _ suffix_  to the actual value of figure name.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzsetfigurename"
   },
   tikzsetnextfilename = {
      arguments = {
         {
            meta = "file name"
         }
      },
      details = [[
Sets the file name for the next TikZ picture or \tikz short command. It
will only be used for the next picture.

Pictures for which no explicit file name has been set (or the next file
name is empty) will get automatically generated file names.

Please note that prefix will still be prepended to {file name}.

    \documentclass{article}
    % main document, called main.tex
    \usepackage{tikz}

    \usetikzlibrary{external}
    \tikzexternalize[prefix=figures/] % activate

    \begin{document}

    \tikzsetnextfilename{trees}
    \begin{tikzpicture} % will be written to 'figures/trees.pdf'
      \node {root}
        child {node {left}}
        child {node {right}
          child {node {child}}
          child {node {child}}
        };
    \end{tikzpicture}

    \tikzsetnextfilename{simple}
    A simple image is \tikz \fill (0,0) circle(5pt);. % will be written to 'figures/simple.pdf'

    \begin{tikzpicture} % will be written to 'figures/main-figure0.pdf'
       \draw[help lines] (0,0) grid (5,5);
    \end{tikzpicture}
    \end{document}

    pdflatex -shell-escape main
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.tikzsetnextfilename"
   },
   useasboundingbox = {
      action = "tikzpath",
      arguments = {
         {
            delimiters = {
               "",
               ";"
            },
            meta = "specification"
         }
      },
      details = [[
Inside {tikzpicture} this is an abbreviation for
\path[use as bounding box].
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.useasboundingbox"
   },
   usegdlibrary = {
      arguments = {
         {
            meta = "list of libraries"
         }
      },
      details = [[
This command is used to load the special graph drawing libraries (the gd
in the name of the command stands for "graph drawing"). The ⟨list of
libraries⟩ is a comma-separated list of library written in the Lua
programming language (which is why a special command is needed).

In detail, this command does the following. For each ⟨name⟩ in the ⟨list
of libraries⟩ we do:

1.  Check whether LuaTeX can call require on the library file
    pgf.gd.⟨name⟩.library. LuaTeX's usual file search mechanism will
    search the texmf-trees in the usual manner and the dots in the file
    name get converted into directory slashes.

2.  If the above failed, try to require the string pgf.gd.⟨name⟩.

3.  If this fails, try to require the string ⟨name⟩.library.

4.  If this fails, try to require the string ⟨name⟩. If this fails,
    print an error message.

The net effect of the above is the following: Authors of graph drawing
algorithms can bundle together multiple algorithms in a library by
creating a ...xyz/library.lua file that internally just calls require
for all files containing declarations. On the other hand, if a graph
drawing algorithm completely fits inside a single file, it can also be
read directly using \usegdlibrary.

    \usetikzlibrary{graphdrawing}
    \usegdlibrary{trees,force}

The different graph drawing libraries are documented in the following
Sections ?? to ??.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.usegdlibrary"
   },
   usetikzlibrary = {
      arguments = {
         {
            meta = "list of libraries"
         }
      },
      details = [[
Once TikZ has been loaded, you can use this command to load further
libraries. The list of libraries should contain the names of libraries
separated by commas. Instead of curly braces, you can also use square
brackets, which is something ConTeXt users will like. If you try to load
a library a second time, nothing will happen.

\usetikzlibrary{arrows.meta}

The above command will load a whole bunch of extra arrow tip
definitions.

What this command does is to load the file tikzlibrary⟨library⟩.code.tex
for each ⟨library⟩ in the ⟨list of libraries⟩. If this file does not
exist, the file pgflibrary⟨library⟩.code.tex is loaded instead. If this
file also does not exist, an error message is printed. Thus, to write
your own library file, all you need to do is to place a file of the
appropriate name somewhere where TeX can find it. LaTeX, plain TeX, and
ConTeXt users can then use your library.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.usetikzlibrary"
   },
   value = {
      arguments = {
         {
            meta = "variable"
         }
      },
      details = [[
This expands to the current value of the key /data point/⟨variable⟩.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.value"
   },
   x = {
      arguments = {
         {
            meta = "point register"
         }
      },
      details = [[
This macro expands just to the $x$-part of the point register. If we say
as above, as we did above, let \p1=(1pt,1pt+2pt) in ..., then inside the
... part the macro \x1 expands to 1pt.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.x"
   },
   y = {
      arguments = {
         {
            meta = "point register"
         }
      },
      details = [[
Works like \x, only for the $y$-part.
]],
      documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf.y"
   }
}
keys = {
   ["data visualization"] = {
      about = {
         details = [[
This key asks the data visualization to place about ⟨number⟩ many ticks
on an axis. It is not guaranteed that exactly ⟨number⟩ many ticks will
be used, rather the actual number will be the closest number of ticks to
⟨number⟩ so that their stepping is still "good". For instance, when you
say about=10, it may happen that exactly 10, but perhaps even 13 ticks
are actually selected, provided that these numbers of ticks lead to good
stepping values like 5 or 2.5 rather than numbers like 3.4 or 7. The
method that is used to determine which steppings a deemed to be "good"
depends on the current tick placement strategy.

Linear steps. Let us start with linear steps: First, the difference
between the maximum value $v_{\max}$ and the minimum value $v_{\min}$ on
the axis is computed; let us call it $r$ for "range". Then, $r$ is
divided by ⟨number⟩, yielding a target stepping $s$. If $s$ is a number
like $1$ or $5$ or $10$, then this number could be used directly as the
new value of step. However, $s$ will typically something strange like
$0.023\,45$ or $345\,223.76$, so $s$ must be replaced by a better value
like $0.02$ in the first case and perhaps $250\,000$ in the second case.

In order to determine which number is to be used, $s$ is rewritten in
the form $m \cdot 10^k$ with $1 \le m < 10$ and $k \in \mathbb Z$. For
instance, $0.023\,45$ would be rewritten as $2.345 \cdot 10^{-2}$ and
$345\,223.76$ as $3.452\,2376 \cdot 10^5$. The next step is to replace
the still not-so-good number $m$ like $2.345$ or $3.452\,237$ by a
"good" value $m'$. For this, the current value of the about strategy is
used:

Once $m'$ has been determined, the stepping is set to
$s' = m' \cdot 10^k$.

The net effect of all this is that for the default strategy the only
valid stepping are the values $1$, $2$, $2.5$ and $5$ and every value
obtainable by multiplying one of these values by a power of ten. The
following example shows the effects of, first, setting about=5
(corresponding to the some option) and then having axes where the
minimum value is always 0 and where the maximum value ranges from 10 to
100 and, second, setting about to the values from 3 (corresponding to
the few option) and to 10 (corresponding to the many option) while
having the minimum at 0 and the maximum at 100:

Exponential steps. For exponential steps the strategy for determining a
good stepping value is similar to linear steps, but with the following
differences:

-   Naturally, since the stepping value refers to the exponent, the
    whole computation of a good stepping value needs to be done "in the
    exponent". Mathematically spoken, instead of considering the
    difference $r = v_{\max} - v_{\min}$, we consider the difference $r
                = \log v_{\max} - \log v_{\min}$. With this difference,
    we still compute $s = r / ⟨number⟩$ and let $s = m \cdot 10^k$ with
    $1
                \le m < 10$.

-   It makes no longer sense to use values like $2.5$ for $m'$ since
    this would yield a fractional exponent. Indeed, the only sensible
    values for $m'$ seem to be $1$, $3$, $6$, and $10$. Because of this,
    the about strategy is ignored and one of these values or a multiple
    of one of them by a power of ten is used.

The following example shows the chosen steppings for a maximum varying
from $10^1$ to $10^5$ and from $10^{10}$ to $10^{50}$ as well as for
$10^{100}$ for about=3:

Alternative strategies.

In addition to the standard about strategy, there are some additional
strategies that you might wish to use instead:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/about",
         meta = "⟨number⟩"
      },
      ["about strategy"] = {
         details = [[
The ⟨list⟩ is a comma-separated sequence of pairs ⟨threshold⟩/⟨value⟩
like for instance 1.5/1.0 or 2.3/2.0. When a good value $m'$ is sought
for a given $m$, we iterate over the list and find the first pair
⟨threshold⟩/⟨value⟩ where ⟨threshold⟩ exceeds $m$. Then $m'$ is set to
⟨value⟩. For instance, if ⟨list⟩ is 1.5/1.0,2.3/2.0,4/2.5,7/5,11/10,
which is the default, then for $m=3.141$ we would get $m'=2.5$ since
$4 >
        3.141$, but $2.3 \le 3.141$. For $m=6.3$ we would get $m'=5$.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/about:strategy",
         meta = "⟨list⟩"
      },
      ["after creation"] = {
         details = [[
This code is executed right after the object has just been created. A
handle to the just-created object is available in \tikzdvobj.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/after:creation",
         meta = "⟨code⟩"
      },
      ["after survey"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/after:survey",
         meta = "⟨code⟩"
      },
      ["after visualization"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/after:visualization",
         meta = "⟨code⟩"
      },
      ["all axes"] = {
         details = [[
This key passes the ⟨options⟩ to all axes inside the current scope, just
as if you had written ⟨some axis name⟩=⟨options⟩ for each ⟨some axis
name⟩ in the current scope, including the just-created name ⟨axis name⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/all:axes",
         meta = "⟨options⟩"
      },
      ["also at"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/also:at",
         meta = "⟨list⟩"
      },
      arg1 = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/arg1",
         meta = "⟨value⟩"
      },
      ["arg1 from key"] = {
         details = [[
Works like the arg1, only the value that is passed to the constructor is
the current value of the specified ⟨key⟩ at the moment when the object
is created.

    \tikzdatavisualizationset{
      new object={
        class              = example class,
        arg1 from key      = /tikz/some key
      }
    }
    \tikzset{some key/.initial=foobar}

causes the following to be executed:

    \pgfoonew \tikzdvobj=new example class(foobar)

Naturally, the keys arg2 from key to arg8 from key are also provided.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/arg1:from:key",
         meta = "⟨key⟩"
      },
      ["arg1 handle from key"] = {
         details = [[
Works like the arg1 from key, only the key must store an object and
instead of the object a handle to the object is passed to the
constructor.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/arg1:handle:from:key",
         meta = "⟨key⟩"
      },
      at = {
         details = [[
Basically, the ⟨list⟩ must be a list of values that is processed with
the \foreach macro (thus, it can contain ellipses to specify ranges of
value). Empty values are skipped.

The effect of passing at to a major, minor, or subminor key is that
ticks or grid lines on the axis will be placed exactly at the values in
⟨list⟩. Here is an example:

    \tikz \datavisualization
      [ school book axes, visualize as smooth line,
        x axis={ticks={major={at={-1,0.5,(pi/2)}}}}]
      data [format=function] {
        var x : interval [-1.25:2];
        func y = \value x * \value x / 2;
      };

When this option is used, any previously specified tick positions are
overwritten by the values in ⟨list⟩. Automatically computed ticks are
also overwritten. Thus, this option gives you complete control over
where ticks should be placed.

Normally, the individual values inside the ⟨list⟩ are just numbers that
are specified in the same way as an attribute value. However, such a
value may also contain the keyword as, which allows you so specify the
styling of the tick in detail. Section ?? details how this works.

It is often a bit cumbersome that one has to write things like

    some axis = {ticks = {major = {at = {...}}}}

A slight simplification is given by the following keys, which can be
passed directly to ticks and grid:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/at",
         meta = "⟨list⟩"
      },
      ["at end survey"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/at:end:survey",
         meta = "⟨code⟩"
      },
      ["at end visualization"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/at:end:visualization",
         meta = "⟨code⟩"
      },
      ["at start survey"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/at:start:survey",
         meta = "⟨code⟩"
      },
      ["at start visualization"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/at:start:visualization",
         meta = "⟨code⟩"
      },
      ["axis layer"] = {
         details = [[
The layer on which the axis is drawn. See the description of grid layer
on page ?? for details.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:layer"
      },
      ["axis option/anchor at max"] = {
         details = [[
Like anchor at min.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:option/anchor:at:max"
      },
      ["axis option/anchor at min"] = {
         details = [[
When passed to an axis, this key sets the anchor so that a node
positioned at either the min or the padded min value of the axis will be
placed "nicely" with respect to the axis. For instance, if the axis
points upwards from the min value to the max value, the anchor would be
set to north since this gives a label below the axis's start. Similarly,
if the axis points right, the anchor would be set to east, and so on.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:option/anchor:at:min"
      },
      ["axis options/attribute"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/attribute",
         meta = "⟨attribute⟩"
      },
      ["axis options/degrees"] = {
         details = [[
When this key is passed to the angle axis of a polar axis system, it
sets up the scaling so that a value of 360 on this axis corresponds to a
complete circle.

    \tikz \datavisualization
        [new polar axes={angle axis}{radius axis},
         radius axis={unit length=1cm},
         angle axis={degrees},
         visualize as scatter]
      data [format=named] {
        angle={10,90}, radius={0.25,0.5,...,2}
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/degrees"
      },
      ["axis options/exponential steps"] = {
         details = [[
This strategy produces ticks at positions that are appropriate for
logarithmic plots. It is automatically selected when you use the
logarithmic option with an axis.

In detail, the following happens: As for linear steps let numbers $a$,
$b$, $s$, and $p$ be given. Then, major ticks are placed at all
positions $10^{i\cdot s+p}$ that lie in the interval $[a,b]$ for
$i \in \mathbb{Z}$.

The minor steps are added in the same way as for linear steps. In
particular, they interpolate linearly between major steps.

    \begin{tikzpicture}
      \datavisualization
        [scientific axes,
         x axis={logarithmic, length=2cm, ticks={step=1.5}},
         y axis={logarithmic, ticks={step=1, minor steps between steps=9}},
         visualize as scatter]
        data {
          x, y
          1, 10
          1000, 1000000
        };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/exponential:steps"
      },
      ["axis options/function"] = {
         details = [[
The ⟨code⟩ should specify a function $f$ that is applied during the
transformation of the interval $[s_1,s_2]$ to the interval $[t_1,t_2]$
in the following way: When the ⟨code⟩ is called, the macro \pgfvalue
will have been set to an internal representation of the
to-be-transformed value $v$. You can then call the commands of the
math-micro-kernel of the data visualization system, see Section ??, to
compute a new value. This new value must once more be stored in
\pgfvalue.

The most common use of this key is to say

    some axis={function=\pgfdvmathln{\pgfvalue}{\pgfvalue}}

This specifies that the function $f$ is the logarithm function.

    \tikz \datavisualization
       [scientific axes,
        x axis={ticks={major={at={1,10,100,1000}}},
                 scaling=1 at 0cm and 1000 at 3cm,
                 function=\pgfdvmathln{\pgfvalue}{\pgfvalue}},
        visualize as scatter]
      data [format=named] {
        x={1,100,...,1000}, y={1,2,3}
      };

Another possibility might be to use the square-root function, instead:

    \tikz \datavisualization
       [scientific axes,
        x axis={ticks=few,
                scaling=1 at 0cm and 1000 at 3cm,
                function=\pgfdvmathunaryop{\pgfvalue}{sqrt}{\pgfvalue}},
        visualize as scatter]
      data [format=named] {
        x={0,100,...,1000}, y={1,2,3}
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/function",
         meta = "⟨code⟩"
      },
      ["axis options/goto"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/goto",
         meta = "⟨value⟩"
      },
      ["axis options/goto pos"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/goto:pos",
         meta = "⟨fraction⟩"
      },
      ["axis options/grid"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/grid",
         meta = "⟨options⟩"
      },
      ["axis options/include value"] = {
         details = [[
This key "fakes" data points for which the attribute's values are in the
comma-separated ⟨list of values⟩. For instance, when you write
include value=0, then the attribute range interval is guaranteed to
contain 0 -- even if the actual data points are all positive or all
negative.

    \tikz \datavisualization [scientific axes, all axes={length=3cm},
                              visualize as line]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };

    \tikz \datavisualization [scientific axes, all axes={length=3cm},
                              visualize as line,
                              x axis={include value=20},
                              y axis={include value=0}]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/include:value",
         meta = "⟨list of value⟩"
      },
      ["axis options/label"] = {
         details = [[
This key sets the label of an axis to ⟨text⟩. This text will typically
be placed inside a node and the ⟨options⟩ can be used to further
configure the way this node is rendered. The ⟨options⟩ will be executed
with the path prefix /tikz/data visualization/, so you need to say
node style to configure the styling of a node, see Section ??.

    \tikz \datavisualization [
        scientific axes,
        x axis = {label, length=2.5cm},
        y axis = {label={[node style={fill=blue!20}]{$x^2$}}},
        visualize as smooth line]
     data [format=function] {
       var x : interval [-3:5];
       func y = \value x * \value x;
     };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/label",
         meta = "{[⟨options⟩]}⟨text⟩"
      },
      ["axis options/length"] = {
         details = [[
Sets scaling to min at 0cm and max at ⟨dimension⟩. The effect is that
the range of all values of the axis's attribute will be mapped to an
interval of exact length ⟨dimension⟩.

    \tikz \datavisualization [scientific axes,
                              x axis={length=3cm},
                              y axis={length=2cm},
                              all axes={ticks=few},
                              visualize as line]
        data {
          x, y
          10, 10
          20, 20
          15, 30
          13, 20
        };

    \tikz \datavisualization [scientific axes,
                              x axis={length=3cm},
                              y axis={length=4cm},
                              all axes={ticks=few},
                              visualize as line]
        data {
          x, y
          10, 10
          20, 20
          15, 30
          13, 20
        };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/length",
         meta = "⟨dimension⟩"
      },
      ["axis options/linear steps"] = {
         details = [[
This strategy places ticks at positions that are evenly spaced by the
current value of step.

In detail, the following happens: Let $a$ be the minimum value of the
data values along the axis and let $b$ be the maximum. Let the current
stepping be $s$ (the stepping is set using the step option, see below)
and let the current phasing be $p$ (set using the phase) option. Then
ticks are placed all positions $i\cdot s + p$ that lie in the interval
$[a,b]$, where $i$ ranges over all integers.

The tick positions computed in the way described above are major step
positions. In addition to these, if the key minor steps between steps is
set to some number $n$, then $n$ many minor ticks are introduced between
each two major ticks (and also before and after the last major tick,
provided the values still lie in the interval $[a,b]$). Note that is $n$
is $1$, then one minor tick will be added in the middle between any two
major ticks. Use a value of $9$ (not $10$) to partition the interval
between two major ticks into ten equally sized minor intervals.

    \begin{tikzpicture}
      \datavisualization
        [scientific axes={inner ticks, width=3cm},
         x axis={ticks={step=3, minor steps between steps=2}},
         y axis={ticks={step=.36}},
         visualize as scatter]
        data {
          x, y
          17, 30
          34, 32
        };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/linear:steps"
      },
      ["axis options/logarithmic"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/logarithmic"
      },
      ["axis options/max value"] = {
         details = [[
Works like min value.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/max:value",
         meta = "⟨value⟩"
      },
      ["axis options/min value"] = {
         details = [[
This key allows you to simply set the minimum value, regardless of which
values are present in the actual data. This key should be used with
care: If there are data points for which the attribute's value is less
than ⟨value⟩, they will still be depicted, but typically outside the
normal visualization area. Usually, saying include value=⟨value⟩ will
achieve the same as saying min value=⟨value⟩, but with less danger of
creating ill-formed visualizations.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/min:value",
         meta = "⟨value⟩"
      },
      ["axis options/padding"] = {
         details = [[
Sets both padding min to the negated value of ⟨dimension⟩ and
padding max to ⟨dimension⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/padding",
         meta = "⟨dimension⟩"
      },
      ["axis options/padding max"] = {
         details = [[
Works like padding min, but ⟨dimension⟩ should typically be positive.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/padding:max",
         meta = "⟨dimension⟩"
      },
      ["axis options/padding min"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/padding:min",
         meta = "⟨dimension⟩"
      },
      ["axis options/power unit length"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/power:unit:length",
         meta = "⟨dimension⟩"
      },
      ["axis options/radians"] = {
         details = [[
In contrast to degrees, this option sets up things so that a value of
2*pi on this axis corresponds to a complete circle.

    \tikz \datavisualization
        [new polar axes={angle axis}{radius axis},
         radius axis={unit length=1cm},
         angle axis={radians},
         visualize as scatter]
      data [format=named] {
        angle={0,1.5}, radius={0.25,0.5,...,2}
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/radians"
      },
      ["axis options/scaling"] = {
         details = [[
The ⟨scaling spec⟩ must have the following form:

  ⟨$s_1$⟩ at ⟨$t_1$⟩ and ⟨$s_2$⟩ at ⟨$t_2$⟩

This means that monitored values in the interval $[s_1,s_2]$ should be
mapped to values the "reasonable" interval $[t_1,t_2]$, instead. For
instance, we might write

    [y axis = {scaling = 1900 at 0cm and 2000 at 5cm}]

in order to map dates between 1900 and 2000 to the dimension interval
$[0\mathrm{cm},5\mathrm{cm}]$.

    \tikz \datavisualization
       [scientific axes,
        x axis={attribute=people, length=2.5cm, ticks=few},
        y axis={attribute=year, scaling=1900 at 0cm and 2000 at 5cm},
        visualize as scatter]
      data {
        year, people
        1900, 100
        1910, 200
        1950, 200
        1960, 250
        2000, 150
      };

So much for the basic idea. Let us now have a detailed look at what
happens.

Number format and the min and max keywords. The source values $s_1$ and
$s_2$ are typically just numbers like 3.14 or 10000000000. However, as
described in Section ??, you can also specify expressions like (pi/2),
provided that (currently) you put them in parentheses.

Instead of a number, you may alternatively also use the two key words
min and max for $s_1$ and/or $s_2$. In this case, min evaluates to the
smallest value observed for the attribute in the data, symmetrically max
evaluates to the largest values. For instance, in the above example with
the year attribute ranging from 1900 to 2000, the keyword min would
stand for 1900 and max for 2000. Similarly, for the people attribute min
stands for 100 and max for 250. Note that min and max can only be used
for $s_1$ and $s_2$, not for $t_1$ and $t_2$.

A typical use of the min and max keywords is to say

    scaling = min at 0cm and max at 5cm

to map the complete range of values into an interval of length of 5cm.

The interval $[s_1,s_2]$ need not contain all values that the
⟨attribute⟩ may attain. It is permissible that values are less than
$s_1$ or more than $s_2$.

Linear transformation of the attribute. As indicated earlier, the main
job of an axis is to map values from a "large" interval $[s_1,s_2]$ to a
more reasonable interval $[t_1,t_2]$. Suppose that for the current data
point the value of the key /data point/⟨attribute⟩ is the number $v$. In
the simplest case, the following happens: A new value $v'$ is computed
so that $v' = t_1$ when $v=s_1$ and $v'=t_2$ when $v=s_2$ and $v'$ is
some value in between $t_1$ and $t_2$ then $v$ is some value in between
$s_1$ and $s_2$. (Formally, in this basic case
$v' = t_1 + (v-s_1)\frac{t_2-t_1}{s_2-s_1}$.)

Once $v'$ has been computed, it is stored in the key
/data point/⟨attribute⟩/scaled. Thus, the "reasonable" value $v'$ does
not replace the value of the attribute, but it is placed in a different
key. This means that both the original value and the more "scaled"
values are available when the data point is visualized.

As an example, suppose you have written

    [x axis = {attribute = x, scaling=1000 at 20 and 2000 at 30}]

Now suppose that /data point/x equals 1200 for a data point. Then the
key /data point/x/scaled will be set to 22 when the data point is being
visualized.

Nonlinear transformations of the attribute. By default, the
transformation of $[s_1,s_2]$ to $[t_1,t_2]$ is the linear
transformation described above. However, in some case you may be
interested in a different kind of transformation: For example, in a
logarithmic plot, values of an attribute may range between, say, 1 and
1000 and we want an axis of length 3cm. So, we would write

    [x axis = {attribute = x, scaling=1 at 0cm and 1000 at 3cm}]

Indeed, 1 will now be mapped to position 0cm and 1000 will be mapped to
position 3cm. Now, the value 10 will be mapped to approximately 0.03cm
because it is (almost) at one percent between 1 and 1000. However, in a
logarithmic plot we actually want 10 to be mapped to the position 1cm
rather than 0.03cm and we want 100 to be mapped to the position 2cm.
Such a mapping a nonlinear mapping between the intervals.

In order to achieve such a nonlinear mapping, the function key can be
used, whose syntax is described in a moment. The effect of this key is
to specify a function $f \colon \mathbb{R} \to \mathbb{R}$ like, say,
the logarithm function. When such a function is specified, the mapping
of $v$ to $v'$ is computed as follows: $$\begin{aligned}
        v' = t_1 + (f(s_2) - f(v))\frac{t_2 - t_1}{f(s_2)-f(s_1)}.
    \end{aligned}$$

The syntax of the function key is described next, but you typically will
not call this key directly. Rather, you will use a key like logarithmic
that installs appropriate code for the function key for you.

Default scaling. When no scaling is specified, it may seem natural to
use $[0,1]$ both as the source and the target interval. However, this
would not work when the logarithm function is used as transformations:
In this case the logarithm of zero would be computed, leading to an
error. Indeed, for a logarithmic axis it is far more natural to use
$[1,10]$ as the source interval and $[0,1]$ as the target interval.

For these reasons, the default value for the scaling that is used when
no value is specified explicitly can be set using a special key:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/scaling",
         meta = "⟨scaling spec⟩"
      },
      ["axis options/scaling/default"] = {
         details = [[
The ⟨text⟩ is used as scaling whenever no other scaling is specified.
This key is mainly used when a transformation function is set using
function; normally, you will not use this key directly.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/scaling/default",
         meta = "⟨text⟩"
      },
      ["axis options/tick placement strategy"] = {
         details = [[
This key can be used to install a so-called tick placement strategy.
Whenever visualize ticks is used to request some ticks to be visualized,
it is checked whether some automatic ticks should be created. This is
the case when the following key is set:

Provided compute step is set to some nonempty value, upon visualization
of ticks the ⟨macro⟩ is executed. Typically, ⟨macro⟩ will first call the
⟨code⟩ stored in the key compute step. Then, it should implement some
strategy then uses the value of the computed or desired stepping to
create appropriate at commands. To be precise, it should set the keys
major, minor, and/or subminor with some appropriate at values.

Inside the call of ⟨macro⟩, the macro \tikzdvaxis will have been set to
the name of the axis for which default ticks need to be computed. This
allows you to access the minimum and the maximum value stored in the
scaling mapper of that axis.

    \def\silly{
      \tikzdatavisualizationset{major={at={
            2,3,5,7,11,13}}}
    }
    \begin{tikzpicture}
      \datavisualization [
        scientific axes, visualize as scatter,
        x axis={tick placement strategy=\silly}
        ]
        data {
          x, y
          0, 0
          15, 15
        };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/tick:placement:strategy",
         meta = "⟨macro⟩"
      },
      ["axis options/ticks"] = {
         details = [[
This key can be passed to an axis in order to configure which ticks are
present for the axis. The possible ⟨options⟩ include, for instance, keys
like step, which is used to specify a stepping for the ticks, but also
keys like major or minor for specifying the positions of major and minor
ticks in detail. The list of possible options is described in the rest
of this section.

Note that the ticks option will only configure which ticks should be
shown in principle. The actual rendering is done only when the
visualize ticks key is used, documented in Section ??, which is
typically done only internally by an axis system.

The ⟨options⟩ will be executed with the path prefix
/tikz/data visualization/. When the ticks key is used multiple times for
an axis, the ⟨options⟩ accumulate.

    \tikz \datavisualization [
      scientific axes, visualize as line,
      x axis={ticks={step=24, minor steps between steps=3},
              label=hours}]
      data {
        x, y
        0, 0
        10, 0
        20, 0.5
        30, 0.75
        40, 0.7
        50, 0.6
        60, 0.5
        70, 0.45
        80, 0.47
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/ticks",
         meta = "⟨options⟩"
      },
      ["axis options/ticks and grid"] = {
         details = [[
This key passes the ⟨options⟩ to both the ticks key and also to the grid
key. This is useful when you want to specify some special points
explicitly where you wish a tick to be shown and also a grid line.

    \tikz \datavisualization
      [scientific axes,
       visualize as smooth line,
       all axes= {grid, unit length=1.25cm},
       y axis={ ticks=few },
       x axis={ ticks=many, ticks and grid={ major also at={(pi/2) as $\frac{\pi}{2}$}}}]
      data [format=function] {
        var x : interval [-pi/2:3*pi] samples 50;
        func y = sin(\value x r);
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/ticks:and:grid",
         meta = "⟨options⟩"
      },
      ["axis options/unit length"] = {
         details = [[
Sets scaling to 0 at 0cm and 1 at ⟨dimension⟩. In other words, this key
allows you to specify how long a single unit should be. This key is
particularly useful when you wish to ensure that the same scaling is
used across multiple axes or pictures.

    \tikz \datavisualization [scientific axes,
                              all axes={ticks=few, unit length=1mm},
                              visualize as line]
        data {
          x, y
          10, 10
          40, 20
          15, 30
          13, 20
        };

The optional per ⟨number⟩ units allows you to apply more drastic
scaling. Suppose that you want to plot a graph where one billion
corresponds to one centimeter. Then the unit length would be need to be
set to a hundredth of a nanometer -- much too small for TeX to handle as
a dimension. In this case, you can write
unit length=1cm per 1000000000 units:

    \tikz \datavisualization
      [scientific axes,
       x axis={unit length=1mm per 1000000000 units, ticks=few},
       visualize as line]
     data {
       x, y
       10000000000, 10
       40000000000, 20
       15000000000, 30
       13000000000, 20
     };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/unit:length",
         meta = "⟨dimension⟩ per ⟨number⟩ units"
      },
      ["axis options/unit vector"] = {
         details = [[
Recall that an axis takes the values of an attribute and rescales them
so that they fit into a "reasonable" interval $[t_1,t_2]$. Suppose that
$v'$ is the rescaled dimension in (TeX) points. Then when the data point
is visualized, the coordinate system will be shifted by $v'$ times the
⟨coordinate⟩.

As an example, suppose that you have said
scaling=0 and 10pt and 50 and 20pt. Then when the underlying attribute
has the value 25, it will be mapped to a $v'$ of $15$ (because 25 lies
in the middle of 0 and 50 and 15pt lies in the middle of 10pt and 20pt).
This, in turn, causes the data point to be displaced by $15$ times the
⟨coordinate⟩.

The bottom line is that the ⟨coordinate⟩ should usually denote a point
that is at distance 1pt from the origin and that points into the
direction of the axis.

    \begin{tikzpicture}
      \draw [help lines] (0,0) grid (3,2);

      \datavisualization
        [new Cartesian axis=x axis, x axis={attribute=x},
         new Cartesian axis=y axis, y axis={attribute=y},
         x axis={unit vector=(0:1pt)},
         y axis={unit vector=(60:1pt)},
         visualize as scatter]
      data {
        x, y
        0, 0
        1, 0
        2, 0
        1, 1
        2, 1
        1, 1.5
        2, 1.5
      };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/unit:vector",
         meta = "⟨coordinate⟩"
      },
      ["axis options/unit vectors"] = {
         details = [[
Both the ⟨unit vector 0 degrees⟩ and the ⟨unit vector 90 degrees⟩ are
TikZ coordinates:

    \tikz \datavisualization
        [new polar axes={angle axis}{radius axis},
         radius axis={unit length=1cm},
         angle axis={unit vectors={(10:1pt)}{(60:1pt)}},
         visualize as scatter]
      data [format=named] {
        angle={0,90}, radius={0.25,0.5,...,2}
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/unit:vectors",
         meta = " {⟨unit vector 0 degrees⟩}{⟨unit vector 90 degrees⟩}"
      },
      ["axis options/visualize axis"] = {
         details = [[
This key is passed to an axis as an option. It causes a visual
representation of the axis to be created during the data visualization.
The ⟨options⟩ are used to determine where the axis should be drawn and
how long it should be. We can specify, for instance, that an axis should
be drawn at the minimum value of another axis or where another axis has
the value 0.

The goto, high, and low Keys. In our example, the left axis should be
shown at the left hand side. This is the position where the x axis has
its minimum value. To specify this, we would use the following code:

    left axis={ visualize axis={ x axis={ goto=min } }

As can be seen, we can pass another axis as an ⟨option⟩ to
visualize axis, where we pass the following key to the axis in turn:

The right axis would be visualized the same way, only at goto=max. The
$x$-axis actually needs to be visualized twice: Once at the bottom and
once at the top. Thus, we need to call visualize axis twice for this
axis:

    \tikzset{
      data visualization/our system/.append style={
        left axis= {visualize axis={x axis=   {goto=min}}},
        right axis={visualize axis={x axis=   {goto=max}}},
        x axis=    {visualize axis={left axis={goto=min}},
                    visualize axis={left axis={goto=max}}},
     }
    }
    \tikz \datavisualization [
        our system,
        x axis={attribute=time, length=4cm},
        left axis ={attribute=money},
        right axis={attribute=people},
        visualize as line/.list={people 1, people 2, money 1, money 2}]
      data group {people and money};

There is another key that is similar to goto, but has a slightly
different semantics:

By default, when an axis is visualized, it spans the set of all possible
values for the monitored attribute, that is, from min to max. However,
there are actually two keys that allow you to adjust this:

By default, low=min and high=max are set for an axis visualization.
Another sensible setting is low=padded min and high=padded max. The
following key provides a shorthand for this:

As an example, consider the scientific axes=clean. Here, each axis is
actually drawn three times: Once at the minimum, once at the maximum and
then once more at the padded minimum.

The axis line. When an axis is drawn, TikZ does not simply draw a
straight line from the low position to the high position. In reality,
the data visualization system uses the two commands \pgfpathdvmoveto and
\pgfpathdvlineto internally. These will replace the straight line by a
curve in certain situations. For instance, in a polar coordinate system,
if an axis should be drawn along an angle axis for a fixed radius, an
arc will be used instead of a straight line.

Styling the axis. As can be seen, we now get the axis we want (but
without the ticks, visualizing them will be explained later). The axis
is, however, simply a black line. We can style the axis in a manner
similar to styling ticks and grid lines, see Section ??. In detail, the
following styles get executed:

1.  axis layer

2.  every axis

3.  styling

Additionally, even before every axis is executed, low=min and high=max
are executed.

Recall that the styling key is set using the style key, see Section ??.

    \tikzset{
      data visualization/our system/.append style={
        every axis/.style={style=black!50}, % make this the default
        left axis= {visualize axis={x axis=   {goto=min}, style=red!75}},
        right axis={visualize axis={x axis=   {goto=max}, style=blue!75}},
        x axis=    {visualize axis={left axis={goto=min}},
                    visualize axis={left axis={goto=max}}},
     }
    }
    \tikz \datavisualization [
        our system,
        x axis={attribute=time, length=4cm},
        left axis ={attribute=money},
        right axis={attribute=people},
        visualize as line/.list={people 1, people 2, money 1, money 2}]
      data group {people and money};

Padding the Axis. When an axis is visualized, it is often a good idea to
make it "a little bit longer" or to "remove it a bit from the border",
because the visualization of an axis should not interfere with the
actual data. For this reason, a padding can be specified for axes:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/visualize:axis",
         meta = "⟨options⟩"
      },
      ["axis options/visualize grid"] = {
         details = [[
This key is passed to an axis. It causes grid lines to be drawn at the
positions specified by the grid key for this axis. The ⟨options⟩ govern
where and how the grid lines will be drawn.

The direction axis. At first sight, one might expect that the grid lines
for an axis should simply be drawn perpendicular to the axis between the
minimum and maximum value of the axis. However, things are somewhat more
difficult in reality:

1.  A grid line is supposed to indicate all positions where a certain
    attribute attains a fixed value. But, then, a grid line does not
    really need to be a grid line. Consider for instance a three
    dimensional axis system. A "grid line" for the $x$-coordinate 3
    would actually be a "grid plane".

2.  For a polar coordinate system and a fixed radius, this set of
    positions at a certain radius is not a straight line, but an arc.
    For more complicated coordinate systems such as the one arising from
    three-dimensional spherical projections, a grid line may well be a
    fairly involved curve.

The visualize grid command addresses these complications as follows:

1.  A grid line is always a line, not a plane or a volume. This means
    that in the example of a three dimensional axis system and the
    $x$-attribute being 3, one would have to choose whether the grid
    line should go "along" the $y$-axis or "along" the $z$-axis for this
    position. One can, however, call the visualize grid command twice,
    once for each direction, to cause grid lines to be shown for both
    directions.

2.  A grid line is created by moving to a start position and then doing
    a lineto to the target position. However, the "moveto" and "lineto"
    are done by calling special commands of the data visualization
    system. These special commands allow coordinate system to "notice"
    that the line is along an axis and will allow them to replace the
    straight line by an appropriate curve. The polar axes systems employ
    this strategy, for instance.

By the above discussion, in order to create a grid line for attribute
$a$ having value $v$, we need to specify an axis "along" which the line
should be drawn. When there are only two axes, this is usually "the
other axis". This "other axis" is specified using the following key:

The low and high keys are the same as the ones used in the
visualize axis key.

    \tikz \datavisualization [
        xyz Cartesian cabinet,
        all axes={visualize axis={low=0, style=->}},
        x axis={visualize grid={direction axis=y axis}, grid=many},
        visualize as scatter]
      data {
        x, y, z
        0, 0, 1
        0, 1, 0
        2, 2, 2
      };

    \tikz \datavisualization [
        xyz Cartesian cabinet,
        all axes={visualize axis={low=0, style=->}, grid=many},
        x axis={visualize grid={direction axis=z axis}},
        z axis={visualize grid={direction axis=x axis},
                visualize grid={direction axis=y axis},},
        visualize as scatter]
      data {
        x, y, z
        0, 0, 1
        0, 1, 0
        2, 2, 2
      };

Styling the grid lines. When a grid line is draw, styles are applied as
described in Section ??.

The major, minor, and subminor grid lines. The grid option allows you to
specify for each kind of grid line (major, minor, or subminor) a set of
different values for which these grid lines should be drawn.
Correspondingly, it is also possible to configure for each kind of grid
line how it should be drawn. For this, the major, minor, subminor, and
also the common keys can be used inside the ⟨options⟩ of visualize grid.
While as option to grid these keys are used to specify at values, as
options of visualize grid they are used to configure the different kinds
of grid lines.

Most of the time, no special configuration is necessary since all
styling is best done by configuring keys like every major grid. You need
to use a key like major only if you wish to configure for instance the
low or high values of a major grid line differently from those of minor
grid lines -- are rather unlikely setting -- or when the styling should
deviate from the usual settings.

    \tikz \datavisualization [
        xy Cartesian,
        all axes={visualize axis={low=0, style=->},
                  grid={some, minor steps between steps}},
        x axis=  {visualize grid={
                    direction axis=y axis,
                    minor={low=0.25, high=1.75, style=red!50}}},
        visualize as scatter]
      data {
        x, y
        0, 0
        3, 3
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/visualize:grid",
         meta = "⟨options⟩"
      },
      ["axis options/visualize label"] = {
         details = [[
The ⟨options⟩ should be used to configure a "good place" for the axis
label. Usually, you will use the goto or the goto pos key.

For the example of our system, we would like the label of the x axis to
be placed below at the middle of the axis, so we use goto pos=.5 to
determine this position. Concerning the other axes, we want it to be
placed at the minimum position of the left axis with a lot of padding.

    \tikzdatavisualizationset{
      our system/.append style={
        x axis={visualize label={
            x axis={goto pos=.5},
            left axis={padding=1.5em, goto=padded min}}}
      }
    }
    \tikz \datavisualization [
        our system,
        x axis={attribute=time, ticks=some, label},
        left axis ={attribute=money},
        right axis={attribute=people},
        visualize as line/.list={
          people 1, people 2, money 1, money 2}]
      data group {people and money};

In the above example, the padding of 1.5em was rather arbitrary and
"suboptimal". It would be outright wrong if the labels on the x axis
were larger or if they were missing. It would be better if the vertical
position of the x axis label were always "below" all other options. For
such cases a slightly strange approach is useful: You position the node
using node style={at=...} where at is now the normal TikZ option that is
used to specify the position of a node. Inside the ..., you specify that
the horizontal position should be the bottom of up-to-now-constructed
data visualization and the vertical position should be at the "origin",
which is, however, the position computed by the goto keys for the axes:

    \tikzdatavisualizationset{
      our system/.append style={
        x axis={visualize label={
          x axis={goto pos=.5},
          node style={
            at={(0,0 |- data visualization bounding box.south)},
            below
    } } } } }
    \tikz \datavisualization [
        our system,
        x axis={attribute=time, ticks=some, label=Year},
        left axis ={attribute=money},
        right axis={attribute=people},
        visualize as line/.list={
          people 1, people 2, money 1, money 2}]
      data group {people and money};

Two additional keys are useful for positioning axis labels:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/visualize:label",
         meta = "⟨options⟩"
      },
      ["axis options/visualize ticks"] = {
         details = [[
Visualizing a tick involves (possibly) drawing a tick mark and adding
(possibly) the tick node. The process is similar to visualize grid:
Users use the ticks key to configure how many ticks they would like for
an axis and at which positions. The axis system uses the visualize ticks
key to specify where these ticks should actually be shown.

Unlike grid lines, which are typically only visualized once for each
combination of an axis and a direction axis, tick marks might be
visualized at different places for the same axis. Consider for instance
the scientific axes:

    \tikz \datavisualization [scientific axes, all axes={length=3cm},
                              x axis={ticks={stack}},
                              visualize as smooth line]
      data [format=function] {
        var x : interval [0:2];
        func y = \value  x*\value x;
      };

Have a look at the ticks on the $y$-axis: There are ticks at values 0,
1, 2, 3, and 4. These are visualized both at the left side (where the
tick nodes are also shown) and additionally also at the right side, but
only as small marks. Similarly, the ticks on the $x$-axis appear at the
bottom, but also (in much simpler versions) at the top. Both for the
$x$-axis and for the $y$-axis the visualize ticks key was called twice.

The tick marks. Drawing a tick mark is quite similar to visualizing a
grid line; indeed a tick mark can be thought of as a "mini grid line":
Just like a grid line it "points a long an axis". However, a tick will
always be a short straight line -- even when the coordinate system is
actually twisted (experimentation has shown that ticks that follow the
curvature of the coordinate system like grid lines are hard to
recognize). For this reason, the low and high keys have a different
meaning from the one used with the visualize grid key. In detail to
configure the size and position of a tick mark for the value $v$ of
attribute $a$, proceed as follows:

-   The visualize ticks key will have setup attribute $a$ to be equal to
    $v$.

-   You should now use the goto or goto pos key together with all other
    axes to configure at which position with respect to these other
    options the tick mark should be shown. For instance, suppose we want
    tick marks in our system for the $x$-axis at the bottom and at the
    top. This corresponds to once setting the left axis to its minimal
    value and once to its maximal value:

        \tikzset{
          data visualization/our system/.append style={
            x axis={visualize ticks={direction axis=left axis, left axis={goto=min}},
                    visualize ticks={direction axis=left axis, left axis={goto=max}},
            }
          }
        }
        \tikz \datavisualization [
            our system,
            x axis={attribute=time, length=3cm, ticks=many},
            left axis ={attribute=money},
            right axis={attribute=people},
            visualize as line/.list={people 1, people 2, money 1, money 2}]
          data group {people and money};

-   In the above example, we may wish to shorten the ticks a bit at the
    bottom and at the top. For this, we use the low and high key:

    What we want to happen is that in the upper visualization of the
    ticks the low value is 0pt, while in the lower one the high value is
    0pt:

        \tikzset{
          data visualization/our system/.append style={
            x axis={
              visualize ticks={direction axis=left axis,high=0pt,left axis={goto=min}},
              visualize ticks={direction axis=left axis,low=0pt,left axis={goto=max}},
            }
          }
        }
        \tikz \datavisualization [
            our system,
            x axis={attribute=time, length=3cm, ticks=many},
            left axis ={attribute=money},
            right axis={attribute=people},
            visualize as line/.list={people 1, people 2, money 1, money 2}]
          data group {people and money};

In order to style the tick mark, use the styling mechanism that is
detailed in Section ??.

The tick label node. At certain tick positions, we may wish to add a
node indicating the value of the attribute at the given position. The
visualize ticks command has no influence over which text should be shown
at a node -- the text is specified and typeset as explained in
Section ??.

Each time visualize ticks, for each tick position up to two tick label
nodes will be created: One at the low position and one at the high
position. The following keys are used to configure which of these cases
happen:

When a tick label node is to be placed at the low or the high position,
the next step is to determine the exact position and the correct anchor
of the node. This is done as follows:

-   In order to compute an appropriate anchor, the tick mark is
    considered: This is a short line pointing in a certain direction.
    For a tick label node at the low position, the anchor attribute is
    setup in such a way that the node label will be below the low
    position when the tick mark direction points up, it will be to the
    right when the direction points left, above when it points down, and
    so on also for diagonal directions. Similarly, for the high
    position, when the direction points up, the node will be placed
    above the tick mark and so on.

    This computation is done automatically.

-   The tick label node is styled. The styles that are applied are
    described in Section ??.

-   A tick label node for the low position is usually anchored at this
    low position, but an additional padding will be added as described
    in Section ??.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/axis:options/visualize:ticks",
         meta = "⟨options⟩"
      },
      ["before creation"] = {
         details = [[
This code is executed right before the object is finally created. It can
be used to compute values that are then passed to the constructor.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/before:creation",
         meta = "⟨code⟩"
      },
      ["before survey"] = {
         details = [[
The ⟨code⟩ is passed to the before survey method of the data
visualization object and then executed at the appropriate time (see
Section ?? for details).

The following commands work likewise:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/before:survey",
         meta = "⟨code⟩"
      },
      ["before visualization"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/before:visualization",
         meta = "⟨code⟩"
      },
      class = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/class",
         meta = "⟨class name⟩"
      },
      common = {
         details = [[
This key allows you to specify ⟨options⟩ that apply to major, minor and
subminor alike. It does not make sense to use common to specify
positions (since you typically do not want both a major and a minor tick
at the same position), but it can be useful to configure, say, the size
of all kinds of ticks:

    \tikz \datavisualization
      [ school book axes, visualize as smooth line,
        x axis={ticks={minor steps between steps, common={low=0}}} ]
      data [format=function] {
        var x : interval [-1.25:2];
        func y = \value x * \value x / 2;
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/common",
         meta = "⟨options⟩"
      },
      ["compute step"] = {
         details = [[
The ⟨code⟩ should compute a suitable value for the stepping to be used
by the ⟨macro⟩ in the tick placement strategy.

For instance, the step key sets compute step to
\def\tikz@lib@dv@step{# 1}. Thus, when you say step=5, then the desired
stepping of 5 is communicated to the ⟨macro⟩ via the macro
\tikz@lib@dv@step.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/compute:step",
         meta = "⟨code⟩"
      },
      ["data point"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/data:point",
         meta = "⟨options⟩"
      },
      ["decimal about strategy"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/decimal:about:strategy"
      },
      ["direction axis"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/direction:axis",
         meta = "⟨axis name⟩"
      },
      ["euro about strategy"] = {
         details = [[
Permissible values for $m'$ are: $1$, $2$, and $5$. These are the same
values as for the Euro coins, hence the name.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/euro:about:strategy"
      },
      ["every axis"] = {
         details = [[
Put styling of the axis here. It is usually a good idea to set this
style to style={black!50}.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:axis"
      },
      ["every data set label"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:data:set:label"
      },
      ["every grid"] = {
         details = [[
This style provides overall configuration options for grid lines. By
default, it is set to the following:

    low=min, high=max

This causes grid lines to span all possible values when they are
visualized, which is usually the desired behavior (the low and high keys
are explained in Section ??. You can append the style key to this style
to configure the overall appearance of grid lines. It should be noted
that settings to style inside every grid will take precedence over ones
in every major grid and every minor grid. In the following example we
cause all grid lines to be dashed (which is not a good idea in general
since it creates a distracting background pattern).

    \tikz \datavisualization
      [scientific axes,
       all axes={length=3cm, grid},
       every grid/.append style={style=densely dashed},
       visualize as line]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:grid"
      },
      ["every label in data"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:label:in:data"
      },
      ["every label in legend"] = {
         details = [[
This key is executed with every label in a legend. However, the options
stored in this style are executed with the path prefix
/tikz/data visualization/legend entry options. Thus, this key can use
keys like node style to configure the styling of all text nodes:

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      every label in legend/.style={node style=
        {fill=red!30}},
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend=north east outside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$,
          node style={circle, draw=red}}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:label:in:legend"
      },
      ["every major grid"] = {
         details = [[
This style configures the appearance of major grid lines. It does so by
calling the style key to setup appropriate TikZ options for visualizing
major grid lines. The default definition of this style is:

    style = {help lines, thin, black!25}

In the following example, we use thin major blue grid lines:

    \tikz \datavisualization
      [scientific axes,
       all axes={
         length=3cm,
         grid,
         grid={minor steps between steps}
       },
       every major grid/.style = {style={blue, thin}},
       visualize as line]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };

As can be seen, this is not exactly visually pleasing. The default
settings for the grid lines should work in most situations; you may wish
to increase the blackness level, however, when you experience trouble
during printing or projecting graphics.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:major:grid"
      },
      ["every major ticks"] = {
         details = [[
The default is

      style={line cap=round}, tick length=2pt
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:major:ticks"
      },
      ["every minor grid"] = {
         details = [[
Works like every major grid. The default is

    style = {help lines, black!25}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:minor:grid"
      },
      ["every minor ticks"] = {
         details = [[
The default is

      style={help lines,thin, line cap=round}, tick length=1.4pt
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:minor:ticks"
      },
      ["every scientific axes"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:scientific:axes"
      },
      ["every subminor grid"] = {
         details = [[
Works like every major grid. The default is

    style = {help lines, black!10}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:subminor:grid"
      },
      ["every subminor ticks"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:subminor:ticks"
      },
      ["every ticks"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:ticks"
      },
      ["every visualizer"] = {
         details = [[
This style is used with every visualizer. Note that it should contain
normal TikZ keys.

    \tikz \datavisualization
     [scientific axes=clean,
      every visualizer/.style={dashed},
      visualize as smooth line]
    data [format=function] {
      var x : interval[0:3*pi];
      func y = sin(\value x r);
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:visualizer"
      },
      ["every ⟨axis system name⟩"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/every:⟨axis:system:name⟩"
      },
      few = {
         details = [[
This is an abbreviation for about=3.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/few"
      },
      ["grid layer"] = {
         details = [[
[section-dv-grid-layer] This key is used to specified the layer on which
grid lines should be drawn (layers are explained in Section ??). By
default, all grid lines are placed on the background layer and thus
behind the data visualization. This is a sensible strategy since it
avoids obscuring the more important data with the far less important
grid lines. However, you can change this style to "get the grid lines to
the front":

    \tikz \datavisualization
      [scientific axes,
       all axes={
         length=3cm,
         grid,
         grid={minor steps between steps}
       },
       grid layer/.style=, % none, so on top of data (bad idea)
       visualize as line]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };

When this style is executed, the keys stored in the style will be
executed with the prefix /tikz. Normally, you should only set this style
to be empty or to on background layer.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/grid:layer"
      },
      ["half about strategy"] = {
         details = [[
Permissible values for $m'$: $1$ and $5$. Use this strategy if only
powers of $10$ or halves thereof seem logical.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/half:about:strategy"
      },
      high = {
         details = [[
Like low, only for where the axis ends.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/high",
         meta = "⟨value⟩"
      },
      ["int about strategy"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/int:about:strategy"
      },
      legend = {
         details = [[
This is a shorthand for new legend=main legend, main legend=⟨options⟩.
In other words, this key creates a new main legend and immediately
passes the configuration ⟨options⟩ to this legend.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes, x axis={label=$x$},
      visualize as smooth line/.list={log, lin, squared, exp},
      legend=below,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=vary dashing]
    data group {function classes};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend",
         meta = "⟨options⟩"
      },
      ["legend entry options/circular label in legend line"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/circular:label:in:legend:line"
      },
      ["legend entry options/default label in legend closed path"] = {
         details = [[
This style is executed by smooth cycle and straight cycle. There are
(currently) no other predefined sets of coordinates that can be used
instead of the default value circular label in legend line.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/default:label:in:legend:closed:path"
      },
      ["legend entry options/default label in legend mark"] = {
         details = [[
This style is executed by no lines and, implicitly, by scatter plots.
The default is to use label in legend line one mark. Another possible
value is label in legend line three marks.

    \tikz \datavisualization [
      visualize as scatter/.list={a,b,c},
      style sheet=cross marks,
      legend entry options/default label in legend mark/.style=
        label in legend three marks,
      a={label in legend={text=example a}},
      b={label in legend={text=example b}},
      c={label in legend={text=example c}}];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/default:label:in:legend:mark"
      },
      ["legend entry options/default label in legend path"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/default:label:in:legend:path"
      },
      ["legend entry options/gap circular label in legend line"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/gap:circular:label:in:legend:line"
      },
      ["legend entry options/label in legend line coordinates"] = {
         details = [[
This key takes a ⟨list of coordinates⟩, which are TikZ-coordinates
separated by commas like (0,0),(1,1). The effect of setting the key is
the following: The label in legend visualizer used by, for instance,
visualize as line will draw a path going through these points. When the
line is drawn, the exact same style will be used as was used for the
data set. For instance, if the smooth line key was used and also the
style=red key, the line through the ⟨list of coordinates⟩ will also be
red and smooth. When the straight cycle key was used, the coordinates
will also be connected by a cycle, and so on.

When the line connecting the ⟨list of coordinates⟩ is drawn, the
coordinate system will have been shifted and transformed in such a way
that (0,0) lies to the left of the text and at half the height of the
character "x". This means that the right-most-point in the list should
usually be (0,0) and all other $x$-coordinates should usually be
negative. When the text left options is used, the coordinate system will
have been flipped, so the ⟨list of coordinates⟩ is independent of
whether the text is to the right or to the left of the line.

Let us now have a look at a first, simple example. We create a legend
entry that is just a straight line, so it should start somewhere to the
left of the origin at height $0$ and go to the origin:

    \tikz \datavisualization [
      school book axes, visualize as line/.list={a,b},
      style sheet=vary dashing,
      a={label in legend={text=a,
          label in legend line coordinates={(-1em,0), (0,0)}}},
      b={label in legend={text=b,
          label in legend line coordinates={(-2em,0), (0,0)}}}]
    data point [x=-1, y=-1, set=a]   data point [x=1, y=0, set=a]
    data point [x=-1, y=1,  set=b]   data point [x=1, y=0.5, set=b];

Now let us make this a bit more fancy and useful by using shifted lines:

    \tikz \datavisualization [
      school book axes, visualize as line/.list={a,b},
      legend={up then right}, style sheet=vary dashing,
      a={label in legend={text=a,
          label in legend line coordinates={(-2em,-.25ex), (0,0)}}},
      b={label in legend={text=b,
          label in legend line coordinates={(-2em,.25ex), (0,0)}}}]
    data point [x=-1, y=-1, set=a]   data point [x=1, y=0, set=a]
    data point [x=-1, y=1,  set=b]   data point [x=1, y=0.5, set=b];

In the final example, we use a little "hat" to represent lines:

    \tikz \datavisualization [
      school book axes, visualize as line/.list={a,b},
      legend={up then right}, style sheet=vary dashing,
      a={label in legend={text=a,
          label in legend line coordinates={
            (-2em,-.2ex), (-1em,.2ex), (0,-.2ex)}}},
      b={label in legend={text=b,
          label in legend line coordinates={
            (-2em,-.2ex), (-1em,.2ex), (0,-.2ex)}}}]
    data point [x=-1, y=-1, set=a]   data point [x=1, y=0, set=a]
    data point [x=-1, y=1,  set=b]   data point [x=1, y=0.5, set=b];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/label:in:legend:line:coordinates",
         meta = " {list of coordinates}"
      },
      ["legend entry options/label in legend mark coordinates"] = {
         details = [[
This key is similar to label in legend line coordinates, but now the
⟨list of coordinates⟩ is used as the positions where plot marks are
shown. Naturally, plot marks are only shown there if they are also shown
by the visualizer in the actual data -- just like the line through the
coordinates of the previous key is only shown when there is a line.

The ⟨list of coordinates⟩ may be the same as the one used for lines, but
usually it is not. In general, it is better to have marks for instance
not at the ends of the line.

    \tikz \datavisualization [
      school book axes, visualize as line/.list={a,b},
      legend={up then right},
      style sheet=vary dashing,
      style sheet=cross marks,
      a={label in legend={text=a,
          label in legend line coordinates={
            (-2em,-.2ex), (-1em,.2ex), (0,-.2ex)},
          label in legend mark coordinates={
            (-1em,.2ex)}}},
      b={label in legend={text=b,
          label in legend line coordinates={
            (-2em,-.2ex), (-1em,.2ex), (0,-.2ex)},
          label in legend mark coordinates={
            (-2em,-.2ex), (0,-.2ex)}}}]
    data point [x=-1, y=-1, set=a]   data point [x=1, y=0, set=a]
    data point [x=-1, y=1,  set=b]   data point [x=1, y=0.5, set=b];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/label:in:legend:mark:coordinates",
         meta = " {list of coordinates}"
      },
      ["legend entry options/label in legend one mark"] = {
         details = [[
To be used with scatter plots, since no line is drawn. Just displays a
single mark (this is the default with a scatter plot or when the no line
is selected.

    \tikz \datavisualization [visualize as scatter/.list={a,b,c},
       style sheet=cross marks,
      a={label in legend={text=example a}},
      b={label in legend={text=example b}},
      c={label in legend={text=example c}}];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/label:in:legend:one:mark"
      },
      ["legend entry options/label in legend three marks"] = {
         details = [[
An alternative to the previous style, where several marks are shown.

    \tikz \datavisualization [visualize as scatter/.list={a,b,c},
      style sheet=cross marks,
      a={label in legend={text=example a, label in legend three marks}},
      b={label in legend={text=example b, label in legend three marks}},
      c={label in legend={text=example c, label in legend three marks}}];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/label:in:legend:three:marks"
      },
      ["legend entry options/legend"] = {
         details = [[
Set this key to the name of a legend that has previously been created
using new legend. The label will then be shown in this legend.

In most cases, there is only one legend (namely main legend) and there
is no need to set this key since it defaults to the main legend.

Also note that the legend ⟨name⟩ is automatically created if it nodes
not yet exist.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/legend",
         meta = "⟨name⟩"
      },
      ["legend entry options/node style"] = {
         details = [[
This key adds ⟨options⟩ to the styling of the text nodes of the label.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend=north east outside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$,
          node style={circle, draw=red}}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/node:style",
         meta = "⟨options⟩"
      },
      ["legend entry options/setup"] = {
         details = [[
Some code to be executed at this point. Mostly, it is used to setup
attributes for style sheets.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/setup"
      },
      ["legend entry options/straight label in legend line"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/straight:label:in:legend:line"
      },
      ["legend entry options/text"] = {
         details = [[
Use this key to setup the ⟨text⟩ that is shown as the label of the data
set.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes, x axis={label=$x$},
      visualize as smooth line/.list=
      {log, lin, squared, exp},
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={pin in data    ={text=$x^2$, pos=0.1}},
      exp=    {label in data  ={text=$e^x$}},
      style sheet=vary dashing]
    data group {function classes};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/text",
         meta = "⟨text⟩"
      },
      ["legend entry options/text colored"] = {
         details = [[
Causes the node style to set the text color to visualizer color. The
effect of this is that the label's text will have the same color as the
data set to which it is attached.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend={label style=text colored},
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/text:colored"
      },
      ["legend entry options/text left"] = {
         details = [[
Placed the text node to the left of the data set style visualization.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend={label style=text left},
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/text:left"
      },
      ["legend entry options/text only"] = {
         details = [[
Shows only the text nodes and no data set style visualization at all.
This options only makes sense in conjunction with the text colored
options, which is why this options is also selected implicitly.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend={south east inside, rows=2,
              label style=text only},
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/text:only"
      },
      ["legend entry options/text right"] = {
         details = [[
Placed the text node to the right of the data set style visualization.
This is the default for most, but not all, legends.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/text:right"
      },
      ["legend entry options/visualizer in legend"] = {
         details = [[
Set this key to some code that paints something in the cell picture.
Typically, this will be a visual representation of the data set styling,
but it could also be something different.

    \tikz \datavisualization [
      school book axes, visualize as line/.list={a,b},
      style sheet=vary dashing,
      a={label in legend={text=a}},
      new legend entry={
        text=spacer,
        visualizer in legend={\draw[solid] (0,0) circle[radius=2pt];}
      },
      b={label in legend={text=b}}]
    data point [x=-1, y=-1, set=a]   data point [x=1, y=0, set=a]
    data point [x=-1, y=1,  set=b]   data point [x=1, y=0.5, set=b];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/visualizer:in:legend"
      },
      ["legend entry options/visualizer in legend style"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/visualizer:in:legend:style",
         meta = " {options}"
      },
      ["legend entry options/zig zag label in legend line"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:entry:options/zig:zag:label:in:legend:line"
      },
      ["legend options/above"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/above"
      },
      ["legend options/above left of"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/above:left:of",
         meta = "⟨data point⟩"
      },
      ["legend options/above of"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/above:of",
         meta = "⟨data point⟩"
      },
      ["legend options/above right of"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/above:right:of",
         meta = "⟨data point⟩"
      },
      ["legend options/anchor"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/anchor",
         meta = "⟨anchor⟩"
      },
      ["legend options/at"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/at",
         meta = "⟨coordinate⟩"
      },
      ["legend options/at values"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/at:values",
         meta = "⟨data point⟩"
      },
      ["legend options/below"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/below"
      },
      ["legend options/below left of"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/below:left:of",
         meta = "⟨data point⟩"
      },
      ["legend options/below of"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/below:of",
         meta = "⟨data point⟩"
      },
      ["legend options/below right of"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/below:right:of",
         meta = "⟨data point⟩"
      },
      ["legend options/columns"] = {
         details = [[
Shorthand for ideal number of columns=⟨number⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/columns",
         meta = "⟨number⟩"
      },
      ["legend options/down then left"] = {
         details = [[
     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={down then left, columns=3}]
    data group {sin functions};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/down:then:left"
      },
      ["legend options/down then right"] = {
         details = [[
Causes the legend entries to fill the legend matrix first downward and,
once a column is full, the next column is begun to the right of the
previous one. This is the default.

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={down then right, columns=3}]
    data group {sin functions};

In the example, the legend example is the following style:

    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/down:then:right"
      },
      ["legend options/east inside"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/east:inside"
      },
      ["legend options/east outside"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/east:outside"
      },
      ["legend options/every legend inside"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/every:legend:inside"
      },
      ["legend options/every new legend"] = {
         details = [[
This key defaults to east outside, label style=text right. This means
that by default a legend is placed to the right of the data
visualization and that in the individual legend entries the text is to
the right of the data set visualization.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/every:new:legend"
      },
      ["legend options/ideal number of columns"] = {
         details = [[
Specifies, that the entries should be split into ⟨number⟩ different
columns, whenever possible. However, when there would be more than the
max rows value of rows per column, more columns than the ideal number
are created.

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={ideal number of columns=2}]
    data group {sin functions};

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={ideal number of columns=4}]
    data group {sin functions};

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={max rows=3,ideal number of columns=2}]
    data group {sin functions};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/ideal:number:of:columns",
         meta = "⟨number⟩"
      },
      ["legend options/ideal number of rows"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/ideal:number:of:rows",
         meta = "⟨number⟩"
      },
      ["legend options/label style"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/label:style",
         meta = "⟨options⟩"
      },
      ["legend options/left"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/left"
      },
      ["legend options/left of"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/left:of",
         meta = "⟨data point⟩"
      },
      ["legend options/left then down"] = {
         details = [[
     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={left then down, columns=3}]
    data group {sin functions};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/left:then:down"
      },
      ["legend options/left then up"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/left:then:up"
      },
      ["legend options/matrix node style"] = {
         details = [[
Adds the ⟨options⟩ to the list of options that will be executed when the
legend's node is created.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend={matrix node style={fill=black!25}},
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=vary dashing]
    data group {function classes};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/matrix:node:style",
         meta = "⟨options⟩"
      },
      ["legend options/max columns"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/max:columns",
         meta = "⟨number⟩"
      },
      ["legend options/max rows"] = {
         details = [[
As the legend matrix is being filled, whenever the number of rows in the
current column would exceed ⟨number⟩, a new column is started.

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={max rows=3}]
    data group {sin functions};

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={max rows=4}]
    data group {sin functions};

     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={max rows=5}]
    data group {sin functions};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/max:rows",
         meta = "⟨number⟩"
      },
      ["legend options/north east inside"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/north:east:inside"
      },
      ["legend options/north east outside"] = {
         details = [[
A variant, where the legend is to the right, but aligned with the
northern end of the data visualization:

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend=north east outside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/north:east:outside"
      },
      ["legend options/north inside"] = {
         details = [[
As above.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/north:inside"
      },
      ["legend options/north outside"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/north:outside"
      },
      ["legend options/north west inside"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/north:west:inside"
      },
      ["legend options/north west outside"] = {
         details = [[
     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend=north west outside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/north:west:outside"
      },
      ["legend options/opaque"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/opaque",
         meta = "⟨color⟩"
      },
      ["legend options/right"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/right"
      },
      ["legend options/right of"] = {
         details = [[
Works like at values, but the anchor is set to west:

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list={log, lin},
      legend={right of={x=-1, y=2}},
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      style sheet=strong colors]
    data group {function classes};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/right:of",
         meta = "⟨data point⟩"
      },
      ["legend options/right then down"] = {
         details = [[
     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={right then down, columns=3}]
    data group {sin functions};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/right:then:down"
      },
      ["legend options/right then up"] = {
         details = [[
     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={right then up, columns=3}]
    data group {sin functions};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/right:then:up"
      },
      ["legend options/rows"] = {
         details = [[
Shorthand for ideal number of rows=⟨number⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/rows",
         meta = "⟨number⟩"
      },
      ["legend options/south east inside"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/south:east:inside"
      },
      ["legend options/south east outside"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/south:east:outside"
      },
      ["legend options/south inside"] = {
         details = [[
Puts the legend in the upper right corner of the data. Note that the
text is now a little smaller since there tends to be much less space
inside the data visualization than next to it.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list={log, lin},
      legend=south inside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      style sheet=strong colors]
    data group {function classes};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/south:inside"
      },
      ["legend options/south outside"] = {
         details = [[
     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend=south outside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/south:outside"
      },
      ["legend options/south west inside"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/south:west:inside"
      },
      ["legend options/south west outside"] = {
         details = [[
     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes,
      visualize as smooth line/.list=
        {log, lin, squared, exp},
      legend=south west outside,
      log=    {label in legend={text=$\log x$}},
      lin=    {label in legend={text=$x/2$}},
      squared={label in legend={text=$x^2$}},
      exp=    {label in legend={text=$e^x$}},
      style sheet=strong colors]
    data group {function classes};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/south:west:outside"
      },
      ["legend options/transparent"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/transparent"
      },
      ["legend options/up then left"] = {
         details = [[
     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={up then left, columns=3}]
    data group {sin functions};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/up:then:left"
      },
      ["legend options/up then right"] = {
         details = [[
     {
        var set : {1,...,8};
        var x : interval [0:50];
        func y = sin(\value x * (\value{set}+10))/(\value{set}+5);
      }
    };%
    \tikzdatavisualizationset {
      legend example/.style={
        scientific axes, all axes={length=1cm, ticks=none},
        1={label in legend={text=1}},
        2={label in legend={text=2}},
        3={label in legend={text=3}},
        4={label in legend={text=4}},
        5={label in legend={text=5}},
        6={label in legend={text=6}},
        7={label in legend={text=7}},
        8={label in legend={text=8}}
      }
    }},
    ]
    \tikz \datavisualization [
      visualize as smooth line/.list={1,2,3,4,5,6,7,8},
      legend example, style sheet=vary hue,
      main legend={up then right, columns=3}]
    data group {sin functions};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/up:then:right"
      },
      ["legend options/west inside"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/west:inside"
      },
      ["legend options/west outside"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/legend:options/west:outside"
      },
      low = {
         details = [[
This is the attribute value where the axis visualization starts. The
same special values as for goto are permissible (like min or padded min,
but also 0 or 1).
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/low",
         meta = "⟨value⟩"
      },
      major = {
         details = [[
The key can be passed as an option to the ticks key and also to the grid
key, which in turn is passed as an option to an axis. The ⟨options⟩
passed to major specify at which positions major ticks/grid lines should
be shown (using the at option and also at option) and also any special
styling. The different possible options are described later in this
section.

    \tikz \datavisualization
      [ school book axes, visualize as smooth line,
        x axis={ticks={major={at={1, 1.5, 2}}}}]
      data [format=function] {
        var x : interval [-1.25:2];
        func y = \value x * \value x / 2;
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/major",
         meta = "⟨options⟩"
      },
      ["major also at"] = {
         details = [[
A shorthand for major={also at={⟨list⟩}}.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/major:also:at",
         meta = "⟨list⟩"
      },
      ["major at"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/major:at",
         meta = "⟨list⟩"
      },
      many = {
         details = [[
This is an abbreviation for about=10.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/many"
      },
      minor = {
         details = [[
Like major, only for minor ticks/grid lines.

    \tikz \datavisualization
      [ school book axes, visualize as smooth line,
        x axis={grid={minor={at={1, 1.5, 2}}}}]
      data [format=function] {
        var x : interval [-1.25:2];
        func y = \value x * \value x / 2;
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/minor",
         meta = "⟨options⟩"
      },
      ["minor also at"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/minor:also:at",
         meta = "⟨list⟩"
      },
      ["minor at"] = {
         details = [[
A shorthand for major={at={⟨list⟩}}.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/minor:at",
         meta = "⟨list⟩"
      },
      ["minor steps between steps"] = {
         details = [[
Specifies that between any two major steps (whose positions are
specified by the step key), there should be ⟨number⟩ many minor steps.
Note that the default of 9 is exactly the right number so that each
interval between two minor steps is exactly a tenth of the size of a
major step. See also Section ?? for further details.

    \begin{tikzpicture}
      \datavisualization [school book axes, visualize as smooth line,
        x axis={ticks={minor steps between steps=3}},
        y axis={ticks={minor steps between steps}},
      ]
        data [format=function] {
          var x : interval [-1.5:1.5];
          func y = \value x*\value x;
        };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/minor:steps:between:steps",
         meta = "⟨number⟩"
      },
      ["new Cartesian axis"] = {
         details = [[
This key creates a new "Cartesian" axis, named ⟨name⟩. For such an axis,
the (scaled) values of the axis's attribute are transformed into a
displacement on the page along a straight line. The following key is
used to configure in which "direction" the axis points:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/new:Cartesian:axis",
         meta = "⟨name⟩"
      },
      ["new axis base"] = {
         details = [[
This key defines a new axis for the current data visualization called
⟨name⟩. This has two effects:

1.  A so called scaling mapper is created that will monitor a certain
    attribute, rescale it, and map it to another attribute. (This will
    be explained in detail in a moment.)

2.  The ⟨axis name⟩ is made available as a key that can be used to
    configure the axis:

3.  The ⟨axis name⟩ becomes part of the current set of axes. This set
    can be accessed through the following key:

There are many ⟨options⟩ that can be passed to a newly created axis.
They are explained in the rest of this section.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/new:axis:base",
         meta = "⟨axis name⟩"
      },
      ["new axis system"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/new:axis:system",
         meta = "{axis system name}{axis setup}{default options} {application options}"
      },
      ["new legend"] = {
         details = [[
This key is used to create a new legend named ⟨legend name⟩. The legend
is empty by default and further options are needed to add entries to it.
When the key is called a second time for the same ⟨legend name⟩ nothing
happens.

When a legend is created, a new key is created that can subsequently be
used to configure the legend:

In the end, the legend is just a TikZ node, a matrix node, to be
precise. The following key is used to style this node:

The following style allows you to configure the default appearance of
every newly created legend:

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      scientific axes, x axis={label=$x$},
      visualize as smooth line/.list={log, lin, squared, exp},
      new legend={upper legend},
      new legend={lower legend},
      upper legend=above,
      lower legend=below,
      log=    {label in legend={text=$\log x$, legend=upper legend}},
      lin=    {label in legend={text=$x/2$, legend=upper legend}},
      squared={label in legend={text=$x^2$, legend=lower legend}},
      exp=    {label in legend={text=$e^x$, legend=lower legend}},
      style sheet=vary dashing]
    data group {function classes};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/new:legend",
         meta = "⟨legend name⟩"
      },
      ["new legend entry"] = {
         details = [[
This key will add a new entry to the legend that is identified by the
⟨options⟩. For this, the ⟨options⟩ are executed once with the path
prefix /tikz/data visualization/legend entry options and the resulting
setting of the legend key is used to pick which legend the new entry
should belong to. Then, the ⟨options⟩ are stored away for the time
being.

Later, when the legend is created, the ⟨options⟩ get executed once more.
This time, however, the legend key is no longer important. Instead, the
⟨options⟩ that setup keys like text or visualizer in legend now play a
role.

In detail, the following happens:

-   For the legend entry, a little cell picture is created in the matrix
    of the legend (see Section ?? for details on cell pictures).

-   Inside this picture, a node is created whose text is taken from the
    key

        /tikz/data visualization/legend entry options/text

-   Also inside the picture, the code stored in the following key gets
    executed:

The following styles are applied in the following order before the cell
picture is filled:

1.  /tikz/data visualization/every data set label with path
    /tikz/data visualization

2.  /tikz/data visualization/every label in legend with path
    /tikz/data visualization/legend entry options.

3.  The ⟨options⟩.

4.  The code in the following key:

5.  A styling signal is emitted.

6.  Only for the node: The current value of node style.

7.  Only for the visualizer in legend: The styling that has been
    accumulated by calls to the following key:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/new:legend:entry",
         meta = "⟨options⟩"
      },
      ["new object"] = {
         details = [[
This key serves two purposes:

1.  This method makes it easy to create a new object as part of the
    rendering pipeline, using ⟨options⟩ to specify arguments rather that
    directly calling \pgfoonew. Since you have the full power of the
    keys mechanism at your disposal, it is easy, for instance, to
    control whether or not parameters to the constructor are expanded or
    not.

2.  The object is not created immediately, but only just before the
    visualization starts. This allows you to specify that an object must
    be created, but the parameter values of for its constructor may
    depend on keys that are not yet set. A typical application is the
    creating of an axis object: When you say scientific axes, the
    new object command is used internally to create two objects
    representing these axes. However, keys like x={length=5cm} can only
    later be used to specify the parameters that need to be passed to
    the constructor of the objects.

The following keys may be used inside the ⟨options⟩:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/new:object",
         meta = "⟨options⟩"
      },
      ["new polar axes"] = {
         details = [[
This key actually creates two axes, whose names are give as parameters:
An angle axis and a radius axis. These two axes work in concert in the
following way: Suppose a data point has two attributes called angle and
radius (these attribute names can be changed by changing the attribute
of the ⟨angle axis name⟩ or the ⟨radius axis name⟩, respectively). These
two attributes are then scaled as usual, resulting in two "reasonable"
values $a$ (for the angle) and $r$ (for the radius). Then, the data
point gets visualized (in principle, details will follow) at a position
on the page that is at a distance of $r$ from the origin and at an angle
of $a$.

    \tikz \datavisualization
        [new polar axes={angle axis}{radius axis},
         radius axis={length=2cm},
         visualize as scatter]
      data [format=named] {
        angle={0,20,...,160}, radius={0,...,5}
      };

In detail, the ⟨angle axis⟩ keeps track of two vectors $v_0$ and
$v_{90}$, each of which will usually have unit length (length 1pt) and
which point in two different directions. Given a radius $r$ (measured in
TeX pts, so if the radius attribute 10pt, then $r$ would be $10$) and an
angle $a$, let $s$ be the sine of $a$ and let $c$ be the cosine of $a$,
where $a$ is a number is degrees (so $s$ would be $1$ for $a = 90$).
Then, the current page position is shifted by $c \cdot r$ times $v_0$
and, additionally, by $s \cdot r$ times $v_{90}$. This means that in the
"polar coordinate system" $v_0$ is the unit vector along the
"$0^\circ$-axis" and $v_{90}$ is the unit vector along
"$90^\circ$-axis". The values of $v_0$ and $v_{90}$ can be changed using
the following key on the ⟨angle axis⟩:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/new:polar:axes",
         meta = "{⟨angle axis name⟩}{⟨radius axis name⟩}"
      },
      ["new visualizer"] = {
         details = [[
This key configures a new visualizer named ⟨name⟩. This entails the
following actions:

-   The key /tikz/data visualization/⟨name⟩ is created. As described
    earlier, this key can be used to pass for instance style options to
    the visualizer.

-   The style key /tikz/data visualization/visualizers/⟨name⟩/styling is
    created and made empty. This is the key in which the style key will
    store the options passed to the visualizer.

-   The style key
    /tikz/data visualization/visualizers/⟨name⟩/label in legend options
    is set to ⟨legend entry options⟩. These options are used to
    configure how the visualizer should be rendered in a legend, see
    Section ?? for details.

-   The key /data point/set/⟨name⟩ is set to a number that is increased
    for each visualizer in the current data visualization. This number
    is important for style sheets, see Section ??.

-   The key /data point/⟨name⟩/execute at begin is set to code that
    creates a {scope} that executes the following styles as options:

    1.  The ⟨options⟩ passed to the new visualizer key.

    2.  The every visualizer style.

    3.  The styling from the currently active style sheets, see
        Section ??.

    4.  The styling stored in the styling key mentioned above.

-   The key /data point/⟨name⟩/execute at end is set to code that will
    finish all paths that may have been created by the visualizer and
    closes the scope.

All of the above mean the following in practice:

-   Inside a new visualize as ... key, you pass the name of the
    to-be-created to new visualizer as the first parameter and any
    special default styling setup of the visualizer as the second
    parameter.

-   The new visualize as ... key should also create a visualizer object
    using new object.

-   When this object finally is about to create the actual
    visualization, it should surround the code by invoking the code
    stored in the execute at begin and the execute at end keys of the
    visualizer.

Everything else is usually taken care of by the new visualizer key
automatically.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/new:visualizer",
         meta = "{name}{options}{legend entry options}"
      },
      ["no tick text"] = {
         details = [[
Shorthand for tick text at low=false, tick text at high=false.

    \tikz \datavisualization [scientific axes, all axes={length=3cm},
                              x axis={ticks={
                                  major also at={6.5 as [no tick text]}}},
                              visualize as smooth line]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/no:tick:text"
      },
      ["no tick text at"] = {
         details = [[
Shorthand for options at=⟨value⟩ as [no tick text].
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/no:tick:text:at",
         meta = "⟨value⟩"
      },
      ["node style"] = {
         details = [[
This key works like style, but it has an effect only on nodes that are
created during a data visualization. This includes tick labels and axis
labels:

    \tikz \datavisualization
      [scientific axes,
       all axes={ticks={node style=red}, length=3cm},
       visualize as line]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };

Note that in the example the ticks themselves (the little thicker lines)
are not red.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/node:style",
         meta = "⟨tikzoptions⟩"
      },
      ["node styling"] = {
         details = [[
Executing this key will cause all "accumulated" node stylings to be
executed.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/node:styling"
      },
      none = {
         details = [[
Switches off the automatic step computation. Unless you use step=
explicitly to set a stepping, no ticks will be (automatically) added.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/none"
      },
      ["options at"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/options:at",
         meta = "⟨value⟩ as [⟨options⟩]"
      },
      padded = {
         details = [[
Shorthand for low=padded min, high=padded max.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/padded"
      },
      phase = {
         details = [[
See Section ?? for details on how the phase of steps influences the tick
placement.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/phase",
         meta = "⟨value⟩"
      },
      ["quarter about strategy"] = {
         details = [[
Permissible values for $m'$ are: $1$, $2.5$, and $5$.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/quarter:about:strategy"
      },
      ["school book axes"] = {
         details = [[
This axis system is intended to "look like" the coordinate systems often
used in school books: The axes are drawn in such a way that they
intersect to origin. Furthermore, no automatic scaling is done to ensure
that the lengths of units are the same in all directions.

This axis system must be used with care -- it is nearly always necessary
to specify the desired unit length by hand using the option unit length.
If the magnitudes of the units on the two axes differ, different unit
lengths typically need to be specified for the different axes.

Finally, if the data is "far removed" from the origin, this axis system
will also "look bad".

    \begin{tikzpicture}
      \datavisualization [school book axes, visualize as smooth line]
        data [format=function] {
          var x : interval [-1.3:1.3];
          func y = \value x*\value x*\value x;
        };
    \end{tikzpicture}

The stepping of the ticks is one unit by default. Using keys like
ticks=some may help to give better steppings.

The ⟨options⟩ are executed with the key itself as path prefix. Thus, the
following subkeys are permissible options:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/school:book:axes",
         meta = "⟨options⟩"
      },
      ["school book axes/standard labels"] = {
         details = [[
This key makes the label of the $x$-axis appear at the right end of this
axis and it makes the label of the $y$-axis appear at the top of the
$y$-axis.

Currently, this is the only supported placement strategy for the school
book axis system.

    \begin{tikzpicture}
      \datavisualization [school book axes={standard labels},
                          visualize as smooth line,
                          clean ticks,
                          x axis={label=$x$},
                          y axis={label=$f(x)$}]
        data [format=function] {
          var x : interval [-1:1];
          func y = \value x*\value x + 1;
        };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/school:book:axes/standard:labels"
      },
      ["school book axes/unit"] = {
         details = [[
Sets the scaling so that 1 cm corresponds to ⟨value⟩ units. At the same
time, the stepping of the ticks will also be set to ⟨value⟩.

    \begin{tikzpicture}
      \datavisualization [school book axes={unit=10},
                          visualize as smooth line,
                          clean ticks,
                          x axis={label=$x$},
                          y axis={label=$f(x)$}]
        data [format=function] {
          var x : interval [-20:20];
          func y = \value x*\value x/10;
        };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/school:book:axes/unit",
         meta = "⟨value⟩"
      },
      ["scientific axes"] = {
         details = [[
This key installs a two-dimensional coordinate system based on the
attributes /data point/x and /data point/y.

    \begin{tikzpicture}
      \datavisualization [scientific axes,
                          visualize as smooth line]
        data [format=function] {
          var x : interval [0:100];
          func y = sqrt(\value x);
        };
    \end{tikzpicture}

This axis system is usually a good choice to depict "arbitrary two
dimensional data". Because the axes are automatically scaled, you do not
need to worry about how large or small the values will be. The name
scientific axes is intended to indicate that this axis system is often
used in scientific publications.

You can use the ⟨options⟩ to fine tune the axis system. The ⟨options⟩
will be executed with the following path prefix:

    /tikz/data visualization/scientific axes

All keys with this prefix can thus be passed as ⟨options⟩.

This axis system will always distort the relative magnitudes of the
units on the two axis. If you wish the units on both axes to be equal,
consider directly specifying the unit length "by hand":

    \begin{tikzpicture}
      \datavisualization [visualize as smooth line,
                          scientific axes,
                          all axes={unit length=1cm per 10 units, ticks={few}}]
        data [format=function] {
          var x : interval [0:100];
          func y = sqrt(\value x);
        };
    \end{tikzpicture}

The scientific axes have the following properties:

-   The x-values are surveyed and the $x$-axis is then scaled and
    shifted so that it has the length specified by the following key.

    The minimum value is at the left end of the axis and at the canvas
    origin. The maximum value is at the right end of the axis.

-   The y-values are surveyed and the $y$-axis is then scaled so that is
    has the length specified by the following key.

    The minimum value is at the bottom of the axis and at the canvas
    origin. The maximum value is at the top of the axis.

-   Lines (forming a frame) are depicted at the minimum and maximum
    values of the axes in 50% black.

The following keys are executed by default as options: outer ticks and
standard labels.

You can use the following style to overrule the defaults:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes",
         meta = "⟨options⟩"
      },
      ["scientific axes/clean"] = {
         details = [[
The axes and the ticks are completely removed from the actual data,
making this axis system especially useful for scatter plots, but also
for most other scientific plots.

    \tikz \datavisualization [
      scientific axes=clean,
      visualize as smooth line]
    data [format=function] {
      var x : interval [-12:12];
      func y = \value x*\value x*\value x;
    };

The distance of the axes from the actual plot is given by the padding of
the axes.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes/clean"
      },
      ["scientific axes/end labels"] = {
         details = [[
Places the labels at the end of the $x$- and the $y$-axis, similar to
the axis labels of a school book axis system.

    \tikz \datavisualization [
      scientific axes={clean, end labels},
      visualize as smooth line,
      x axis={label=degree $d$,
        ticks={tick unit={}^\circ}},
      y axis={label=$\tan d$}]
    data [format=function] {
      var x : interval [-80:80];
      func y = tan(\value x);
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes/end:labels"
      },
      ["scientific axes/height"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes/height",
         meta = "⟨dimension⟩"
      },
      ["scientific axes/inner ticks"] = {
         details = [[
This axis system works like scientific axes, only the ticks are on the
"inside" of the frame.

    \begin{tikzpicture}
      \datavisualization [scientific axes=inner ticks,
                          visualize as smooth line]
        data [format=function] {
          var x : interval [-12:12];
          func y = \value x*\value x*\value x;
        };
    \end{tikzpicture}

This axis system is also common in publications, but the ticks tend to
interfere with marks if they are near to the border as can be seen in
the following example:

    \begin{tikzpicture}
      \datavisualization [scientific axes={inner ticks, width=3.2cm},
                          style sheet=cross marks,
                          visualize as scatter/.list={a,b}]
        data [set=a] {
          x, y
          0, 0
          1, 1
          0.5, 0.5
          2, 1
        }
        data [set=b] {
          x, y
          0.05, 0
          1.5, 1
          0.5, 0.75
          2, 0.5
        };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes/inner:ticks"
      },
      ["scientific axes/outer ticks"] = {
         details = [[
This causes the ticks to be drawn " on the outside" of the frame so that
they interfere as little as possible with the data. It is the default.

    \begin{tikzpicture}
      \datavisualization [scientific axes=outer ticks,
                          visualize as smooth line]
        data [format=function] {
          var x : interval [-12:12];
          func y = \value x*\value x*\value x;
        };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes/outer:ticks"
      },
      ["scientific axes/standard labels"] = {
         details = [[
As the name suggests, this is the standard placement strategy. The label
of the $x$-axis is placed below the center of the $x$-axis, the label of
the $y$-axis is rotated by $90^\circ$ and placed left of the center of
the $y$-axis.

    \tikz \datavisualization
     [scientific axes={clean, standard labels},
      visualize as smooth line,
      x axis={label=degree $d$,
        ticks={tick unit={}^\circ}},
      y axis={label=$\sin d$}]
    data [format=function] {
      var x : interval [-10:10] samples 10;
      func y = sin(\value x);
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes/standard:labels"
      },
      ["scientific axes/upright labels"] = {
         details = [[
Works like scientific axes standard labels, only the label of the
$y$-axis is not rotated.

    \tikz \datavisualization [
      scientific axes={clean, upright labels},
      visualize as smooth line,
      x axis={label=degree $d$,
        ticks={tick unit={}^\circ}},
      y axis={label=$\cos d$, include value=1,
        ticks={style={
            /pgf/number format/precision=4,
            /pgf/number format/fixed zerofill}}}]
    data [format=function] {
      var x : interval [-10:10] samples 10;
      func y = cos(\value x);
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes/upright:labels"
      },
      ["scientific axes/width"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:axes/width",
         meta = "⟨dimension⟩"
      },
      ["scientific polar axes"] = {
         details = [[
This key installs a polar axis system that can be used in a "scientific"
publication. Two axes are created called the angle axis and the
radius axis. Unlike "normal" Cartesian axes, these axes do not point in
a specific direction. Rather, the radius axis is used to map the values
of one attribute to a distance from the origin while the angle axis is
used to map the values of another attribute to a rotation angle.

The ⟨options⟩ will be executed with the path prefix

    /tikz/data visualization/scientific polar axes

The permissible keys are documented in the later subsections of this
section.

Let us start with the configuration of the radius axis since it is
easier. Firstly, you should specify which attribute is linked to the
radius. The default is radius, but you will typically wish to change
this. As with any other axis, the attribute key is used to configure the
axis, see Section ?? for details. You can also apply all other
configurations to the radius axis like, say, unit length or length or
style. Note, however, that the logarithmic key will not work with the
radius axis for a scientific polar axes system since the attribute value
zero is always placed at the center -- and for a logarithmic plot the
value 0 cannot be mapped.

    \tikz \datavisualization [
      scientific polar axes,
      radius axis={
        attribute=distance,
        ticks={step=5000},
        padding=1.5em,
        length=3cm,
        grid
      },
      visualize as smooth line]
    data [format=function] {
      var  angle : interval [0:100];
      func distance = \value{angle}*\value{angle};
    };

For the angle axis, you can also specify an attribute using the
attribute key. However, for this axis the mapping of a value to an
actual angle is a complicated process involving many considerations of
how the polar axis system should be visualized. For this reason, there
are a large number of predefined such mappings documented in Section ??.
Finally, as for a scientific plot, you can configure where the ticks
should be shown using the keys inner ticks, outer ticks, and clean,
documented below.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:polar:axes",
         meta = "⟨options⟩"
      },
      ["scientific polar axes/clean"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:polar:axes/clean"
      },
      ["scientific polar axes/inner ticks"] = {
         details = [[
This key causes the ticks to be "turned to the inside". I do not
recommend using this key.

    \tikz \datavisualization [
      scientific polar axes={inner ticks, 0 to 180},
      visualize as smooth line]
    data [format=function] {
      var  angle : interval [0:100];
      func radius = \value{angle};
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:polar:axes/inner:ticks"
      },
      ["scientific polar axes/outer ticks"] = {
         details = [[
This key, which is the default, causes ticks to be drawn "outside" the
outer "ring" of the polar axes:

    \tikz \datavisualization [
      scientific polar axes={outer ticks, 0 to 180},
      visualize as smooth line]
    data [format=function] {
      var  angle : interval [0:100];
      func radius = \value{angle};
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/scientific:polar:axes/outer:ticks"
      },
      some = {
         details = [[
This is an abbreviation for about=5.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/some"
      },
      stack = {
         details = [[
Shorthand for tick text even padding=⟨dimension⟩.

    \tikz \datavisualization [scientific axes,
                              all axes={length=2.5cm},
                              x axis={ticks={stack=1.5em}},
                              visualize as smooth line]
      data [format=function] {
        var y : interval[-100:100];
        func x = \value y*\value y;
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/stack",
         meta = "⟨dimension⟩"
      },
      ["stack'"] = {
         details = [[
Shorthand for tick text odd padding=⟨dimension⟩. The difference to stack
is that the set of value that are "lowered" is exactly exchanged with
the set of value "lowered" by stack.

    \tikz \datavisualization [scientific axes,
                              all axes={length=2.5cm},
                              x axis={ticks=stack'},
                              visualize as smooth line]
      data [format=function] {
        var y : interval[-100:100];
        func x = \value y*\value y;
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/stack'",
         meta = "⟨dimension⟩"
      },
      ["standard about strategy"] = {
         details = [[
Permissible values for $m'$ are: $1$, $2$, $2.5$, and $5$. This strategy
is the default strategy.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/standard:about:strategy"
      },
      step = {
         details = [[
The value of this key is used to determine the spacing of the major
ticks. The key is used by the linear steps and exponential steps
strategies, see the explanations in Section ?? for details. Basically,
all ticks are placed at all multiples of ⟨value⟩ that lie in the
attribute range interval.

    \tikz \datavisualization [
        school book axes, visualize as smooth line,
        y axis={ticks={step=1.25}},
      ]
        data [format=function] {
          var x : interval [0:3];
          func y = \value x*\value x/2;
        };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/step",
         meta = "⟨value⟩"
      },
      store = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/store",
         meta = "⟨key name⟩"
      },
      style = {
         details = [[
This key takes options whose path prefix is /tikz, not
/tikz/data visualization. These options will be appended to a current
list of such options (thus, multiple calls of this key accumulate). The
resulting list of keys is not executed immediately, but it will be
executed whenever the data visualization engine calls the TikZ layer to
draw something (this placed will be indicated in the following).

    \tikz \datavisualization
      [scientific axes,
       all axes={ticks={style=blue}, length=3cm},
       y axis={grid, grid={minor steps between steps, major={style=red}}},
       visualize as line]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/style",
         meta = "⟨tikzoptions⟩"
      },
      ["style sheet"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/style:sheet",
         meta = "⟨style sheet⟩"
      },
      styling = {
         details = [[
Executing this key will cause all "accumulated" TikZ options from
previous calls to the key /tikz/data visualization/style to be executed.
Thus, you use style to set TikZ options, but you use styling to actually
apply these options. Usually, you do not call this option directly since
this application is only done deep inside the data visualization engine.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/styling"
      },
      subminor = {
         details = [[
Like major, only for subminor ticks/grid lines.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/subminor",
         meta = "⟨options⟩"
      },
      ["subminor also at"] = {
         details = [[
A shorthand for major={also at={⟨list⟩}}.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/subminor:also:at",
         meta = "⟨list⟩"
      },
      ["subminor at"] = {
         details = [[
A shorthand for major={at={⟨list⟩}}.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/subminor:at",
         meta = "⟨list⟩"
      },
      ["tick layer"] = {
         details = [[
Like grid layer, this key specifies on which layer the ticks should be
placed.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:layer"
      },
      ["tick length"] = {
         details = [[
Shorthand for low=-⟨dimension⟩, high=⟨dimension⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:length",
         meta = "⟨dimension⟩"
      },
      ["tick node layer"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:node:layer"
      },
      ["tick prefix"] = {
         details = [[
The ⟨text⟩ will be put in front of every typeset tick:

    \tikz \datavisualization
      [scientific axes, all axes={ticks=few, length=2.5cm},
       x axis={ticks={tick prefix=$\langle$, tick suffix=$]$}},
       visualize as line]
      data [format=function] {
        var x : interval [5:10];
        func y = \value x * \value x;
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:prefix",
         meta = "⟨text⟩"
      },
      ["tick suffix"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:suffix",
         meta = "⟨text⟩"
      },
      ["tick text at high"] = {
         details = [[
Like tick text at low.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:at:high",
         meta = "⟨true or false⟩"
      },
      ["tick text at low"] = {
         details = [[
Pass this option to visualize ticks when you want tick label nodes to be
placed at the low position of each tick mark.

    \tikzset{
      data visualization/our system/.append style={
        x axis={
          visualize ticks={direction axis=left axis, left axis={goto=min},
                           high=0pt, tick text at low, stack},
          visualize ticks={direction axis=left axis, left axis={goto=max},
                           low=0pt, tick text at high, stack}
        }
      }
    }
    \tikz \datavisualization [
        our system,
        x axis={attribute=time, length=3cm, ticks=some},
        left axis ={attribute=money},
        right axis={attribute=people},
        visualize as line/.list={people 1, people 2, money 1, money 2}]
      data group {people and money};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:at:low",
         meta = "⟨true or false⟩"
      },
      ["tick text even padding"] = {
         details = [[
A shorthand for setting tick text even low padding and
tick text even high padding at the same time.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:even:padding",
         meta = "⟨dimension⟩"
      },
      ["tick text high even padding"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:high:even:padding",
         meta = "⟨dimension⟩"
      },
      ["tick text high odd padding"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:high:odd:padding",
         meta = "⟨dimension⟩"
      },
      ["tick text low even padding"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:low:even:padding",
         meta = "⟨dimension⟩"
      },
      ["tick text low odd padding"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:low:odd:padding",
         meta = "⟨dimension⟩"
      },
      ["tick text odd padding"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:odd:padding",
         meta = "⟨dimension⟩"
      },
      ["tick text padding"] = {
         details = [[
Sets all text paddings to ⟨dimension⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:text:padding",
         meta = "⟨dimension⟩"
      },
      ["tick typesetter"] = {
         details = [[
The key gets called for each number that should be typeset. The argument
⟨value⟩ will be in scientific notation (like 1.0e1 for $10$). By
default, this key applies \pgfmathprintnumber to its argument. This
command is a powerful number printer whose configuration is documented
in Section ??.

You are invited to code underlying this key so that a different
typesetting mechanism is used. Here is a (not quite finished) example
that shows how, say, numbers could be printed in terms of multiples of
$\pi$:

    \def\mytypesetter#1{%
      \pgfmathparse{#1/pi}%
      \pgfmathprintnumber{\pgfmathresult}$\pi$%
    }
    \tikz \datavisualization
      [school book axes, all axes={unit length=1.25cm},
       x axis={ticks={step=(0.5*pi), tick typesetter/.code=\mytypesetter{##1}}},
       y axis={include value={-1,1}},
       visualize as smooth line]
      data [format=function] {
        var x : interval [0.5:7];
        func y = sin(\value x r);
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:typesetter",
         meta = "⟨value⟩"
      },
      ["tick unit"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/tick:unit",
         meta = "⟨roman math text⟩"
      },
      ["uv Cartesian"] = {
         details = [[
This axis system works like xy Cartesian, but it introduces two axes
called u axis and v axis rather than the x axis and the y axis. The idea
is that in addition to a "major" $xy$-coordinate system this is also a
"smaller" or "minor" coordinate system in use for depicting, say, small
vectors with respect to this second coordinate system.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/uv:Cartesian"
      },
      ["uv axes"] = {
         details = [[
Applies the ⟨options⟩ to both the u axis and the y axis.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/uv:axes",
         meta = "⟨options⟩"
      },
      ["uvw Cartesian cabinet"] = {
         details = [[
Like xyz Cartesian cabinet, but for the $uvw$-system.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/uvw:Cartesian:cabinet"
      },
      ["uvw axes"] = {
         details = [[
Like xyz axes.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/uvw:axes",
         meta = "⟨options⟩"
      },
      ["visualizer label options/auto"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/auto"
      },
      ["visualizer label options/index"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/index",
         meta = "⟨number⟩"
      },
      ["visualizer label options/node style"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/node:style",
         meta = "⟨options⟩"
      },
      ["visualizer label options/pin angle"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/pin:angle",
         meta = "⟨angle⟩"
      },
      ["visualizer label options/pin length"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/pin:length",
         meta = "⟨dimension⟩"
      },
      ["visualizer label options/pos"] = {
         details = [[
This key chooses the first data point belonging to the data set whose
index is at least ⟨fraction⟩ times the number of all data points in the
data set.

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      school book axes,
      x axis={label=$x$},
      visualize as smooth line=exp,
      exp=    {label in data={text=$.2$, pos=0.2},
               label in data={text=$.5$, pos=0.5},
               label in data={text=$.95$, pos=0.95},
               style={mark=x}},
      style sheet=vary hue]
    data group {function classes};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/pos",
         meta = "⟨fraction⟩"
      },
      ["visualizer label options/text"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/text",
         meta = "⟨text⟩"
      },
      ["visualizer label options/text colored"] = {
         details = [[
Causes the node style to set the text color to visualizer color. The
effect of this is that the label's text will have the same color as the
data set to which it is attached.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/text:colored"
      },
      ["visualizer label options/text'"] = {
         details = [[
Like text, only the text will be to the "right" of the data.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/text'",
         meta = "⟨text⟩"
      },
      ["visualizer label options/when"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:label:options/when",
         meta = "⟨attribute⟩ is⟨number⟩"
      },
      ["visualizer options/gap cycle"] = {
         details = [[
Like gapped line, only with a cycle:

    \tikz [scale=.55] \datavisualization
     [scientific axes=clean, all axes={ticks=few},
      visualize as smooth line=my data,  my data={gap cycle}]
    data [format=function] {
      var t : interval [0:4] samples 5;
      func x = cos(\value t r);
      func y = sin(\value t r);
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/gap:cycle"
      },
      ["visualizer options/gap line"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/gap:line"
      },
      ["visualizer options/ignore style sheets"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/ignore:style:sheets"
      },
      ["visualizer options/label in data"] = {
         details = [[
This key is passed to a visualizer that has previously been created
using keys starting visualize as .... It will create a label inside the
data visualization "next" to the visualizer (the details are explained
in a moment). You can use this key multiple times with a visualizer to
create multiple labels at different points with different texts.

The ⟨options⟩ determine which text is shown and where it is shown. They
are executed with the following path prefix:

    /tikz/data visualization/visualizer label options

In order to configure which text is shown and where, use the following
keys inside the ⟨options⟩:

The following keys are used to configure where the label will be shown.
They use different strategies to specify one data point where the label
will be anchored. The coordinate of this data point will be stored in
(label visualizer coordinate). Independently of the strategy, once the
data point has been chosen, the coordinate of the next data point is
stored in (label visualizer coordinate’). Then, a (conceptual) line is
created from the first coordinate to the second and a node is placed at
the beginning of this line to its "left" or, for the text’ option, on
its "right". More precisely, an automatic anchor is computed for a node
placed implicitly on this line using the auto option or, for the text’
option, using auto,swap.

The node placed at the position computed in this way will have the
⟨text⟩ set by the text or text’ option and its styling is determined by
the current node style.

Let us now have a look at the different ways of determining the data
point at which the label in anchored:

The following keys allow you to style labels.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/label:in:data",
         meta = "⟨options⟩"
      },
      ["visualizer options/label in legend"] = {
         details = [[
This key is passed to a data set, similar to options like pin in data or
smooth line. The ⟨options⟩ are used to configure the following:

-   The legend in which the data set should be visualized.

-   The text that is to be shown in the legend for the data set.

-   The appearance of the legend entries.

In detail, the ⟨options⟩ are executed with the path prefix

    /tikz/data visualization/legend entry options

To configure in which legend the label should appear, use the following
key:

In addition to the two keys described above, there are further keys that
are described in Section ??.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/label:in:legend",
         meta = "⟨options⟩"
      },
      ["visualizer options/label in legend options"] = {
         details = [[
Use this key with a visualizer to configure the label in legend options.
Typically, this key is used only internally by a visualizer upon its
creating to set the ⟨options⟩ to setup the visualizer in legend key.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/label:in:legend:options",
         meta = "⟨options⟩"
      },
      ["visualizer options/no lines"] = {
         details = [[
Suppresses the line. This option only makes sense when the mark option
is used.

    \tikz [scale=.55] \datavisualization
     [scientific axes=clean, all axes={ticks=few},
      visualize as smooth line=my data,  my data={no lines, style={mark=x}}]
    data [format=function] {
      var t : interval [0:4] samples 5;
      func x = cos(\value t r);
      func y = sin(\value t r);
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/no:lines"
      },
      ["visualizer options/pin in data"] = {
         details = [[
This key is a variant of the label in data key and takes the same
options, plus two additional ones. The difference to label in data is
that the label node is shown a bit removed from the data set, but
connected to it via a small line (this is like the difference between
the label and pin options).

    \tikz \datavisualization [
      scientific axes=clean,
      visualize as smooth line/.list={linear, squared, cubed},
      linear ={pin in data={text=$2x$}},
      squared={pin in data={text=$x^2$}},
      cubed  ={pin in data={text=$x^3$}}]
    data [set=linear, format=function] {
      var x : interval [0:1.5];
      func y = \value x;
    }
    data [set=squared, format=function] {
      var x : interval [0:1.5];
      func y = \value x * \value x;
    }
    data [set=cubed, format=function] {
      var x : interval [0:1.5];
      func y = \value x * \value x * \value x;
    };

The following keys can be used additionally:

     {
        var x : interval [0.2:2.5];
        func y = ln(\value x);
      }
      data [set=lin, format=function] {
        var x : interval [-2:2.5];
        func y = 0.5*\value x;
      }
      data [set=squared, format=function] {
        var x : interval [-1.5:1.5];
        func y = \value x*\value x;
      }
      data [set=exp, format=function] {
        var x : interval [-2.5:1];
        func y = exp(\value x);
      }
    };},
    ]
    \tikz \datavisualization [
      school book axes,
      x axis={label=$x$},
      visualize as smooth line/.list={log, lin, squared, exp},
      every data set label/.append style={text colored},
      log=    {pin in data={text'=$\log x$, when=y is -1}},
      lin=    {pin in data={text=$x/2$, when=x is 2,
                            pin length=1ex}},
      squared={pin in data={text=$x^2$, when=x is 1.1,
                            pin angle=230}},
      exp=    {label in data={text=$e^x$, when=x is -2}},
      style sheet=vary hue]
    data group {function classes};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/pin:in:data",
         meta = "⟨options⟩"
      },
      ["visualizer options/polygon"] = {
         details = [[
This is an alias for straight cycle.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/polygon"
      },
      ["visualizer options/smooth cycle"] = {
         details = [[
Causes the data points to be connected by a circular line that is
smoothed at the joins:

    \tikz [scale=.55] \datavisualization
     [scientific axes=clean, all axes={ticks=few},
      visualize as smooth line=my data,  my data={smooth cycle}]
    data [format=function] {
      var t : interval [0:4] samples 5;
      func x = cos(\value t r);
      func y = sin(\value t r);
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/smooth:cycle"
      },
      ["visualizer options/smooth line"] = {
         details = [[
Causes the data points to be connected by a line that is smoothed at the
joins:

    \tikz [scale=.55] \datavisualization
     [scientific axes=clean, all axes={ticks=few},
      visualize as smooth line=my data,  my data={smooth line}]
    data [format=function] {
      var t : interval [0:4] samples 5;
      func x = cos(\value t r);
      func y = sin(\value t r);
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/smooth:line"
      },
      ["visualizer options/straight cycle"] = {
         details = [[
Causes the data points to be connected by a polygon.

    \tikz [scale=.55] \datavisualization
     [scientific axes=clean, all axes={ticks=few},
      visualize as smooth line=my data,  my data={straight cycle}]
    data [format=function] {
      var t : interval [0:4] samples 5;
      func x = cos(\value t r);
      func y = sin(\value t r);
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/straight:cycle"
      },
      ["visualizer options/straight line"] = {
         details = [[
Causes the data points to be connected by straight lines.

    \tikz [scale=.55] \datavisualization
     [scientific axes=clean, all axes={ticks=few},
      visualize as smooth line=my data,  my data={straight line}]
    data [format=function] {
      var t : interval [0:4] samples 5;
      func x = cos(\value t r);
      func y = sin(\value t r);
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/straight:line"
      },
      ["visualizer options/style"] = {
         details = [[
The ⟨options⟩ given to this key should be normal TikZ options. They will
be executed when the visualizer is used.

    \tikz \datavisualization
     [scientific axes=clean,
      visualize as smooth line=sin,
      sin={style={red, densely dotted}},
      visualize as smooth line=cos,
      cos={style={mark=x}},
    ]
    data [set=sin, format=function] {
      var x : interval[0:3*pi];
      func y = sin(\value x r);
    }
    data [set=cos, format=function] {
      var x : interval[0:3*pi];
      func y = cos(\value x r);
    };

When you have multiple visualizers in a single data visualization, you
can use the style option with each visualizer to configure their
different appearances as in the above example. However, it is usually
much better (and easier) to use a style sheet, see Section ??.

    \tikz \datavisualization
     [scientific axes={clean, end labels},
      x axis={label=$x$}, y axis={grid={major also at=0}},
      visualize as smooth line/.list={sin,cos,sin 2,cos 2},
      legend={below, rows=2},
      sin={label in legend={text=$\sin x$}},
      cos={label in legend={text=$\cos x$}},
      sin 2={label in legend={text=$\sin 2x$}},
      cos 2={label in legend={text=$\cos 2x$}},
      style sheet=strong colors]
    data [set=sin, format=function] {
      var x : interval[0:3*pi];
      func y = sin(\value x r);
    }
    data [set=cos, format=function] {
      var x : interval[0:3*pi];
      func y = cos(\value x r);
    }
    data [set=sin 2, format=function] {
      var x : interval[0:3*pi];
      func y = sin(2*\value x r);
    }
    data [set=cos 2, format=function] {
      var x : interval[0:3*pi];
      func y = cos(2*\value x r);
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/visualizer:options/style",
         meta = "⟨options⟩"
      },
      when = {
         details = [[
This key is used to specify when the object is to be created. As
described above, the object is not created immediately, but at some time
during the rendering process. You can specify any of the phases defined
by the data visualization object, see Section ?? for details.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/when",
         meta = "⟨phase name⟩"
      },
      ["xy Cartesian"] = {
         details = [[
This axis system creates two axes called x axis and y axis that point
right and up, respectively. By default, one unit is mapped to one cm.

    \begin{tikzpicture}
      \datavisualization [xy Cartesian, visualize as smooth line]
        data [format=function] {
          var x : interval [-1.25:1.25];
          func y = \value x*\value x*\value x;
        };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/xy:Cartesian"
      },
      ["xy axes"] = {
         details = [[
This key applies the ⟨options⟩ both to the x axis and the y axis.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/xy:axes",
         meta = "⟨options⟩"
      },
      ["xyz Cartesian cabinet"] = {
         details = [[
This axis system works like xy Cartesian, only it additionally creates
an axis called z axis that points left and down. For this axis, one unit
corresponds to $\frac{1}{2}\sin 45^\circ\mathrm{cm}$. This is also known
as a cabinet projection.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/xyz:Cartesian:cabinet"
      },
      ["xyz axes"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/xyz:axes",
         meta = "⟨options⟩"
      },
      ["⟨axis name⟩"] = {
         details = [[
This key becomes available once new axis base=metaaxis name has been
called. It will execute the ⟨options⟩ with the path prefix
/tikz/data visualization/axis options.

    [new axis base=my axis,
     my axis={attribute=some attribute}]
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/⟨axis:name⟩",
         meta = "⟨options⟩"
      },
      ["⟨axis system name⟩"] = {
         details = [[
When the key ⟨axis system name⟩ is used, the following keys will be
executed in the following order:

1.  The ⟨axis setup⟩ with the path prefix /tikz/data visualization/.

2.  The ⟨default options⟩ with the same path prefix.

3.  The following style:

4.  The ⟨options⟩ with the path prefix /tikz/data visualization/⟨axis
    system name⟩.

5.  The ⟨application options⟩ with the path prefix
    /tikz/data visualization/
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/⟨axis:system:name⟩",
         meta = "⟨options⟩"
      },
      ["⟨legend name⟩"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/⟨legend:name⟩",
         meta = "⟨options⟩"
      },
      ["⟨visualizer name⟩"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualization/⟨visualizer:name⟩",
         meta = "⟨options⟩"
      }
   },
   graphs = {
      ["--"] = {
         details = [[
Sets the default edge kind to –.

    \tikz \graph { subgraph K_n [--, n=5, clockwise, radius=6mm] };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/--"
      },
      ["->"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/->"
      },
      ["-\\protect\\exclamationmarktext-"] = {
         details = [[
Sets the default edge kind to -!-.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/-\\protect\\exclamationmarktext-"
      },
      ["<-"] = {
         details = [[
Sets the default edge kind to <-.

    \tikz \graph { subgraph K_n [<-, n=5, clockwise, radius=6mm] };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/<-"
      },
      ["<->"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/<->"
      },
      ["Cartesian placement"] = {
         details = [[
This strategy is the default strategy. It works, roughly, as follows:
For each new node on a chain, advance a "logical width" counter and for
each new node in a group, advance a "logical depth" counter. When a
chain contains a whole group, then the "logical width" taken up by the
group is the maximum over the logical widths taken up by the chains
inside the group; and symmetrically the logical depth of a chain is the
maximum of the depths of the groups inside it.

This slightly confusing explanation is perhaps best exemplified. In the
below example, the two numbers indicate the two logical width and depth
of each node as computed by the graphs library. Just ignore the arcane
code that is used to print these numbers.

    \tikz
      \graph [nodes={align=center, inner sep=1pt}, grow right=7mm,
              typeset={\tikzgraphnodetext\\[-4pt]
                       \tiny\mywidth\\[-6pt]\tiny\mydepth},
              placement/compute position/.append code=
                \pgfkeysgetvalue{/tikz/graphs/placement/width}{\mywidth}
                \pgfkeysgetvalue{/tikz/graphs/placement/depth}{\mydepth}]
    {
      a,
      b,
      c -> d -> {
        e -> f -> g,
        h -> i
      } -> j,
      k -> l
    };

You will find a detailed description of how these logical units are
computed, exactly, in Section ??.

Now, even though we talk about "widths" and "depths" and even though by
default a graph "grows" to the right and down, this is by no means
fixed. Instead, you can use the following keys to change how widths and
heights are interpreted:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/Cartesian:placement"
      },
      V = {
         details = [[
Sets a list of vertex names for use with graphs like subgraph I_ n and
also other graphs. This list is available in the macro \tikzgraphV. The
number of elements of this list is available in \tikzgraphVnum.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/V",
         meta = "{list of vertices}"
      },
      W = {
         details = [[
Sets the list of vertices for the W set. The elements and their number
are available in the macros \tikzgraphW and \tikzgraphWnum,
respectively.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/W",
         meta = "{list of vertices}"
      },
      as = {
         details = [[
The ⟨text⟩ is used as the text of the node. This allows you to provide a
text for the node that differs arbitrarily from the name of the node.

    \tikz \graph { a [as=$x$] -- b [as=$y_5$] -> c [red, as={a--b}] };

This key always takes precedence over all of the mechanisms described
below.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/as",
         meta = "⟨text⟩"
      },
      ["branch down"] = {
         details = [[
    \tikz \graph [branch down=7mm] { a -> b -> {c, d, e}};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/branch:down",
         meta = "⟨distance⟩"
      },
      ["branch down sep"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/branch:down:sep",
         meta = "⟨distance⟩"
      },
      ["branch left"] = {
         details = [[
    \tikz \graph [branch left=7mm, grow down=7mm] { a -> b -> {c, d, e}};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/branch:left",
         meta = "⟨distance⟩"
      },
      ["branch left sep"] = {
         details = [[
    \tikz \graph [grow down sep, branch left sep] {
      start -- {
        an even longer text -- {short, very long text} -- more text,
        long -- longer,
        some text -- a -- b
      } -- end
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/branch:left:sep",
         meta = "⟨distance⟩"
      },
      ["branch right"] = {
         details = [[
    \tikz \graph [branch right=7mm, grow down=7mm] { a -> b -> {c, d, e}};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/branch:right",
         meta = "⟨distance⟩"
      },
      ["branch right sep"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/branch:right:sep",
         meta = "⟨distance⟩"
      },
      ["branch up"] = {
         details = [[
Sets the group shift so that groups "branch upward". The distance by
which the center of each new element is removed from the center of the
previous one is ⟨distance⟩.

    \tikz \graph [branch up=7mm] { a -> b -> {c, d, e} };

Note that when you draw a tree, the branch ... keys specify how siblings
(or adjacent branches) are arranged, while the grow ... keys specify in
which direction the branches "grow".
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/branch:up",
         meta = "⟨distance⟩"
      },
      ["branch up sep"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/branch:up:sep",
         meta = "⟨distance⟩"
      },
      butterfly = {
         details = [[
The butterfly connector is used to create the kind of connections
present between layers of a so-called butterfly network. As for other
connectors, two sets of nodes are connected, which are the nodes having
color target’ and source’ by default. In a level $l$ connection, the
first $l$ nodes of the first set are connected to the second $l$ nodes
of the second set, while the second $l$ nodes of the first set get
connected to the first $l$ nodes of the second set. Then, for next $2l$
nodes of both sets a similar kind of connection is installed.
Additionally, each node gets connected to the corresponding node in the
other set with the same index (as in a matching):

    \tikz \graph [left anchor=east, right anchor=west,
                  branch down=4mm, grow right=15mm] {
      subgraph I_n [n=12, name=A] --[butterfly={level=3}]
      subgraph I_n [n=12, name=B] --[butterfly={level=2}]
      subgraph I_n [n=12, name=C]
    };

Unlike most joining operators, the colors of the nodes in the first and
the second set are not passed as parameters to the butterfly key.
Rather, they can be set using the ⟨options⟩, which are executed with the
path prefix /tikz/graphs/butterfly.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/butterfly",
         meta = "⟨options⟩"
      },
      ["butterfly/from"] = {
         details = [[
Sets the color class of the from nodes.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/butterfly/from",
         meta = "⟨color⟩"
      },
      ["butterfly/level"] = {
         details = [[
Sets the level $l$ for the connections.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/butterfly/level",
         meta = "⟨level⟩"
      },
      ["butterfly/to"] = {
         details = [[
Sets the color class of the to nodes.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/butterfly/to",
         meta = "⟨color⟩"
      },
      ["chain polar shift"] = {
         details = [[
Under the regime of the circular placement strategy, each node on a
chain is shifted by (⟨logical width⟩⟨angle⟩:⟨logical width⟩⟨angle⟩).

    \tikz \graph [circular placement] {
      a -> b -> c;
      d -> e;
      f ->  g -> h;
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/chain:polar:shift",
         meta = "(⟨angle⟩:⟨radius⟩)"
      },
      ["chain shift"] = {
         details = [[
Under the regime of the Cartesian placement strategy, each node is
shifted by the current logical width times this ⟨coordinate⟩.

    \tikz \graph [chain shift=(45:1)] {
      a -> b -> c;
      d -> e;
      f -> g -> h;
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/chain:shift",
         meta = "⟨coordinate⟩"
      },
      ["circular placement"] = {
         details = [[
This key works quite similar to Cartesian placement. As for that
placement strategy, a node has logical width and depth 1. However, the
computed total width and depth are mapped to polar coordinates rather
than Cartesian coordinates.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/circular:placement"
      },
      ["clear <"] = {
         details = [[
A more easy-to-remember shorthand for source edge clear.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/clear:<"
      },
      ["clear >"] = {
         details = [[
A more easy-to-remember shorthand for target edge clear.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/clear:>"
      },
      clique = {
         details = [[
Adds an edge between all vertices of the current group having the
(logical) color ⟨color⟩. Since, by default, this color is set to all,
which is a color that all nodes get by default, when you do not specify
anything, all nodes will be connected.

    \tikz \graph [clockwise, n=5] {
      a,
      b,
      {
        [clique]
        c, d, e
      }
    };

    \tikz \graph [color class=red, clockwise, n=5] {
      [clique=red, ->]
      a, b[red], c[red], d, e[red]
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/clique",
         meta = "⟨color⟩"
      },
      clockwise = {
         details = [[
This key sets the group shift so that if there are exactly ⟨number⟩ many
nodes in a group, they will form a complete circle. If you do not
provide a ⟨number⟩, the current value of \tikzgraphVnum is used, which
is exactly what you want when you use predefined graph macros like
subgraph K_ n.

    \tikz \graph [clockwise=4] { a, b, c, d };

    \tikz \graph [clockwise] { subgraph K_n [n=5] };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/clockwise",
         meta = "⟨number⟩"
      },
      ["color class"] = {
         details = [[
This sets up a new color class called ⟨color class name⟩. Nodes and
whole groups of nodes can now be colored with ⟨color class name⟩. This
is done using the following keys, which become available inside the
current scope:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/color:class",
         meta = "⟨color class name⟩"
      },
      ["complete bipartite"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/complete:bipartite",
         meta = "⟨from color⟩⟨to color⟩"
      },
      counterclockwise = {
         details = [[
Works like clockwise, only the direction is inverted.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/counterclockwise",
         meta = "⟨number⟩"
      },
      cycle = {
         details = [[
Connects the nodes colored ⟨color⟩ is a cyclic fashion. The ordering is
the ordering in which they appear in the whole graph specification.

    \tikz \graph [clockwise, n=6, phase=60] {
      { [cycle, ->] a, b, c },
      { [cycle, <-] d, e, f }
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/cycle",
         meta = "⟨color⟩"
      },
      declare = {
         details = [[
This key declares that ⟨graph name⟩ can subsequently be used as a
replacement for a ⟨node name⟩. Whenever the ⟨graph name⟩ is used in the
following, a graph group will be inserted instead whose content is
exactly ⟨specification⟩. In case ⟨graph name⟩ is used together with some
⟨options⟩, they are executed prior to inserting the ⟨specification⟩.

    \tikz \graph [branch down=4mm, declare={claw}{1 -- {2,3,4}}] {
      a;
      claw;
      b;
    };

In the next example, we use a key to configure a subgraph:

    \tikz \graph [ n/.code=\def\n{#1}, branch down=4mm,
                   declare={star}{root -- { \foreach \i in {1,...,\n} {\i} }}]
    { star [n=5]; };

Actually, the n key is already defined internally for a similar purpose.

As a last example, let us define a somewhat more complicated graph
macro.

    \newcount\mycount
    \tikzgraphsset{
      levels/.store in=\tikzgraphlevel,
      levels=1,
      declare={bintree}{%
        [/utils/exec={%
          \ifnum\tikzgraphlevel=1\relax%
            \def\childtrees{ / }%
          \else%
            \mycount=\tikzgraphlevel%
            \advance\mycount by-1\relax%
            \edef\childtrees{
              / -> {
                bintree[levels=\the\mycount],
                bintree[levels=\the\mycount]
              }}
          \fi%
        },
        parse/.expand once=\childtrees
        ]
        % Everything is inside the \childtrees...
      }
    }
    \tikz \graph [grow down=5mm, branch right=5mm] { bintree [levels=5] };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/declare",
         meta = "{graph name}{specification}"
      },
      ["default edge kind"] = {
         details = [[
This key stores one of the five edge kinds –, <-, ->, <->, and -!-. When
an operator wishes to create a new edge, it should typically set

    \tikzgraphsset{new \pfkeysvalueof{/tikz/graphs/default edge kind}=...}

While this key can be set explicitly, it may be more convenient to use
the abbreviating keys listed below. Also, this key is automatically set
to the current value of ⟨edge specification⟩ when a joining operator is
called, see the discussion of joining operators in Section ??.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/default:edge:kind",
         meta = "⟨value⟩"
      },
      ["default edge operator"] = {
         details = [[
This key stores the name of a ⟨key⟩ that is executed for every ⟨edge
specification⟩ whose ⟨options⟩ do not contain the operator key.

    \tikz \graph [default edge operator=matching] {
      {a, b}    ->[matching and star]
      {c, d, e} --[complete bipartite]
      {f, g, h} --
      {i, j, k}
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/default:edge:operator",
         meta = "⟨key⟩"
      },
      edge = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/edge",
         meta = "⟨options⟩"
      },
      ["edge label"] = {
         details = [[
This key is an abbreviation for edge node=node[auto]{⟨text⟩}. The net
effect is that the text is placed next to the newly created edges.

    \tikz \graph [edge label=x] { a -> b -> {c,d} };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/edge:label",
         meta = "⟨text⟩"
      },
      ["edge label'"] = {
         details = [[
This key is an abbreviation for edge node=node[auto,swap]{⟨text⟩}.

    \tikz \graph [edge label=out, edge label'=in]
      { subgraph C_n [clockwise, n=5] };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/edge:label'",
         meta = "⟨text⟩"
      },
      ["edge node"] = {
         details = [[
This key specifies that the ⟨node specification⟩ should be added to each
newly created edge as an implicitly placed node.

    \tikz \graph [edge node={node [red, near end] {X}}] { a -> b -> c };

Again, multiple uses of this key accumulate.

    \tikz \graph [edge node={node [near end] {X}},
                  edge node={node [near start] {Y}}] { a -> b -> c };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/edge:node",
         meta = "⟨node specification⟩"
      },
      ["edge quotes"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/edge:quotes",
         meta = "⟨options⟩"
      },
      ["edge quotes center"] = {
         details = [[
A shorthand for edge quotes to anchor=center.

    \tikz \graph [edge quotes center] {
      a ->["x"] b ->["y"] c ->["z" red] d;
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/edge:quotes:center"
      },
      ["edge quotes mid"] = {
         details = [[
A shorthand for edge quotes to anchor=mid.

    \tikz \graph [edge quotes mid] {
      a ->["x"] b ->["y"] c ->["z" red] d;
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/edge:quotes:mid"
      },
      edges = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/edges",
         meta = "⟨options⟩"
      },
      ["empty nodes"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/empty:nodes"
      },
      ["every graph"] = {
         details = [[
This style is executed at the beginning of every graph path command
prior to the ⟨options⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/every:graph"
      },
      ["fresh nodes"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/fresh:nodes",
         meta = "⟨true or false⟩"
      },
      ["grid placement"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grid:placement"
      },
      ["group polar shift"] = {
         details = [[
Like for group shift, each node on a chain is shifted by (⟨logical
depth⟩⟨angle⟩:⟨logical depth⟩⟨angle⟩).

    \tikz \graph [circular placement, group polar shift=(30:0)] {
      a -> b -> c;
      d -> e;
      f -> g -> h;
    };

    \tikz \graph [circular placement,
                  chain polar shift=(30:0),
                  group polar shift=(0:1cm)] {
      a -- b -- c;
      d -- e;
      f -- g -- h;
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/group:polar:shift",
         meta = "(⟨angle⟩:⟨radius⟩)"
      },
      ["group shift"] = {
         details = [[
Like for chain shift, each node is shifted by the current logical depth
times this ⟨coordinate⟩.

    \tikz \graph [chain shift=(45:7mm), group shift=(-45:7mm)] {
      a -> b -> c;
      d -> e;
      f -> g -> h;
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/group:shift",
         meta = "⟨coordinate⟩"
      },
      ["grow down"] = {
         details = [[
Like grow up.

    \tikz \graph [grow down=7mm] { a -> b -> c};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grow:down",
         meta = "⟨distance⟩"
      },
      ["grow down sep"] = {
         details = [[
As above.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grow:down:sep",
         meta = "⟨distance⟩"
      },
      ["grow left"] = {
         details = [[
Like grow up.

    \tikz \graph [grow left=7mm] { a -> b -> c};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grow:left",
         meta = "⟨distance⟩"
      },
      ["grow left sep"] = {
         details = [[
    \tikz \graph [grow left sep] { long -- longer -- longest };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grow:left:sep",
         meta = "⟨distance⟩"
      },
      ["grow right"] = {
         details = [[
Like grow up.

    \tikz \graph [grow right=7mm] { a -> b -> c};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grow:right",
         meta = "⟨distance⟩"
      },
      ["grow right sep"] = {
         details = [[
This key has several effects, but let us start with the bottom line:
Nodes along a chain are placed in such a way that the left end of a new
node is ⟨distance⟩ from the right end of the previous node:

    \tikz \graph [grow right sep, left anchor=east, right anchor=west] {
      start -- {
        long text -- {short, very long text} -- more text,
        long -- longer -- longest
      } -- end
    };

What happens internally is the following: First, the anchor of the nodes
is set to west (or north west or south west, see below). Second, the
logical width of a node is no longer 1, but set to the actual width of
the node (which we define as the horizontal difference between the west
anchor and the east anchor) in points. Third, the chain shift is set to
(1pt,0pt).
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grow:right:sep",
         meta = "⟨distance⟩"
      },
      ["grow up"] = {
         details = [[
Sets the chain shift to (0,⟨distance⟩), so that chains "grow upward".
The distance by which the center of each new element is removed from the
center of the previous one is ⟨distance⟩.

    \tikz \graph [grow up=7mm] { a -> b -> c};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grow:up",
         meta = "⟨distance⟩"
      },
      ["grow up sep"] = {
         details = [[
    \tikz \graph [grow up sep] {
      a / $a=x$ --
      b / {$b=\displaystyle \int_0^1 x dx$} --
      c [draw, circle, inner sep=7mm]
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/grow:up:sep",
         meta = "⟨distance⟩"
      },
      ["induced complete bipartite"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/induced:complete:bipartite"
      },
      ["induced cycle"] = {
         details = [[
While the cycle command will only add edges, this key will also remove
all other edges between the nodes of the cycle, provided we are
constructing a simple graph.

    \tikz \graph [simple] {
      subgraph K_n [n=7, clockwise]; % create lots of edges

      { [induced cycle, ->, edge=red] 2, 3, 4, 6, 7 },
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/induced:cycle",
         meta = "⟨color⟩"
      },
      ["induced independent set"] = {
         details = [[
This key is the "opposite" of a clique: It removes all edges in the
current group having belonging to color class ⟨color⟩. More precisely,
an edge of kind -!- is added for each pair of vertices. This means that
edge only get removed if you specify the simple option.

    \tikz \graph [simple] {
      subgraph K_n [<->, n=7, clockwise]; % create lots of edges

      { [induced independent set] 1, 3, 4, 5, 6 }
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/induced:independent:set",
         meta = "⟨color⟩"
      },
      ["induced path"] = {
         details = [[
Works like induced cycle, only there is no edge from the last to the
first vertex.

    \tikz \graph [simple] {
      subgraph K_n [n=7, clockwise]; % create lots of edges

      { [induced path, ->, edges=red] 2, 3, 4, 6, 7 },
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/induced:path",
         meta = "⟨color⟩"
      },
      ["left anchor"] = {
         details = [[
This anchor is used for the node that is to the left of an edge
specification. Setting this anchor to the empty string means that no
special anchor is used (which is the default). The ⟨anchor⟩ is stored in
the macro \tikzgraphleftanchor with a leading dot.

    \tikz \graph {
      {a,b,c} -> [complete bipartite] {e,f,g}
    };

    \tikz \graph [left anchor=east, right anchor=west] {
      {a,b,c} -- [complete bipartite] {e,f,g}
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/left:anchor",
         meta = "⟨anchor⟩"
      },
      m = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/m",
         meta = "⟨number⟩"
      },
      matching = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/matching",
         meta = "⟨from color⟩⟨to color⟩"
      },
      ["matching and star"] = {
         details = [[
The matching and star connector works like the matching connector, only
it behaves differently when the two to-be-connected sets have different
size. In this case, all the surplus nodes get connected to the last node
of the other set, resulting in what is known as a star in graph theory.
This simple rule allows for some powerful effects (since this connector
is the one initially set, there is no need to add it here):

    \tikz \graph { a -> {b, c} -> {d, e} -- f};

The matching and star connector also makes it easy to create trees and
series-parallel graphs.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/matching:and:star",
         meta = "⟨from color⟩⟨to color⟩"
      },
      ["math nodes"] = {
         details = [[
Sets typeset to \textbackslash tikzgraphnodetext, which causes all nodes
names to be typeset in math mode:

    \tikz \graph [math nodes, nodes={circle, draw}] { a_1 -> {b^2, c_3^n} };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/math:nodes"
      },
      multi = {
         details = [[
When this edge is set for a whole graph (which is the default) or just
for a group (which is useful if the whole graph is simple in general,
but a part is a multi-graph), then when you specify an edge between two
nodes several times, several such edges get created:

    \tikz \graph [multi] { % "multi" is not really necessary here
      a ->[bend left,  red]  b;
      a ->[bend right, blue] b;
    };

In case multi is used for a scope inside a larger scope where the simple
option is specified, then inside the local multi scope edges are
immediately created and they are completely ignored when it comes to
deciding which kind of edges should be present in the surrounding simple
graph. From the surrounding scope's point of view it is as if the local
multi graph contained no edges at all.

This means, in particular, that you can use the multi option with a
single edge to "enforce" this edge to be present in a simple graph.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/multi"
      },
      n = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/n",
         meta = "⟨number⟩"
      },
      name = {
         details = [[
This key prepends the ⟨text⟩, followed by a separating symbol (a space
by default), to all ⟨node name⟩s inside a ⟨full node name⟩. Repeated
calls of this key accumulate, leading to ever-longer "name paths":

    \begin{tikzpicture}
      \graph {
        { [name=first]  1, 2, 3} --
        { [name=second] 1, 2, 3}
      };
      \draw [red] (second 1) circle [radius=3mm];
    \end{tikzpicture}

Note that, indeed, in the above example six nodes are created even
though the first and second set of nodes have the same ⟨node name⟩. The
reason is that the full names of the six nodes are all different. Also
note that only the ⟨node name⟩ is used as the node text, not the full
name. This can be changed as described later on.

This key can be used repeatedly, leading to ever longer node names.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/name",
         meta = "⟨text⟩"
      },
      ["name separator"] = {
         details = [[
Changes the symbol that is used to separate the ⟨text⟩ from the ⟨node
name⟩. The default is \space, resulting in a space.

    \begin{tikzpicture}
      \graph [name separator=] { % no separator
        { [name=first]  1, 2, 3} --
        { [name=second] 1, 2, 3}
      };
      \draw [red] (second1) circle [radius=3mm];
    \end{tikzpicture}

    \begin{tikzpicture}
      \graph [name separator=-] {
        { [name=first]  1, 2, 3} --
        { [name=second] 1, 2, 3}
      };
      \draw [red] (second-1) circle [radius=3mm];
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/name:separator",
         meta = "⟨symbols⟩"
      },
      ["name shore V"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/name:shore:V"
      },
      ["name shore W"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/name:shore:W"
      },
      ["new --"] = {
         details = [[
This key is called for – with the same parameters as above. The only
difference in the definition is that in the \path command the -> gets
replaced by -.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/new:--",
         meta = "{left node}{right node}{edge options}{edge nodes}"
      },
      ["new ->"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/new:->",
         meta = "{left node}{right node}{edge options}{edge nodes}"
      },
      ["new -\\protect\\exclamationmarktext-"] = {
         details = [[
Called for -!- with the same parameters as above. Does nothing by
default.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/new:-\\protect\\exclamationmarktext-",
         meta = "{left node}{right node}{edge options}{edge nodes}"
      },
      ["new <-"] = {
         details = [[
Called for <- with the same parameters as above. [1]

[1] You might wonder why this key is needed: It seems more logical at
first sight to just call new edge directed with swapped first
parameters. However, a positioning algorithm might wish to take the fact
into account that an edge is "backward" rather than "forward" in order
to improve the layout. Also, different arrow heads might be used.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/new:<-",
         meta = "{left node}{right node}{edge options}{edge nodes}"
      },
      ["new <->"] = {
         details = [[
Called for <-> with the same parameters as above. The -> is replaced by
<-
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/new:<->",
         meta = "{left node}{right node}{edge options}{edge nodes}"
      },
      ["no placement"] = {
         details = [[
This strategy simply "switches off" the whole placement mechanism,
causing all nodes to be placed at the origin by default. You need to use
this strategy if you position nodes "by hand". For this, you can use the
at key, the shift keys:

    \tikz \graph [no placement]
    {
      a[at={(0:0)}] -> b[at={(1,0)}] -> c[yshift=1cm];
    };

Since the syntax and the many braces and parentheses are a bit
cumbersome, the following two keys might also be useful:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/no:placement"
      },
      nodes = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/nodes",
         meta = "⟨options⟩"
      },
      ["not ⟨color class name⟩"] = {
         details = [[
Sets up an operator for the current scope so that all nodes in it loose
the color ⟨color class name⟩. You can also use !⟨color class name⟩ as an
alias for this key.

    \tikz \graph [color class=red, color class=green,
                  math nodes, clockwise, n=5] {
      [complete bipartite={red}{green}]
      { [red]   r_1, r_2 },
      { [green] g_1, g_2, g_3 },
      g_2 [not green]
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/not:⟨color:class:name⟩"
      },
      ["number nodes"] = {
         details = [[
When this key is used in a scope, each encountered node name will get
appended a new number, starting with ⟨start⟩. Typically, this ensures
that all node names are different. Between the original node name and
the appended number, the setting of the following will be inserted:

    \tikz \graph [branch down=5mm] {
      { [number nodes]
        a -> {
          b -> {c, c},
          b -> {c, c},
          b -> {c, c},
        }
      },
      b 2 -- b 5
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/number:nodes",
         meta = "⟨start number⟩"
      },
      ["number nodes sep"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/number:nodes:sep",
         meta = "⟨text⟩"
      },
      operator = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/operator",
         meta = "⟨code⟩"
      },
      path = {
         details = [[
Works like cycle, only there is no edge from the last to the first
vertex.

    \tikz \graph [clockwise, n=6] {
      { [path, ->] a, b, c },
      { [path, <-] d, e, f }
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/path",
         meta = "⟨color⟩"
      },
      phase = {
         details = [[
This is an initial value that is added to the total computed angle when
the polar shift of a node has been calculated.

    \tikz \graph [circular placement] { a, b, c, d };

    \tikz \graph [circular placement, phase=0] { a, b, c, d };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/phase",
         meta = "⟨angle⟩"
      },
      ["placement/chain count"] = {
         details = [[
This key stores a number that tells us the sequence number of the chain
in the current group.

    \tikz \graph [
      grow right sep, branch down=5mm, typeset=\tikzgraphnodetext:\mynum,
      placement/compute position/.append code=
        \pgfkeysgetvalue{/tikz/graphs/placement/chain count}{\mynum}]
    {
      a -> b -> {c,d,e},
      f,
      g -> h
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/chain:count"
      },
      ["placement/compute position"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/compute:position",
         meta = "⟨code⟩"
      },
      ["placement/depth"] = {
         details = [[
Similarly to the width key, this key stores the "logical depth" of the
nodes parsed up to now in the current group or chain and, also
similarly, this key may or may not be related to the actual depth/height
of the current node. As for the width, the exact definition is as
follows: For a single node, the depth is computed by the following key:

Second, the depth of a group is the sum of the depths of its elements.
Third, the depth of a chain is the maximum of the depth of its elements.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/depth"
      },
      ["placement/element count"] = {
         details = [[
This key stores a number that tells us the position of the node on the
current chain. However, you only have access to this value inside the
code passed to the macro compute position, explained later on.

    \tikz \graph [
      grow right sep, typeset=\tikzgraphnodetext:\mynum,
      placement/compute position/.append code=
        \pgfkeysgetvalue{/tikz/graphs/placement/element count}{\mynum}]
    {
      a -> b -> c,
      d -> {e, f->h} -> j
    };

As can be seen, each group resets the element counter.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/element:count"
      },
      ["placement/level"] = {
         details = [[
This key stores a number that is increased for each element on a chain,
but gets reset at the end of a group:

    \tikz \graph [ branch down=5mm, typeset=
        \tikzgraphnodetext:\pgfkeysvalueof{/tikz/graphs/placement/level}]
    {
      a -> {
        b,
        c -> {
          d,
          e -> {f,g},
          h
        },
        j
      }
    };

Unlike the parameters depth and width described in the next section, the
key level is always available.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/level"
      },
      ["placement/logical node depth"] = {
         details = [[
The code behind this key should return the "logical height" of the node
⟨full node name⟩ in the macro \pgfmathresult.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/logical:node:depth",
         meta = "⟨full node name⟩"
      },
      ["placement/logical node width"] = {
         details = [[
This key is called to compute a physical or logical width of the node
⟨full node name⟩. You can change the code of this key. The code should
return the computed value in the macro \pgfmathresult. By default, this
key returns 1.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/logical:node:width",
         meta = "⟨full node name⟩"
      },
      ["placement/place"] = {
         details = [[
Executing this key has two effects: First, the key compute position is
called to compute a good position for future nodes (usually, these
"future nodes" are just a single node that is created immediately).
Second, all of the above counters like depth or width are reset (but not
level).

There are two places where this key is sensibly called: First, just
prior to creating a node, which happens automatically. Second, when you
change the online strategy. In this case, the computed width and depth
values from one strategy typically make no sense in the other strategy,
which is why the new strategy should proceed "from a fresh start". In
this case, the implicit call of compute position ensures that the new
strategy gets the last place the old strategy would have used as its
starting point, while the computation of its positions is now relative
to this new starting point.

For these reasons, when an online strategy like Cartesian placement is
called, this key gets called implicitly. You will rarely need to call
this key directly, except when you define a new online strategy.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/place"
      },
      ["placement/width"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/placement/width"
      },
      ["put node text on incoming edges"] = {
         details = [[
When this key is used with a node or a group, the following happens:

1.  The command target edge node={node[⟨options⟩]{\tikzgraphnodetext}}
    is executed. This means that all incoming edges of the node get a
    label with the text that would usually be displayed in the node. You
    can use keys like math nodes normally.

2.  The command as={} is executed. This means that the node itself will
    display nothing.

Here is an example that show how this command is used.

    \tikz \graph [put node text on incoming edges,
                  math nodes, nodes={circle,draw}]
      { a -> b -> {c, d} };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/put:node:text:on:incoming:edges",
         meta = "⟨options⟩"
      },
      ["put node text on outgoing edges"] = {
         details = [[
Works like the previous key, only with target replaced by source.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/put:node:text:on:outgoing:edges",
         meta = "⟨options⟩"
      },
      quick = {
         details = [[
When you provide this key with a graph, the syntax of graph
specifications gets restricted. You are no longer allowed to use certain
features of the graph syntax; but all features that are still allowed
are also allowed in the same way when you do not provide the quick
option. Thus, leaving out the quick option will never hurt.

Since the syntax is so severely restricted, it is easier to explain
which aspects of the graph syntax will still work:

1.  A quick graph consists of a sequence of either nodes, edges
    sequences, or groups. These are separated by commas or semicolons.

2.  Every node is of the form

      "⟨node name⟩"/"⟨node text⟩"[⟨options⟩]

    The quotation marks are mandatory. The part /"⟨node text⟩" may be
    missing, in which case the node name is used as the node text. The
    ⟨options⟩ may also be missing. The ⟨node name⟩ may not contain any
    "funny" characters (unlike in the normal graph command).

3.  Every chain is of the form

      ⟨node spec⟩ ⟨connector⟩ ⟨node spec⟩ ⟨connector⟩ ...⟨connector⟩
      ⟨node spec⟩;

    Here, the ⟨node spec⟩ are node specifications as described above,
    the ⟨connector⟩ is one of the four connectors ->, <-, –, and <->
    (the connector -!- is not allowed since the simple option is also
    not allowed). Each connector may be followed by options in square
    brackets. The semicolon may be replaced by a comma.

4.  Every group is of the form

      { [⟨options⟩] ⟨chains and groups⟩ };

    The ⟨options⟩ are compulsory. The semicolon can, again, be replaced
    by a comma.

5.  The number nodes option will work as expected.

Here is a typical way this syntax might be used:

    \tikz \graph [quick] { "a" --["foo"] "b"[x=1] };

    \tikz \graph [quick] {
      "a"/"$a$" -- "b"[x=1] --[red] "c"[x=2];
      { [nodes=blue] "a" -- "d"[y=1]; };
    };

Let us now have a look at the most important things that will not work
when the quick option is used:

-   Connecting a node and a group as in a->{b,c}.

-   Node names without quotation marks as in a–b.

-   Everything described in subsequent subsections, which includes
    subgraphs (graph macros), graph sets, graph color classes, anonymous
    nodes, the fresh nodes option, sublayouts, simple graphs, edge
    annotations.

-   Placement strategies -- you either have to define all node positions
    explicitly using at= or x= and y= or you must use a graph drawing
    algorithm like layered layout.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/quick"
      },
      radius = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/radius",
         meta = "⟨dimension⟩"
      },
      ["recolor ⟨color class name⟩ by"] = {
         details = [[
Causes all keys having color ⟨color class name⟩ to get ⟨new color⟩
instead. They loose having color ⟨color class name⟩, but other colors
are not affected.

    \tikz \graph [color class=red, color class=green,
                  math nodes, clockwise, n=5] {
      [complete bipartite={red}{green}]
      { [red]   r_1, r_2 },
      { [green] g_1, g_2, g_3 },
      g_2 [recolor green by=red]
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/recolor:⟨color:class:name⟩:by",
         meta = "⟨new color⟩"
      },
      ["right anchor"] = {
         details = [[
Works like left anchor, only for \tikzgraphrightanchor.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/right:anchor",
         meta = "⟨anchor⟩"
      },
      simple = {
         details = [[
In contrast a multi-graph, in a simple graph, at most one edge gets
created for every pair of vertices:

    \tikz \graph [simple]{
      a ->[bend left,  red]  b;
      a ->[bend right, blue] b;
    };

As can be seen, the second edge "wins" over the first edge. The general
rule is as follows: In a simple graph, whenever an edge between two
vertices is specified multiple times, only the very last specification
and its options will actually be executed.

The real power of the simple option lies in the fact that you can first
create a complicated graph and then later redirect and otherwise modify
edges easily:

    \tikz \graph [simple, grow right=2cm] {
      {a,b,c,d} ->[complete bipartite] {e,f,g,h};

      { [edges={red,thick}] a -> e -> d -> g -> a };
    };

One particularly interesting kind of edge specification for a simple
graph is -!-. Recall that this is used to indicate that "no edge" should
be added between certain nodes. In a multi-graph, this key usually has
no effect (unless the key new -!- has been redefined) and is pretty
superfluous. In a simple graph, however, it counts as an edge kind and
you can thus use it to remove an edge that been added previously:

    \tikz \graph [simple] {
      subgraph K_n [n=8, clockwise];
      % Get rid of the following edges:
      1 -!- 2;
      3 -!- 4;
      6 -!- 8;
      % And make one edge red:
      1 --[red] 3;
    };

Creating a graph such as the above in other fashions is pretty awkward.

For every unordered pair $\{u,v\}$ of vertices at most one edge will be
created in a simple graph. In particular, when you say a -> b and later
also a <- b, then only the edge a <- b will be created. Similarly, when
you say a -> b and later b -> a, then only the edge b -> a will be
created.

The power of the simple command comes at a certain cost: As the graph is
being constructed, a (sparse) array is created that keeps track for each
edge of the last edge being specified. Then, at the end of the scope
containing the simple command, for every pair of vertices the edge is
created. This is implemented by two nested loops iterating over all
possible pairs of vertices -- which may take quite a while in a graph
of, say, 1000 vertices. Internally, the simple command is implemented as
an operator that adds the edges when it is called, but this should be
unimportant in normal situations.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/simple"
      },
      ["source edge clear"] = {
         details = [[
Works like target edge clear.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/source:edge:clear",
         meta = "⟨node specification⟩"
      },
      ["source edge node"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/source:edge:node",
         meta = "⟨node specification⟩"
      },
      ["source edge style"] = {
         details = [[
Works exactly like target edge style, only now the ⟨options⟩ are only
added when the node is a source of a newly created edge:

    \tikz \graph {
      { a, b } ->
      { c [source edge style=red], d } ->
      { e, f }
    };

If both for the source and also for the target of an edge ⟨options⟩ have
been specified, the options are applied in the following order:

1.  First come the options from the edge itself.

2.  Then come the options contributed by the source node using this key.

3.  Then come the options contributed by the target node using
    target node style.

    \tikz \graph {
      a [source edge style=red] ->[green]
      b [target edge style=blue]  % blue wins
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/source:edge:style",
         meta = "⟨options⟩"
      },
      ["target edge clear"] = {
         details = [[
Clears all ⟨options⟩ for edges with the node as a target and also edge
labels (see below) for this node.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/target:edge:clear"
      },
      ["target edge node"] = {
         details = [[
This key works like target edge style, only the ⟨node specification⟩
will not be added as options to any newly created edges with the current
node as their target, but rather it will be added as a node
specification.

    \tikz \graph {
      { a, b } ->
      { c [target edge node=node{X}], d } ->
      { e, f }
    };

As for target edge style multiple uses of this key accumulate and the
key target edge clear will (also) clear all target edge nodes that have
been set for a node earlier on.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/target:edge:node",
         meta = "⟨node specification⟩"
      },
      ["target edge style"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/target:edge:style",
         meta = "⟨options⟩"
      },
      trie = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/trie",
         meta = "⟨true or false⟩"
      },
      typeset = {
         details = [[
The macro or code stored in this key is used as the ⟨text⟩ of the node.
Inside the ⟨code⟩, the following macros are available:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/typeset",
         meta = "⟨code⟩"
      },
      ["use existing nodes"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/use:existing:nodes",
         meta = "⟨true or false⟩"
      },
      ["wrap after"] = {
         details = [[
Defines the number of nodes placed in a single row of the grid. This
value implicitly defines the number of grid columns as well. In the
following example a grid placement is used to visualize the edges
created between the nodes of a Grid_ n subgraph using different values
for wrap after.

    \tikz \graph [grid placement] { subgraph Grid_n [n=3,wrap after=1] };
    \tikz \graph [grid placement] { subgraph Grid_n [n=3,wrap after=3] };

    \tikz \graph [grid placement] { subgraph Grid_n [n=4,wrap after=2] };
    \tikz \graph [grid placement] { subgraph Grid_n [n=4] };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/wrap:after",
         meta = "⟨number⟩"
      },
      x = {
         details = [[
When you use this key, it will have the same effect as if you had
written at={(⟨x dimension⟩,⟨y dimension⟩)}, where ⟨y dimension⟩ is a
value set using the y key:

    \tikz \graph [no placement]
    {
      a[x=0,y=0] -> b[x=1,y=0] -> c[x=0,y=1];
    };

Note that you can specify an x or a y key for a whole scope and then
vary only the other key:

    \tikz \graph [no placement]
    {
      a ->
      { [x=1] % group option
        b [y=0] -> c[y=1]
      };
    };

Note that these keys have the path /tikz/graphs/, so they will be
available inside graphs and will not clash with the usual x and y keys
of TikZ, which are used to specify the basic lengths of vectors.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/x",
         meta = "⟨x dimension⟩"
      },
      y = {
         details = [[
See above.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/y",
         meta = "⟨y dimension⟩"
      },
      ["⟨color class name⟩"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graphs/⟨color:class:name⟩"
      }
   },
   tikz = {
      ["'"] = {
         details = [[
This is a very short alias for swap.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/'"
      },
      ["3d view"] = {
         details = [[
With the 3d view option, the projection of the 3D coordinates on the 2D
page is defined. It is determined by rotating the coordinate system by
$-⟨azimuth⟩$ around the $z$-axis, and by ⟨elevation⟩ around the (new)
$x$-axis, as shown below.

For example, when both ⟨azimuth⟩ and ⟨elevation⟩ are 0$^\circ$, $+z$
will be pointing upward, and $+x$ will be pointing right. The default is
as shown below.

    \begin{tikzpicture}[3d view]
      \draw[->] (-1,0,0) -- (1,0,0) node[pos=1.1]{x};
      \draw[->] (0,-1,0) -- (0,1,0) node[pos=1.1]{y};
      \draw[->] (0,0,-1) -- (0,0,1) node[pos=1.1]{z};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/3d:view",
         meta = "{azimuth}{elevation}"
      },
      [">"] = {
         details = [[
This is a short way of saying <->/.tip=⟨end arrow specification⟩.

    \begin{tikzpicture}[scale=2,ultra thick]
      \begin{scope}[>=Latex]
        \draw[>->]    (0pt,3ex) -- (1cm,3ex);
        \draw[|<->>|] (0pt,2ex) -- (1cm,2ex);
      \end{scope}
      \begin{scope}[>=Stealth]
        \draw[>->]    (0pt,1ex) -- (1cm,1ex);
        \draw[|<<.<->|] (0pt,0ex) -- (1cm,0ex);
      \end{scope}
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/>",
         meta = "⟨end arrow specification⟩"
      },
      above = {
         details = [[
Does the same as anchor=south. If the ⟨offset⟩ is specified, the node is
additionally shifted upwards by the given ⟨offset⟩.

    \tikz \fill (0,0) circle (2pt) node[above] {above};

    \tikz \fill (0,0) circle (2pt) node[above=2pt] {above};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/above",
         meta = "⟨offset⟩"
      },
      ["above delimiter"] = {
         details = [[
This option allows you to add a delimiter above the node. It is
implemented by rotating a left delimiter.

    \begin{tikzpicture}
      \matrix [matrix of math nodes,%
               left delimiter=\|,right delimiter=\rmoustache,%
               above delimiter=(,below delimiter=\}]
      {
        a_8 & a_1 & a_6 \\
        a_3 & a_5 & a_7 \\
        a_4 & a_9 & a_2 \\
      };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/above:delimiter",
         meta = "⟨delimiter⟩"
      },
      ["above left"] = {
         details = [[
Does the same as anchor=south east. Note that giving both above and left
options does not have the same effect as above left, rather only the
last left "wins". Actually, this option also takes an ⟨offset⟩
parameter, but using this parameter without using the positioning
library is deprecated. (The positioning library changes the meaning of
this parameter to something more sensible.)

    \tikz \fill (0,0) circle (2pt) node[above left] {above left};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/above:left"
      },
      ["above left of"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/above:left:of",
         meta = "⟨node⟩"
      },
      ["above of"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/above:of",
         meta = "⟨node⟩"
      },
      ["above right"] = {
         details = [[
Similar to above left.

    \tikz \fill (0,0) circle (2pt) node[above right] {above right};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/above:right"
      },
      ["above right of"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/above:right:of",
         meta = "⟨node⟩"
      },
      absolute = {
         details = [[
When this key is set, the ⟨angle⟩ is interpreted differently: We still
use a point on the border of the main node, but the angle is measured
"absolutely", that is, an angle of 0 refers to the point on the border
that lies on a straight line from the main node's center to the right
(relative to the paper, not relative to the local coordinate system of
either the node or the scope).

The difference can be seen in the following example:

    \tikz [rotate=-80,every label/.style={draw,red}]
      \node [transform shape,rectangle,draw,label=right:label] {main node};

    \tikz [rotate=-80,every label/.style={draw,red},absolute]
      \node [transform shape,rectangle,draw,label=right:label] {main node};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/absolute",
         meta = "⟨true or false⟩"
      },
      accepting = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/accepting"
      },
      ["accepting above"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/accepting:above"
      },
      ["accepting below"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/accepting:below"
      },
      ["accepting by arrow"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/accepting:by:arrow"
      },
      ["accepting by double"] = {
         details = [[
This style causes a double line to be drawn around a state.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/accepting:by:double"
      },
      ["accepting left"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/accepting:left"
      },
      ["accepting right"] = {
         details = [[
Works similarly to the previous option.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/accepting:right"
      },
      ["accepting text"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/accepting:text",
         meta = "⟨text⟩"
      },
      ["accepting where"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/accepting:where",
         meta = "⟨direction⟩"
      },
      alias = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/alias",
         meta = "⟨another node name⟩"
      },
      align = {
         details = [[
This key is used to set up an alignment for multi-line text inside a
node. If text width is set to some width (let us call this alignment
with line breaking), the align key will setup the \leftskip and the
\rightskip in such a way that the text is broken and aligned according
to ⟨alignment option⟩. If text width is not set (that is, set to the
empty string; let us call this alignment without line breaking), then a
different mechanism is used internally, namely the key
node halign header, is set to an appropriate value. While this key,
which is documented below, is not to be used by beginners, the net
effect is simple: When text width is not set, you can use \\ to break
lines and align them according to ⟨alignment option⟩ and the resulting
node's width will be minimal to encompass the resulting lines.

In detail, you can set ⟨alignment option⟩ to one of the following
values:

align=left

    For alignment without line breaking, the different lines are simply
    aligned such that their left borders are below one another.

        \tikz \node[fill=yellow!80!black,align=left]
          {This is a\\ demonstration text for\\ alignments.};

    For alignment with line breaking, the same will happen; only the
    lines will now, additionally, be broken automatically:

        \tikz \node[fill=yellow!80!black,text width=3cm,align=left]
          {This is a demonstration text for showing how line breaking works.};

align=flush left

    For alignment without line breaking this option has exactly the same
    effect as left. However, for alignment with line breaking, there is
    a difference: While left uses the original plain TeX definition of a
    ragged right border, in which TeX will try to balance the right
    border as well as possible, flush left causes the right border to be
    ragged in the LaTeX-style, in which no balancing occurs. This looks
    ugly, but it may be useful for very narrow boxes and when you wish
    to avoid hyphenations.

        \tikz \node[fill=yellow!80!black,text width=3cm,align=flush left]
          {This is a demonstration text for showing how line breaking works.};

align=right

    Works like left, only for right alignment.

        \tikz \node[fill=yellow!80!black,align=right]
          {This is a\\ demonstration text for\\ alignments.};

        \tikz \node[fill=yellow!80!black,text width=3cm,align=right]
          {This is a demonstration text for showing how line breaking works.};

align=flush right

    Works like flush left, only for right alignment.

        \tikz \node[fill=yellow!80!black,text width=3cm,align=flush right]
          {This is a demonstration text for showing how line breaking works.};

align=center

    Works like left or right, only for centered alignment.

        \tikz \node[fill=yellow!80!black,align=center]
          {This is a\\ demonstration text for\\ alignments.};

        \tikz \node[fill=yellow!80!black,text width=3cm,align=center]
          {This is a demonstration text for showing how line breaking works.};

    There is one annoying problem with the center alignment (but not
    with flush center and the other options): If you specify a large
    line width and the node text fits on a single line and is, in fact,
    much shorter than the specified text width, an underfull horizontal
    box will result. Unfortunately, this cannot be avoided, due to the
    way TeX works (more precisely, I have thought long and hard about
    this and have not been able to figure out a sensible way to avoid
    this). For this reason, TikZ switches off horizontal badness
    warnings inside boxes with align=center. Since this will also
    suppress some "wanted" warnings, there is also an option for
    switching the warnings on once more:

align=flush center

    Works like flush left or flush right, only for center alignment.
    Because of all the trouble that results from the center option in
    conjunction with narrow lines, I suggest picking this option rather
    than center unless you have longer text, in which case center will
    give the typographically better results.

        \tikz \node[fill=yellow!80!black,text width=3cm,align=flush center]
          {This is a demonstration text for showing how line breaking works.};

align=justify

    For alignment without line breaking, this has the same effect as
    left. For alignment with line breaking, this causes the text to be
    "justified". Use this only with rather broad nodes.

        \tikz \node[fill=yellow!80!black,text width=3cm,align=justify]
          {This is a demonstration text for showing how line breaking works.};

    In the above example, TeX complains (rightfully) about three very
    badly typeset lines. (For this manual I asked TeX to stop
    complaining by using \hbadness=10000, but this is a foul deed,
    indeed.)

align=none

    Disables all alignments and \\ will not be redefined.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/align",
         meta = "⟨alignment option⟩"
      },
      ["allow upside down"] = {
         details = [[
If set to true, TikZ will not "righten" upside down text.

    \tikz [allow upside down]
      \draw (0,0) .. controls +(up:2cm) and +(left:2cm) .. (1,3)
        node foreach \p in {0,0.25,...,1} [sloped,above,pos=\p]{\p};

    \begin{tikzpicture}[->,allow upside down]
      \draw (0,0)   -- (2,0.5) node[midway,sloped,above] {$x$};
      \draw (2,-.5) -- (0,0)   node[midway,sloped,below] {$y$};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/allow:upside:down",
         meta = "⟨boolean⟩"
      },
      ["ampersand replacement"] = {
         details = [[
If a macro name is provided, this macro will be defined to be equal to
\pgfmatrixnextcell inside matrices and &  will not be made active. For
instance, you could say ampersand replacement=\&  and then use \&  to
separate columns as in the following example:

    \tikz
      \matrix [ampersand replacement=\&]
      {
        \draw (0,0)   circle (4mm); \& \node[rotate=10] {Hello};        \\
        \draw (0.2,0) circle (2mm); \& \fill[red]   (0,0) circle (3mm); \\
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/ampersand:replacement",
         meta = "⟨macro name or empty⟩"
      },
      anchor = {
         details = [[
Specifies an anchor of the node. Here is an example:

    \begin{tikzpicture}
      \node (shape)   at (0,2)  [draw] {|class Shape|};
      \node (rect)    at (-2,0) [draw] {|class Rectangle|};
      \node (circle)  at (2,0)  [draw] {|class Circle|};
      \node (ellipse) at (6,0)  [draw] {|class Ellipse|};

      \draw (node cs:name=circle,anchor=north) |- (0,1);
      \draw (node cs:name=ellipse,anchor=north) |- (0,1);
      \draw [arrows = -{Triangle[open, angle=60:3mm]}]
               (node cs:name=rect,anchor=north)
            |- (0,1) -| (node cs:name=shape,anchor=south);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/anchor",
         meta = "⟨anchor⟩"
      },
      ["and gate"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/and:gate"
      },
      ["angle eccentricity"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/angle:eccentricity",
         meta = "⟨factor⟩"
      },
      ["angle radius"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/angle:radius",
         meta = "⟨dimension⟩"
      },
      animate = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate",
         meta = "⟨animation specification⟩"
      },
      ["animate/arrows"] = {
         details = [[
This key only has an effect on :path animations. It causes the arrow
tips specified in ⟨arrow spec⟩ to be added to the path during the
animation (the syntax is the same as for the normal arrows key). If you
have several different animations for a paths, these may contain
different arrow tips, but each animation must stick to one kind of arrow
tips.

What happens internally when this key is used is the following: The
specified arrow tips are rendered internally as so-called markers, which
are small graphics that can be placed at the beginning and ends of paths
and which "rotate along" as a path changes. Note that these markers are
used only in the context of animated paths, the arrow tips of normal,
"static" paths are drawn without the use of markers. Normally, there is
no visual difference between an arrow tip drawn using markers or those
drawn for static paths, but in rare cases there may be differences. You
should only add arrows to open path consisting of a single segment with
sufficiently long first and last segments (so that TikZ can shorten
these segments correctly when necessary).

As pointed out earlier, the only way to add arrow tips to a path that is
animated is using this key, you can not say something like

    \draw :path = { 1s = "{(0,0) -- (1,0)}", 2s = "{(0,1) -- (1,0)}" }
      [->] (0,0) -- (1,0);

This will raise an error since you try to animate a path (:path = ...)
that has normal arrow tips attached ([->]).

Instead, you must specify the arrow tips inside the animation command:

    \draw :path = { 1s = "{(0,0) -- (1,0)}", 2s = "{(0,1) -- (1,0)}", arrows = -> }
      (0,0) -- (1,0);

However, the above code now has a big shortcoming: While the animation
is not running, no arrow tip is shown (the arrows key only applies to
the animation.

The trick is to use the base key. It allows you to install a path as the
"base" path that is used when no animation is running and the arrows
specified for the animation will also be used for the base. All told,
the "correct" way to specify the animation is the following (note that
no static path is specified, any specified path would be overruled by
the base path anyway):

    \draw :path = { 1s = "{(0,0) -- (1,0)}" base, 2s = "{(0,1) -- (1,0)}", arrows = -> };

Here is an example:

    \tikz [very thick] {
      \node (node) at (-2,0)
        [fill = blue!20, draw = blue, very thick, circle] {Click me!};
      \draw :path = {
        0s = "{(0,0) to[out=90, in=180] (.5,1) to[out=0, in=90] (.5,.5)}" base,
        2s = "{(1,0) to[out=180, in=180] (.25,.5) to[out=0, in=180] (1,.5)}",
        arrows = <.<->, begin on = {click, of=node} }; }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/arrows",
         meta = "⟨arrow spec⟩"
      },
      ["animate/attribute"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/attribute",
         meta = "⟨list of attributes⟩"
      },
      ["animate/base"] = {
         details = [[
A "base" value is a value that is used for the attribute whenever the
timeline is not active:

    \tikz \node [fill = green, text = white] :fill =
        { 1s = "red", 2s = "blue", base = "orange", begin on = click }
      {Click me};

Syntactically, the base key works much like special time syntax: It sets
up a local sync scope and executes the ⟨options⟩ in it and creates an
entry. However, instead of setting the time attribute to a time, it sets
it to a special value that tells TikZ that when the entry is created,
the current ⟨value⟩ should be used as the base value.

This means that you can write base = "orange" as in the above example to
set the base. However, you can also use the base key in other ways; most
noticeably, you can use it after some value:

    \tikz \node [fill = green, text = white] :fill =
        { 1s = {"red" = base}, 2s = "blue", begin on = click }
      {Click me};

Instead of using base as a key, you can also add base directly after the
quotes of a value. This is particularly useful for setting up a base
value that is also used in a timeline:

    \tikz \node [fill = green, text = white] :fill =
        { 1s = "red" base, 2s = "blue", begin on = click }
      {Click me};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/base",
         meta = "⟨options⟩"
      },
      ["animate/entry"] = {
         details = [[
Each time this key is used in the options of animate, TikZ checks
whether the five keys object, attribute, id, time, and value are set. If
one of them is not set, nothing happens. (The id key is set to the value
default by default, all other keys must be set explicitly.)

If all of these keys are set, a time--value pair is created and added to
the timeline of attribute of the object. Additionally, all options
starting with /tikz/animate/options/, which also influence the timeline
like begin on, are also added to the timeline of the object--attribute
pair.

    \tikz [animate = {
      object = node, attribute = fill, time = 0s, value = red, entry,
      object = node, attribute = fill, time = 2s, value = blue, entry,
      object = node, attribute = fill, begin on = click, entry}]
      \node (node) [fill, text=white] { Click me };

In the above example, it would not have been necessary the specify the
object and the attribute in each line, they retain their values unless
they are overwritten. Thus, we could also have written:

    \tikz [animate = {
      object = node, attribute = fill, time = 0s, value = red, entry,
                                       time = 2s, value = blue, entry,
                                       begin on = click, entry}]
      \node (node) [fill, text=white] { Click me };

Note, however, that in both examples we actually add the time--value
pair $(2\mathrm{s}, \mathrm{blue})$ twice since the time and value keys
also retain their settings and, thus, for the third entry they have the
same values as before and a new pair is added. While this superfluous
pair is not a problem in the example (it has no visual effect), we will
see later on how such pairs can be avoided by using the scope key.

A sequence of calls of entry can freely switch between objects and
attributes (that is, between timelines), but the times for any given
timeline must be given in non-decreasing order:

    \tikz [animate = {
      object = node,  attribute = fill, time = 0s, value = red, entry,
      object = node2, attribute = draw, entry,
      object = node,  attribute = fill, time = 2s, value = blue, entry,
      object = node2, attribute = draw, entry,
      object = node,  attribute = fill, begin on = click, entry,
      object = node2, attribute = draw, begin on = click, entry}] {
      \node (node)  [fill, text=white]            { Node 1 };
      \node (node2) [draw, ultra thick] at (0,-1) { Node 2 };
    }

In the above example, we could not have exchanged the first two lines of
the animate options with the third and fourth line since the values for
time 0s must come before the values for time 2s.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/entry"
      },
      ["animate/fork"] = {
         details = [[
Sets the fork time for the local scope to ⟨t⟩ and sets the current time
to 0s. In this scope, when you use "absolute" times like 0s or 2s, you
actually refer to later times that have started as ⟨t⟩.

One application of forks is in the definition of keys that add a certain
part to a longer animation. Consider for instance the definition of a
highlight key:

    \tikz [animate/highlight/.style = {
        scope = { fork = #1,
                  :fill = { 0s = "black", 0.1s = "white", 0.2s = "black"} }
      }]
      \node [animate = { myself: = {
                :fill = { 0s = "black", begin on = click },
                          highlight = 1s, highlight = 2s } },
             fill = blue, text=white, very thick, circle] { Click me };

In the above example, we could also have written 0.1s later instead of
0.2s and, indeed, the whole style could have been defined using only
times with later, eliminating the need for the fork key. However, using
forks you can specify absolute times for things happening in a
conceptual "subprocess" and also relative times. The name fork for the
key is also borrowed from operating system theory, where a "fork" is the
spawning of an independent process.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/fork",
         meta = "⟨t⟩"
      },
      ["animate/id"] = {
         details = [[
Timelines are use to defined how the values of an attribute of an object
change over time. In many cases, you will have at most one timeline for
each object--attribute pair, but, sometimes, you may wish to have more
than one timeline for the same object and the same attribute. For
instance, you might have a timeline that specifies a changing shift of a
node in some direction and, at the same time, another timeline that
specifies an additional shift in some other direction(s). The problem is
that there is only one shift attribute and it would be difficult to
compute the joint effect of the two timelines.

For this purpose, timelines are actually identified not only by the
object--attribute pair but, in reality, by the triple consisting of the
object, the attribute, and the value of this key. We can now specify two
separate timelines:

    \tikz [animate = {
      id = 1, n:shift = { 0s = "{(0,0)}", 2s = "{(0,5mm)}", begin on = click },
      id = 2, n:shift = { 0s = "{(0,0)}", 2s = "{(5mm,0)}", begin on = click }
    }]
      \node (n) [fill = blue!20, draw=blue, very thick] {The node};

The default value of id is default.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/id",
         meta = "⟨id⟩"
      },
      ["animate/object"] = {
         details = [[
The ⟨list of objects⟩ is a comma-separated list of strings of the form
⟨object⟩.⟨type⟩. All of the objects in the list are selected as
to-be-animate object for the next use of the entry key. The objects
referred to by ⟨object⟩ will be the next objects with the name key set
to ⟨object⟩. You can apply the name key to nodes (where you can also use
the special parentheses-syntax and put the name in parentheses, it has
the same effect), but also to scopes and paths. (The name path key is
not the same as name; it is an older key from the intersections package
and not related.)

    \tikz [animate = { object = b, :fill = {0s = "red", 2s = "blue",
                                            begin on = click }}] {
      \node (a) [fill, text = white, minimum width=1.5cm] at (0,1cm) {a};
      \node (b) [fill, text = white, minimum width=1.5cm] at (0,5mm) {b};
      \node (c) [fill, text = white, minimum width=1.5cm] at (0,0mm) {c}; }

    \tikz [animate = { object = b, :fill = {0s = "red", 2s = "blue",
                                            begin on = click },
                       object = c, :fill = {0s = "green", 2s = "blue",
                                            begin on = click } }] {
      \scoped [name = a, yshift=1cm] \fill (0,0) rectangle (1.5cm,2mm);
      \scoped [name = b, yshift=5mm] \fill (0,0) rectangle (1.5cm,2mm);
      \scoped [name = c, yshift=0mm] \fill (0,0) rectangle (1.5cm,2mm); }

If the ⟨object⟩ name is never used later in the file, no animation is
created.

The ⟨object⟩ may also be the special text myself. In this case, the
referenced object is the scope or object to which the animate key is
given. If an object is named myself (as in \node (myself) ...), you
cannot reference this node using the object key, myself always refers to
the object where the animate key is given (of course, you can animate
the node named myself by placing the animate key inside the options of
this node; you only cannot "remotely" add an animation to it).

The ⟨object⟩ may be followed by a dot and a type. This is need in rare
cases where you want to animate only a special "part" of an object that
is not accessible in other ways. Normally, TikZ takes care of choosing
these types automatically, you only need to set these "if you know what
you are doing".
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/object",
         meta = "⟨list of objects⟩"
      },
      ["animate/options/along"] = {
         details = [[
Use this key with a :shift (or a :position) to make TikZ shift the
object by the coordinates along the ⟨path⟩. When this key is used, the
values may no longer be coordinates, but must be fractions of the
distance along the path. A value of "0" refers to the beginning of the
path and "1" refers to the end:

    \tikz {
      \draw [help lines] (-0.2,-0.2) grid (2.2,1.2);
      \draw (1,.5) circle [radius=1mm];
      \node :shift = {
                along = {(0,0) circle[radius=5mm]} upright,
                0s="0", 2s=".25", begin on=click }
        at (1,.5) [fill = blue, opacity=.5, circle] {Click};
    }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/along",
         meta = "{path}⟨sloped or upright⟩ in⟨time⟩"
      },
      ["animate/options/begin"] = {
         details = [[
This key specifies when the "moment 0s" should be relative to the moment
when the current graphic is first displayed. You can use this key
multiple times, in this case the timeline is restarted for each of the
times specified (if it is already running, it will be reset). If no
begin key is given at all, the effect is the same as if begin=0s had
been specified.

It is permissible to set ⟨time⟩ to a negative value.

Note that this key has no effect for snapshots.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/begin",
         meta = "⟨time⟩"
      },
      ["animate/options/begin on"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/begin:on",
         meta = "⟨options⟩"
      },
      ["animate/options/begin snapshot"] = {
         details = [[
Use this key on a timeline to specify that, only for purposes of taking
snapshots, the timeline starts at ⟨start time⟩ rather than at "moment
zero". (Think of this as saying that the animation starts when a virtual
user clicks on the animation and this click occurs ⟨start time⟩ seconds
after the general "moment zero", causing the animation to "lag behind"
by this amount of time.) Computationally, for the timeline the ⟨start
time⟩ is subtracted from the snapshot's ⟨time⟩ when the value needs to
be determined:

    \tikz [make snapshot of = 1s] {
      \fill :fill = { 0s = "black", 2s = "white",
                      begin snapshot = 1s }        (0,0) rectangle ++(1,1);
      \fill :fill = { 1s = "black", 3s = "white" } (2,0) rectangle ++(1,1);
    }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/begin:snapshot",
         meta = "⟨start time⟩"
      },
      ["animate/options/ease"] = {
         details = [[
A shorthand for ease in=⟨fraction⟩, ease out=⟨fraction⟩.

Note that since for the first time the entry control is ignored and,
similarly, for the last time the exit control is ignored, using the ease
key with an animation having only two times is particularly easy, since
we only need to set ease once:

    \tikz {
      \foreach \i in {0,0.125,...,1} \draw (-0.9,.9-\i) -- ++(1.8,0);
      \node :yshift = { begin on = click, ease, 0s = "0cm", 2s = "-10mm" }
        [fill = blue!20, draw = blue, very thick, circle] {Click me!};
    }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/ease",
         meta = "{fraction}"
      },
      ["animate/options/ease in"] = {
         details = [[
A shorthand for entry control={1-⟨fraction⟩}{1}.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/ease:in",
         meta = "{fraction}"
      },
      ["animate/options/ease out"] = {
         details = [[
A shorthand for exit control={⟨fraction⟩}{1}.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/ease:out",
         meta = "{fraction}"
      },
      ["animate/options/end"] = {
         details = [[
This key will truncate the timeline so that it ends ⟨time⟩ after the
display of the graphic, provided the timeline begins before the
specified end time. For instance, if you specify a timeline starting at
2 s and ending at 5 s and you set begin to 1 s and end to 4 s, the
timeline will run, relative to the moment when the graphic is displayed
from 3 s to 4 s.

    \tikz \node [fill = green!50!black, text = white]
        :rotate = { 1s = "0", 5s = "90", begin = 2s, end = 4s }
      {Click me};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/end",
         meta = "⟨time⟩"
      },
      ["animate/options/end on"] = {
         details = [[
Works exactly like begin on, one possible end of the timeline is
specified using the ⟨options⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/end:on",
         meta = "⟨options⟩"
      },
      ["animate/options/entry control"] = {
         details = [[
Works like exit control.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/entry:control",
         meta = "{time fraction}{value fraction}"
      },
      ["animate/options/exit control"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/exit:control",
         meta = "{time fraction}{value fraction}"
      },
      ["animate/options/forever"] = {
         details = [[
This key causes the timeline to continue "forever" after the last time
with the last value. You can also think of this as having the animation
"freeze" at the end.

    \tikz \node :fill = { 1s="red", 2s="blue", forever, begin on=click}
      [fill = green!50!black, text = white] {Click me};

    \tikz \node [fill = green!50!black, text = white]
        :fill = { 1s = "red", 2s = "blue", begin on = click }
      {Click me};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/forever"
      },
      ["animate/options/freeze"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/freeze"
      },
      ["animate/options/jump"] = {
         details = [[
Works like the stay key, but will cause the value to "jump to" the new
value right at the beginning of the time interval. It is similar to an
entry control specifying a "flat" curve.

    \tikz {
      \foreach \i in {0,0.125,...,1} \draw (-0.9,.9-\i) -- ++(1.8,0);
      \node :yshift = { begin on = click,
                        0s = "0cm",
                        1s = {jump, "-5mm"},
                        2s = "-10mm" }
        [fill = blue!20, draw = blue, very thick, circle] {Click me!};
    }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/jump"
      },
      ["animate/options/origin"] = {
         details = [[
Shifts the animation coordinate system by ⟨coordinate⟩. This has the
effect that the "origin" for scalings and rotations gets shifted by this
amount. In the following example, the point around which the rotation is
done is the right border at (2,1) since the origin of the animation is
at (1,1) relative to the picture's origin and the origin key shifts it
one centimeter to the right.

    \tikz {
      \draw [help lines] (-0.2,-0.2) grid (2.2,2.2);
      \node :rotate = { 0s="0", 2s="45", begin on=click,
                        origin = {(1,0)}}
        at (1,1) [fill = blue!20, draw = blue, ultra thick] {Click me};
    }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/origin",
         meta = "⟨coordinate⟩"
      },
      ["animate/options/repeat"] = {
         details = [[
An alias for repeats.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/repeat",
         meta = "⟨specification⟩"
      },
      ["animate/options/repeats"] = {
         details = [[
Use this key to specify that the timeline animation should repeat at the
end. The ⟨specification⟩ must consist of two parts, each of which may be
empty. The first part is one of the following:

-   Empty, in which case the timeline repeats forever.

        \tikz \node :rotate = { 0s = "0", 2s = "90",
                                repeats, begin on = click }
            [fill = blue!20, draw = blue, ultra thick, circle] {Click me!};

-   A ⟨number⟩ (like 2 or 3.25), in which case the timeline repeats
    ⟨number⟩ times.

        \tikz \node :rotate = { 0s = "0", 2s = "90",
                                repeats = 1.75, begin on = click }
            [fill = blue!20, draw = blue, ultra thick, circle] {Click me!};

-   The text "for ⟨time⟩" (like for 2s or for 300ms), in which case the
    timeline repeats however often necessary so that it stops exactly
    after ⟨time⟩.

        \tikz \node :rotate = { 0s = "0", 2s = "90",
                                repeats = for 3.5s, begin on = click }
            [fill = blue!20, draw = blue, ultra thick, circle] {Click me!};

The second part of the specification must be one of the following:

-   Empty, in which case each time the timeline is restarted, the
    attribute's value undergoes the same series of values it did
    previously.

-   The text accumulating. This has the effect that each time the
    timeline is restarted, the last values specified by the timeline is
    added to the value from the previous iteration(s). A typical example
    is an animation that shifts a scope by, say, 1 cm over a time of
    1 s. Now, if you repeat this five times, normally the scope will
    shift 1 cm for 1 s then "jump back", shift again, jump back, and so
    on for five times. In contrast, when the repeats are accumulating,
    the scope will move by 5 cm over 5 s in total.

        \tikz \node :rotate = { 0s = "0", 2s = "90", begin on = click,
                                repeats = accumulating }
            [fill = blue!20, draw = blue, ultra thick, circle] {Click me!};

        \tikz \node :rotate = { 0s = "0", 2s = "90", begin on = click,
                                repeats = for 4s accumulating }
            [fill = blue!20, draw = blue, ultra thick, circle] {Click me!};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/repeats",
         meta = "⟨specification⟩"
      },
      ["animate/options/restart"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/restart",
         meta = "⟨choice⟩"
      },
      ["animate/options/stay"] = {
         details = [[
Specifies that inside the time interval the value "stays put" at the
first value till the end of the interval, where it will jump to the
second value. This is similar to an exit control where the curve is
"infinitely flat".

    \tikz {
      \foreach \i in {0,0.125,...,1} \draw (-0.9,.9-\i) -- ++(1.8,0);
      \node :yshift = { begin on = click,
                        0s = "0cm",
                        1s = {stay, "-5mm"},
                        2s = "-10mm" }
        [fill = blue!20, draw = blue, very thick, circle] {Click me!};
    }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/stay"
      },
      ["animate/options/transform"] = {
         details = [[
While the origin key does only a shift, the transform key allows you to
add an arbitrary transformation to the animation coordinate system using
keys like shift, rotate or even reset cm and cm. In particular,
origin=⟨c⟩ has the same effect as transform = {shift=⟨c⟩}. Note that the
transformation only influences the animation, not the object itself.

As an example, when you say transform={scale=2}, an :xshift with a value
of "1cm" will actually shift the object by 2cm. Similarly, after you say
transform={rotate=90,scale=2}, the same :xshift of "1cm" will actually
shift the object by 2cm upwards.

Note that, internally, TikZ has to invert the transformation matrix
resulting from the ⟨transformation keys⟩ (plus the original animation
transformation matrix), which can by numerically instable when you use
ill-conditioned transformations.

    \tikz {
      \draw [help lines] (-0.2,-0.2) grid (2.2,2.2);
      \node :xshift = { 0s="0cm", 2s="5mm", begin on=click,
                        transform = {rotate=-90} }
        at (1,1) [fill = blue!20, draw = blue, ultra thick] {Click me};
    }

    \tikz {
      \draw [help lines] (-0.2,-0.2) grid (2.2,2.2);
      \node :xshift = { 0s="0cm", 2s="5mm", begin on=click,
                        transform = {rotate=-45, scale=2} }
        at (1,1) [fill = blue!20, draw = blue, ultra thick] {Click me};
    }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/options/transform",
         meta = "⟨transformation keys⟩"
      },
      ["animate/remember"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/remember",
         meta = "⟨macroname⟩"
      },
      ["animate/resume"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/resume",
         meta = "⟨absolute time⟩"
      },
      ["animate/scope"] = {
         details = [[
Executed the ⟨options⟩ inside a TeX scope. In particular, all settings
made inside the scope have no effect after the end of the scope.

    \tikz \node [animate = { myself: = { begin on = click,
        scope = { attribute = fill, repeats = 3, 0s = "red", 2s = "red!50" },
        scope = { attribute = draw,              0s = "red", 2s = "red!50" }
      }},
      fill=blue!20, draw=blue, very thick, circle] {Click me};

Without the use of the scope key, the repeats key would also affect the
draw attribute.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/scope",
         meta = "⟨options⟩"
      },
      ["animate/shorten < "] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/shorten:<:",
         meta = " ⟨dimension⟩"
      },
      ["animate/shorten > "] = {
         details = [[
For animated paths, just as the key arrows has to be passed to the
animation (to :path) instead of to the static path, the keys shorten >
and shorten < also have to be passed to the :path key.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/shorten:>:",
         meta = " ⟨dimension⟩"
      },
      ["animate/sync"] = {
         details = [[
A shorthand for scope={ ⟨options⟩ , remember=\temp},resume=\temp where
\temp is actually an internal name. The effect is that after a sync the
local time just continues as if the scope where not present -- but
regarding everything else the effects are local to the sync scope.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/sync",
         meta = "⟨options⟩"
      },
      ["animate/time"] = {
         details = [[
Sets the time for the next time--value pair in a call of entry to ⟨time⟩
plus the current fork time. The text later is optional. Both "fork
times" and the optional later will be explained in a moment.

Time Parsing. The ⟨time⟩ is parsed using the command \pgfparsetime,
which is essentially the same as the usual math parser of TikZ, and the
result is interpreted as a time in seconds. Thus, a ⟨time⟩ of 2+3 means
"5 seconds" and a ⟨time⟩ of 2*(2.1) means "4.2 seconds". (You could even
specify silly times like 1in, which results in the time "72.27 seconds".
Please do not do that.) The "essentially" refers to the fact that some
extras are installed when the time parser is running:

-   The postfix operator s is added, which has no effect. Thus, when you
    write 5s you get the same results as 5, which is exactly 5 seconds
    as desired.

-   The postfix operator ms is added, which divides a number by 1000, so
    2ms equals 0.002s.

-   The postfix operator min is added, which multiplies a number by 60.

-   The postfix operator h is added, which multiplies a number by 3600.

-   The infix operator : is redefined, so that it multiplies its first
    argument by 60 and adds the second. This implies that 1:20 equals
    80s and 01:00:00 equals 3600s.

-   The parsing of octal numbers is switched off to allow things like
    01:08 for 68s.

Note that you cannot use the colon syntax for times in things like
01:20 = "0" would (falsely) be interpreted as: "For the object named 01
and its attribute named 20, do something." You can, however, use 01:20
in arguments to the time key, meaning that you would have to write
instead: time = 1:20, "0", possibly surround by a scope.

Relative Times. You can suffix a time key with "later". In this case,
the ⟨time⟩ is interpreted as an offset to the time in the previous use
of the time key:

    \tikz \node :fill = { begin on = click,
        0s = "white",
        500ms later = "red",
        500ms later = "green",  % same as 1s   = "-5mm"
        500ms later = "blue"} % same as 1.5s = "-2.5mm"
      [fill=blue!20, draw=blue, very thick, circle] {Click me};

In reality, the offset is not taken to just any previous use of the time
key, but to the most recent use of this key or of the resume key in the
current local TeX scope. Here is an example:

    time = 2s,
    time = 1s later,    % same as time = 3s
    time = 500ms later, % same as time = 3.5s
    time = 4s,
    time = 1s later,    % same as time = 5s
    scope = {           % opens a local scope
      time = 1s later,  % same as time = 6s
      time = 10s
      time = 1s later   % same as time = 11s
    },                  % closes the scope, most recent time is 5s once more
    time = 2s later     % same as time = 7s

Fork Times. The time meant by the value ⟨time⟩ passed to the time key is
not used directly. Rather, TikZ adds the current fork time to it, which
is 0s by default. You can change the fork time using the following key:

Remembering and Resuming Times. When you have a complicated animation
with a long timeline, you will sometimes wish to start some animation
when some other animation has reached a certain moment; but this moment
is only reached through heavy use of later times and/or forks. In such
situations, the following keys are useful:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/time",
         meta = "⟨time⟩later"
      },
      ["animate/value"] = {
         details = [[
This key sets the value of the next time--value pair created by entry to
⟨value⟩. The syntax of the ⟨value⟩ is not fixed, it depends on the type
of the attribute. For instance, for an attribute like opacity the
⟨value⟩ must be an expression that can be evaluated to a number between
0 and 1; for the attribute color the ⟨value⟩ must, instead, be a color;
and so on. Take care that when a value contains a comma, you must
surround it by braces as in "{(1,1)}".

The allowed texts for the ⟨value⟩ is always the same as the one you
would pass to the TikZ option of the same name. For instance, since the
TikZ option shift expects a coordinate, you use coordinates as ⟨value⟩
with the usual TikZ syntax (including all sorts of extensions, the
animation system calls the standard TikZ parsing routines). The same is
true of dimensions, scalar values, colors, and so on.

In addition to the values normally use for setting the attribute, you
can also (sometimes) use the special text current value as ⟨value⟩. This
means that the value of the point in the timeline should be whatever the
value the attribute has at the beginning of the timeline. For instance,
when you write

    animate = { obj:color = { 0s = "current value", 2s = "white" } }

the color of obj will change from whatever color it currently has to
white in two seconds. This is especially useful when several animations
are triggered by user events and the current color of obj cannot be
determined beforehand.

There are several limitations on the use of the text current value,
which had to be imposed partly because of the limited support of this
feature in SVG:

-   You can use current value only with the first time in a timeline.

-   You can only have two times in a timeline that starts with
    current value.

-   You cannot use current value for timelines of which you wish to take
    a snapshot.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animate/value",
         meta = "⟨value⟩"
      },
      ["animations/base"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animations/base",
         meta = "⟨value⟩"
      },
      ["animations/begin snapshot"] = {
         details = [[
When this key is used inside the options of \pgfanimateattribute, with
respect to snapshots, the timeline begins at ⟨begin time⟩. This means
that, if the snapshot time is set to ⟨time⟩ and the beginning of the
snapshot's timeline is set to ⟨begin time⟩, the attribute is set to the
value of the timeline at time $⟨time⟩ -
        ⟨begin time⟩$.

The idea is that when you make a snapshot of several animations and all
of them have started at different times because of different events, you
use begin snapshot with each object and attribute to directly specify
when these different events have happened.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/animations/begin:snapshot",
         meta = "⟨begin time⟩"
      },
      annotation = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/annotation"
      },
      ["annotation arrow"] = {
         details = [[
This style should set the default > arrow to some nice value.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/annotation:arrow"
      },
      ["append after command"] = {
         details = [[
Some of the path commands described in the following sections take
optional arguments. For these commands, when you use this key inside
these options, the ⟨path⟩ will be inserted after the path command is
done. For instance, when you give this command in the option list of a
node, the ⟨path⟩ will be added after the node. This is used by, for
instance, the label option to allow you to specify a label in the option
list of a node, but have this label cause a node to be added after
another node.

    \tikz \draw node [append after command={(foo)--(1,1)},draw] (foo){foo};

If this key is called multiple times, the effects accumulate, that is,
all of the paths are added in the order to keys were found.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/append:after:command",
         meta = "⟨path⟩"
      },
      arrows = {
         details = [[
This option sets the arrow tip(s) to be used at the start and end of
lines. An empty value as in -> for the start indicates that no arrow tip
should be drawn at the start.

Note: Since the arrow option is so often used, you can leave out the
text arrows=. What happens is that every (otherwise unknown) option that
contains a - is interpreted as an arrow specification.

    \begin{tikzpicture}
      \draw[->]        (0,0)   -- (1,0);
      \draw[>-Stealth] (0,0.3) -- (1,0.3);
    \end{tikzpicture}

In the above example, the first start specification is empty and the
second is >. The end specifications are > for the first line and Stealth
for the second line. Note that it makes a difference whether > is used
in a start specification or in an end specification: In an end
specification it creates, as one would expect, a pointed tip at the end
of the line. In the start specification, however, it creates a
"reversed" version if this arrow -- which happens to be what one would
expect here.

The above specifications are very simple and only select a single arrow
tip without any special configuration options, resulting in the
"natural" versions of these arrow tips. It is also possible to
"configure" arrow tips in many different ways, as explained in detail in
Section ?? below by adding options in square brackets following the
arrow tip kind:

    \begin{tikzpicture}
      \draw[-{Stealth[red]}] (0,0)   -- (1,0);
    \end{tikzpicture}

Note that in the example I had to surround the end specification by
braces. This is necessary so that TikZ does not mistake the closing
square bracket of the Stealth arrow tip's options for the end of the
options of the \draw command. In general, you often need to add braces
when specifying arrow tips except for simple case like -> or <<->, which
are pretty frequent, though. When in doubt, say arrows={⟨start
spec⟩-⟨end spec⟩}, that will always work.

It is also possible to specify multiple (different) arrow tips in a row
inside a specification, see Section ?? below for details.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/arrows",
         meta = "⟨start arrow specification⟩-⟨end arrow specification⟩"
      },
      at = {
         details = [[
If this option is explicitly set inside the ⟨options⟩ (or indirectly via
the every circle style), the ⟨coordinate⟩ is used as the center of the
circle instead of the current point. Setting at to some value in an
enclosing scope has no effect.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/at",
         meta = "⟨coordinate⟩"
      },
      ["at end"] = {
         details = [[
Set to pos=1.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/at:end"
      },
      ["at start"] = {
         details = [[
Set to pos=0.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/at:start"
      },
      attribute = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/attribute"
      },
      auto = {
         details = [[
This option causes an anchor position to be calculated automatically
according to the following rule. Consider a line between two points. If
the ⟨direction⟩ is left, then the anchor is chosen such that the node is
to the left of this line. If the ⟨direction⟩ is right, then the node is
to the right of this line. Leaving out ⟨direction⟩ causes automatic
placement to be enabled with the last value of left or right used. A
⟨direction⟩ of false disables automatic placement. This happens also
whenever an anchor is given explicitly by the anchor option or by one of
the above, below, etc. options.

This option only has an effect for nodes that are placed on lines or
curves.

    \begin{tikzpicture}
      [scale=.8,auto=left,every node/.style={circle,fill=blue!20}]
      \node (a) at (-1,-2) {a};
      \node (b) at ( 1,-2) {b};
      \node (c) at ( 2,-1) {c};
      \node (d) at ( 2, 1) {d};
      \node (e) at ( 1, 2) {e};
      \node (f) at (-1, 2) {f};
      \node (g) at (-2, 1) {g};
      \node (h) at (-2,-1) {h};

      \foreach \from/\to in {a/b,b/c,c/d,d/e,e/f,f/g,g/h,h/a}
        \draw [->] (\from) -- (\to)
                   node[midway,fill=red!20] {\from--\to};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/auto",
         meta = "⟨direction⟩"
      },
      ["background grid"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/background:grid"
      },
      ["background rectangle"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/background:rectangle"
      },
      ["background top"] = {
         details = [[
    \tikzset{background rectangle/.style={fill=blue!20},
             background top/.style={draw=blue!50,line width=1ex}}
    \begin{tikzpicture}[framed,show background top]
      \draw (0,0) ellipse (10mm and 5mm);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/background:top"
      },
      ["badness warnings for centered text"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/badness:warnings:for:centered:text",
         meta = "⟨true or false⟩"
      },
      ["ball color"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/ball:color",
         meta = "⟨color⟩"
      },
      ["base left"] = {
         details = [[
This key works like the left key, only instead of the east anchor, the
base east anchor is used and, when the second form of an ⟨of-part⟩ is
used, the corresponding base west anchor.

This key is useful for chaining together nodes so that their base lines
are aligned.

    \begin{tikzpicture}[node distance=1ex]
      \draw[help lines] (0,0) grid (3,1);
      \huge
      \node (X) at (0,1)     {X};
      \node (a) [right=of X] {a};
      \node (y) [right=of a] {y};

      \node (X) at (0,0)          {X};
      \node (a) [base right=of X] {a};
      \node (y) [base right=of a] {y};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/base:left",
         meta = "⟨specification⟩"
      },
      ["base right"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/base:right",
         meta = "⟨specification⟩"
      },
      baseline = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/baseline",
         meta = "⟨dimension or coordinate or default⟩"
      },
      ["behind path"] = {
         details = [[
When this key is set, either as a local option for the node or some
surrounding scope, the node will be drawn behind the current path. For
this, TikZ collects all nodes defined on the current path with this
option set and then inserts all of them, in the order they appear, just
before it draws the path. Thus, several nodes with this option set may
obscure one another, but never the path itself. "Just before it draws
the path" actually means that the nodes are inserted into the page
output just before any pre-actions are applied to the path (see below
for what pre-actions are).

    \tikz \fill [fill=blue!50, draw=blue, very thick]
          (0,0)   node [behind path, fill=red!50]   {first node}
       -- (1.5,0) node [behind path, fill=green!50] {second node}
       -- (1.5,1) node [behind path, fill=brown!50] {third node}
       -- (0,1)   node [             fill=blue!30]  {fourth node};

Note that behind path only applies to the current path; not to the
current scope or picture. To put a node "behind everything" you need to
use layers and options like on background layer, see the backgrounds
library in Section ??.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/behind:path"
      },
      below = {
         details = [[
This key is redefined in the same manner as above.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/below",
         meta = "⟨specification⟩"
      },
      ["below delimiter"] = {
         details = [[
Works as above.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/below:delimiter",
         meta = "⟨delimiter⟩"
      },
      ["below left"] = {
         details = [[
Similar to above left.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/below:left"
      },
      ["below left of"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/below:left:of",
         meta = "⟨node⟩"
      },
      ["below of"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/below:of",
         meta = "⟨node⟩"
      },
      ["below right"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/below:right",
         meta = "⟨specification⟩"
      },
      ["below right of"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/below:right:of",
         meta = "⟨node⟩"
      },
      bend = {
         details = [[
Has the same effect as saying bend⟨coordinate⟩ outside the ⟨options⟩.
The option specifies that the bend of the parabola should be at the
given ⟨coordinate⟩. You have to take care yourself that the bend
position is a "valid" position; which means that if there is no parabola
of the form $f(x) = a x^2 + b x + c$ that goes through the old current
point, the given bend, and the new current point, the result will not be
a parabola.

There is one special property of the ⟨coordinate⟩: When a relative
coordinate is given like +(0,0), the position relative to this
coordinate is "flexible". More precisely, this position lies somewhere
on a line from the old current point to the new current point. The exact
position depends on the next option.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/bend",
         meta = "⟨coordinate⟩"
      },
      ["bend angle"] = {
         details = [[
Sets the angle to be used by the bend left or bend right, but without
actually selecting the curve to or the relative option. This is useful
for globally specifying a bend angle for a whole picture.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/bend:angle",
         meta = "⟨angle⟩"
      },
      ["bend at end"] = {
         details = [[
This places the bend at the end of a parabola.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/bend:at:end"
      },
      ["bend at start"] = {
         details = [[
This places the bend at the start of a parabola. It is a shortcut for
the following options: bend pos=0,bend={+(0,0)}.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/bend:at:start"
      },
      ["bend left"] = {
         details = [[
This option sets out=⟨angle⟩,in=$180-⟨angle⟩$,relative. If no ⟨angle⟩ is
given, the last given bend left or bend right angle is used.

    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid]
      \node[state,initial]  (q_0)                {$q_0$};
      \node[state]          (q_1) [right=of q_0] {$q_1$};
      \node[state,accepting](q_2) [right=of q_1] {$q_2$};

      \path[->] (q_0) edge              node [above]  {0} (q_1)
                      edge [loop above] node          {1} ()
                      edge [bend left]  node [above]  {1} (q_2)
                      edge [bend right] node [below]  {0} (q_2)
                (q_1) edge              node [above]  {1} (q_2);
    \end{tikzpicture}

    \begin{tikzpicture}
      \foreach \angle in {0,45,...,315}
        \node[rectangle,draw=black!50] (\angle) at (\angle:2) {\angle};

      \foreach \from/\to in {0/45,45/90,90/135,135/180,
                             180/225,225/270,270/315,315/0}
        \path (\from) edge [->,bend right=22,looseness=0.8] (\to)
                      edge [<-,bend left=22,looseness=0.8] (\to);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/bend:left",
         meta = "⟨angle⟩"
      },
      ["bend pos"] = {
         details = [[
Specifies where the "previous" point is relative to which the bend is
calculated. The previous point will be at the ⟨fraction⟩th part of the
line from the old current point to the new current point.

The idea is the following: If you say bend pos=0 and bend +(0,0), the
bend will be at the old current point. If you say bend pos=1 and
bend +(0,0), the bend will be at the new current point. If you say
bend pos=0.5 and bend +(0,2cm) the bend will be 2cm above the middle of
the line between the start and end point. This is most useful in
situations such as the following:

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw (-1,0) parabola[bend pos=0.5] bend +(0,2) +(3,0);
    \end{tikzpicture}

In the above example, the bend +(0,2) essentially means "a parabola that
is 2cm high" and +(3,0) means "and 3cm wide". Since this situation
arises often, there is a special shortcut option:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/bend:pos",
         meta = "⟨fraction⟩"
      },
      ["bend right"] = {
         details = [[
Works like the bend left option, only the bend is to the other side.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/bend:right",
         meta = "⟨angle⟩"
      },
      ["blend group"] = {
         details = [[
This key can only be used with a scope (like transparency group). It
will cause the current scope to become a transparency group and, inside
this group, the blend mode will be set to ⟨mode⟩.

    \tikz [blend group=screen] {
      \fill[red!90!black]   ( 90:.6) circle (1);
      \fill[green!80!black] (210:.6) circle (1);
      \fill[blue!90!black]  (330:.6) circle (1);
    }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/blend:group",
         meta = "⟨mode⟩"
      },
      ["blend mode"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/blend:mode",
         meta = "⟨mode⟩"
      },
      ["bottom color"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/bottom:color",
         meta = "⟨color⟩"
      },
      ["callout absolute pointer"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/callout:absolute:pointer",
         meta = "⟨coordinate⟩"
      },
      ["callout relative pointer"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/callout:relative:pointer",
         meta = "⟨coordinate⟩"
      },
      ["canvas is plane"] = {
         details = [[
Perform the transformation into the new canvas plane using the units
above. Note that you have to set the units before calling
canvas is plane.

    \begin{tikzpicture}[
        ->,
        plane x={(0.707,-0.707)},
        plane y={(0.707,0.707)},
        canvas is plane,
    ]
        \draw (0,0) -- (1,0);
        \draw (0,0) -- (0,1);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/canvas:is:plane"
      },
      ["canvas is xy plane at z"] = {
         details = [[
A plane with

-   plane origin={(0,0,⟨dimension⟩)},

-   plane x={(1,0,⟨dimension⟩)}, and

-   plane y={(0,1,⟨dimension⟩)}.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/canvas:is:xy:plane:at:z",
         meta = "⟨dimension⟩"
      },
      ["canvas is xz plane at y"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/canvas:is:xz:plane:at:y",
         meta = "⟨dimension⟩"
      },
      ["canvas is yx plane at z"] = {
         details = [[
A plane with

-   plane origin={(0,0,⟨dimension⟩)},

-   plane x={(0,1,⟨dimension⟩)}, and

-   plane y={(1,0,⟨dimension⟩)}.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/canvas:is:yx:plane:at:z",
         meta = "⟨dimension⟩"
      },
      ["canvas is yz plane at x"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/canvas:is:yz:plane:at:x",
         meta = "⟨dimension⟩"
      },
      ["canvas is zx plane at y"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/canvas:is:zx:plane:at:y",
         meta = "⟨dimension⟩"
      },
      ["canvas is zy plane at x"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/canvas:is:zy:plane:at:x",
         meta = "⟨dimension⟩"
      },
      cells = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cells",
         meta = "⟨options⟩"
      },
      centered = {
         details = [[
A shorthand for anchor=center.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/centered"
      },
      ["chain default direction"] = {
         details = [[
This ⟨direction⟩ is used in a chain option, if no other ⟨direction⟩ is
specified.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/chain:default:direction",
         meta = "⟨direction⟩"
      },
      ["child anchor"] = {
         details = [[
Specifies the anchor where the edge from parent meets the child node by
setting the macro \tikzchildanchor to .⟨anchor⟩.

If you specify border as the ⟨anchor⟩, then the macro \tikzchildanchor
is set to the empty string. The effect of this is that the edge from the
parent will meet the child on the border at an automatically calculated
position.

    \begin{tikzpicture}
      \node {root}
        [child anchor=north]
        child {node {left} edge from parent[dashed]}
        child {node {right}
          child {node {child}}
          child {node {child} edge from parent[draw=none]}
        };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/child:anchor",
         meta = "⟨anchor⟩"
      },
      ["children are tokens"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/children:are:tokens"
      },
      ["circle connection bar"] = {
         details = [[
This style installs a rather involved to-path. Unlike normal to-paths,
this path requires that the start and the target of the to-path are
named nodes of shape circle -- if this is not the case, this path will
produce errors.

Assuming that the start and the target are circles, the to-path will
first compute the radii of these circles (by measuring the distance from
the center anchor to some anchor on the border) and will set the
start circle keys accordingly. Next, the fill option is set to the
concept color while draw=none is set. The decoration is set to
circle connection bar. Finally, the following style is included:

    \begin{tikzpicture}[concept color=blue!50,blue!50,outer sep=0pt]
      \node (n1) at (0,0)   [circle,minimum size=2cm,fill,draw,thick] {};
      \node (n2) at (2.5,0) [circle,minimum size=1cm,fill,draw,thick] {};

      \path (n1) to[circle connection bar] (n2);
    \end{tikzpicture}

Note that it is not a good idea to have more than one to operation
together with the option circle connection bar in a single \path. Use
the edge operation, instead, for creating multiple connections and this
operation creates a new scope for each edge.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circle:connection:bar"
      },
      ["circle connection bar switch color"] = {
         details = [[
This style works similarly to the circle connection bar. The only
difference is that instead of filling the path with a single color a
shading is used.

    \begin{tikzpicture}[outer sep=0pt]
      \node (n1) at (0,0)    [circle,minimum size=2cm,fill,draw,thick,red] {};
      \node (n2) at (30:2.5) [circle,minimum size=1cm,fill,draw,thick,blue] {};

      \path (n1) to[circle connection bar switch color=from (red) to (blue)] (n2);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circle:connection:bar:switch:color",
         meta = "from (⟨first color⟩) to (⟨second color⟩)"
      },
      ["circle through"] = {
         details = [[
When this key is given as an option to a node, the following happens:

1.  The inner sep and the outer sep are set to zero.

2.  The shape is set to circle.

3.  The minimum size is set such that the circle around the center of
    the node (which is specified using at), goes through ⟨coordinate⟩.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \node (a) at (2,1.5) {$a$};
      \node [draw] at (1,1) [circle through={(a)}] {$c$};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circle:through",
         meta = "⟨coordinate⟩"
      },
      ["circuit declare annotation"] = {
         details = [[
This key is used to declare an annotation named ⟨name⟩. Once declared,
it can be used as an argument of a symbol and will add the drawing in
⟨path⟩ to the symbol. In detail, the following happens:

The Main Keys. Two keys called ⟨name⟩ and ⟨name⟩’ are defined. The
second causes the annotation to be "mirrored and placed on the other
side" of the symbol. Both of these keys may also take further keys as
parameter like info keys. Whenever the ⟨name⟩ key is used, a local scope
is opened and in this scope the following things are done:

1.  The style every ⟨name⟩ is executed.

2.  The following style is executed and then arrows=->:

3.  The coordinate system is shifted such that the origin is at the
    north anchor of the symbol. (For the ⟨name⟩’ key the coordinate
    system is flipped and shifted such that the origin is at the south
    anchor of the symbol.)

4.  The label distance is locally set to ⟨distance⟩.

5.  The parameter options given to the ⟨name⟩ key are executed.

6.  The ⟨path⟩ is executed.

Usage. What all of the above amounts to is best explained by an example.
Suppose we wish to create an annotation that looks like a little
circular arrow (like [PICTURE]). We could then say:

    \tikzset{circuit declare annotation=
      {circular annotation}
      {9pt}
      {(0pt,8pt) arc (-270:80:3.5pt)}
    }

We can then use it like this:

    \tikz[circuit ee IEC]
      \draw (0,0) to [resistor={circular annotation}]   (3,0);

Well, not very impressive since we do not see anything. This is due to
the fact that the ⟨path⟩ becomes part of a path that contains the symbol
node an nothing else. This path is not drawn or filled, so we do not see
anything. What we must do is to use an edge path operation:

    \tikzset{circuit declare annotation={circular annotation}{9pt}
      {(0pt,8pt) edge[to path={arc(-270:80:3.5pt)}] ()}
    }
    \tikz[circuit ee IEC]
      \draw (0,0) to [resistor={circular annotation}]   (3,0)
                  to [capacitor={circular annotation'}] (3,2);

The ⟨distance⟩ is important for the correct placement of additional info
labels. When an annotation is present, the info labels may need to be
moved further away from the symbol, but not always. For this reason, an
annotation defines an additional ⟨distance⟩ that is applied to all info
labels given as parameters to the annotation. Here is an example, that
shows the difference:

    \tikz[circuit ee IEC]
      \draw (0,0) to [resistor={circular annotation,ohm=5}]   (2,0)
                  to [resistor={circular annotation={ohm=5}}] (4,0);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:declare:annotation",
         meta = "{name}{distance}{path}"
      },
      ["circuit declare symbol"] = {
         details = [[
This key is used to declare a symbol. It does not cause this symbol to
be shown nor does it set a graphic to be used for the symbol, it simply
"prepares" several keys that can later be used to draw a symbol and to
configure it.

In detail, the first key that is defined is just called ⟨name⟩. This key
should be given as an option to a node or on a to path, as explained
below. The key will take options, which can be used to influence the way
the symbol graphic is rendered.

Let us have a look at an example. Suppose we want to define a symbol
called foo, which just looks like a simple rectangle. We could then say

    \tikzset{circuit declare symbol=foo}

The symbol could now be used like this:

      \node [foo]       at (1,1) {};
      \node [foo={red}] at (2,1) {};

However, in the above example we would not actually see anything since
we have not yet set up the graphic to be used by foo. For this, we must
use a key called set foo graphic or, generally, set ⟨name⟩ graphic. This
key gets graphic options as parameter that will be set when a symbol foo
should be shown:

    \begin{tikzpicture}
      [circuit declare symbol=foo,
       set foo graphic={draw,shape=rectangle,minimum size=5mm}]

      \node [foo]       at (1,1) {};
      \node [foo={red}] at (2,1) {};
    \end{tikzpicture}

In detail, when you use the key ⟨name⟩=⟨options⟩ with a node, the
following happens:

1.  The inner sep is set to 0.5pt.

2.  The following style is executed:

3.  The graphic options that have been set using set ⟨name⟩ graphic are
    set.

4.  The style every ⟨name⟩ is executed. You can use it to configure the
    symbol further.

5.  The ⟨options⟩ are executed.

The key ⟨name⟩ will have a different effect when it is used on a to path
command inside a circuit environment (the circuit environment sets up to
paths in such a way that the use of a key declared using
circuit declare symbol is automatically detected). When ⟨name⟩ is used
on a to path, the above actions also happen (setting the inner
separation, using the symbol graphic, and so on), but they are passed to
the key circuit handle symbol, which is explained next.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:declare:symbol",
         meta = "⟨name⟩"
      },
      ["circuit declare unit"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:declare:unit",
         meta = "{name}{unit}"
      },
      ["circuit ee"] = {
         details = [[
This style calls the keys circuit (which internally calls every circuit
and the following style:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:ee"
      },
      ["circuit ee IEC"] = {
         details = [[
This style calls circuit ee and installs the IEC-like graphics for the
logical symbols like resistor.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:ee:IEC"
      },
      ["circuit handle symbol"] = {
         details = [[
This key is mostly used internally. Its purpose is to render a symbol.
The effect of this key differs, depending on whether it is used as the
optional argument of a to path command or elsewhere.

If the key is not used as an argument of a to path command, the
⟨options⟩ are simply executed.

The more interesting case happens when the key is given on a to path
command. In this case, several things happen:

1.  The to path is locally changed and set to an internal path (which
    you should not try to change) that consists mostly of a single
    straight line.

2.  The ⟨options⟩ are tentatively executed with filtering switched on.
    Everything is filtered out, except for the key pos and also the
    styles at start, very near start, near start, midway, near end,
    very near end, and at end. If none of them is found, midway is used.

3.  The filtered option is used to determine a position for the symbol
    on the path. At the given position (with pos=0 representing the
    start and pos=1 representing the end), a node will be added to the
    path (in a manner to be described presently).

4.  This node gets ⟨options⟩ as its option list.

5.  The node is added by virtue of a special markings decoration. This
    means that a mark command is executed that causes the node to be
    placed as a mark on the path.

6.  The marking decoration will automatically subdivide the path and
    cause a line to be drawn from the start of the path to the node's
    border (at the position that lies on a line from the node's center
    to the start of the path) and then from the node's border (at a
    position on the other side of the node) to the end of the path.

7.  The marking decoration will also take care of the case that multiple
    marks are present on a path, in this case the lines from and to the
    borders of the nodes are only between consecutive nodes.

8.  The marking decoration will also rotate the coordinate system in
    such a way that the $x$-axis points along the path. Thus, if you use
    the transform shape option, the node will "point along" the path.

9.  In case a node is at pos=0 or at pos=1 some special code will
    suppress the superfluous lines to the start or end of the path.

The net effect of all of the above is that a node will be placed "on the
path" and the path will have a "gap" just large enough to encompass the
node. Another effect is that you can use this key multiple times on a
path to add several node to a path, provided they do not overlap.

    \begin{tikzpicture}[circuit]
      \draw (0,0) to [circuit handle symbol={draw,shape=rectangle,near start},
                      circuit handle symbol={draw,shape=circle,near end}] (3,2);
    \end{tikzpicture}

    \begin{tikzpicture}[transform shape,circuit]
      \draw (0,0) to [circuit handle symbol={draw,shape=rectangle,at start},
                      circuit handle symbol={draw,shape=circle,near end}] (3,2);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:handle:symbol",
         meta = "⟨options⟩"
      },
      ["circuit logic"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:logic"
      },
      ["circuit logic CDH"] = {
         details = [[
This key calls circuit logic US and installs the two special and- and
nand-gates, that is, it uses set and gate graphic with
and gate CDH graphic and likewise for nand-gates.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:logic:CDH"
      },
      ["circuit logic IEC"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:logic:IEC"
      },
      ["circuit logic US"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:logic:US"
      },
      ["circuit symbol filled"] = {
         details = [[
This style is used with symbols that are completely filled. For
instance, the variant IEC version of an inductor is a filled, black
rectangle.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:symbol:filled"
      },
      ["circuit symbol lines"] = {
         details = [[
This style is used with symbols that consist only of lines that do not
surround anything. Examples are a capacitor.

    \tikz [circuit ee IEC,
           circuit symbol lines/.style={thick,draw=red}]
      \draw (0,0) to [capacitor] ++(right:3) to [resistor] ++(up:2);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:symbol:lines"
      },
      ["circuit symbol open"] = {
         details = [[
This style is used with symbols that consist of lines that surround some
area. For instance, the IEC version of a resistor is an open symbol.

    \tikz [circuit ee IEC,
           circuit symbol open/.style={thick,draw,fill=yellow}]
      \draw (0,0) to [inductor] ++(right:3) to [resistor] ++(up:2);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:symbol:open"
      },
      ["circuit symbol size"] = {
         details = [[
This key sets minimum height to ⟨height⟩ times the current value of the
circuit symbol unit and the minimum width to ⟨width⟩ times this value.
Thus, this option can be used with a node command to set the size of the
node as a multiple of the circuit symbol unit.

    \begin{tikzpicture}[circuit ee IEC]
      \draw (0,1) to [resistor] (2,1) to[inductor] (4,1);

      \begin{scope}
        [every resistor/.style={circuit symbol size=width 3 height 1}]
        \draw (0,0) to [resistor] (2,0) to[inductor] (4,0);
      \end{scope}
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:symbol:size",
         meta = "width ⟨width⟩ height ⟨height⟩"
      },
      ["circuit symbol unit"] = {
         details = [[
This dimension is a "unit" for the size of symbols. The libraries
generally define the sizes of symbols relative to this dimension. For
instance, the longer side of an inductor is, by default, in the IEC
library equal to five times this ⟨dimension⟩. When you change this
⟨dimension⟩, the size of all symbols will automatically change
accordingly.

Note, that it is still possible to overwrite the size of any particular
symbol. These settings apply only to the default sizes.

    \begin{tikzpicture}[circuit ee IEC]
      \draw (0,1) to [resistor] (3.5,1);
      \draw[circuit symbol unit=14pt]
            (0,0) to [resistor] (3.5,0);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:symbol:unit",
         meta = "⟨dimension⟩"
      },
      ["circuit symbol wires"] = {
         details = [[
This style is used for symbols that consist only of "wires". The
difference to the previous style is that a symbol consisting of wires
will look strange when the lines are thicker than the lines of normal
wires, while for symbols consisting of lines (but not wires) it may look
nice to make them thicker. An example is the make contact symbol.

Compare

    \tikz [circuit ee IEC,circuit symbol lines/.style={draw,very thick}]
      \draw (0,0) to [capacitor={near start},
                      make contact={near end}] (3,0);

to

    \tikz [circuit ee IEC,circuit symbol wires/.style={draw,very thick}]
      \draw (0,0) to [capacitor={near start},
                      make contact={near end}] (3,0);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circuit:symbol:wires"
      },
      circuits = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circuits"
      },
      ["circular drop shadow"] = {
         details = [[
This shadow works like a drop shadow, only it adds a circular fading to
the shadow. This means that the shadow will fade out at the border. The
following options are preset for this shadow:

      shadow scale=1.1, shadow xshift=.3ex, shadow yshift=-.3ex,
      fill=black, path fading={circle with fuzzy edge 15 percent},
      every shadow,

    \begin{tikzpicture}
      \foreach \i in {1,...,8}
        \node[circle,circular drop shadow,draw=blue,fill=blue!20,thick]
          at (\i*45:1) {Circle \i};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circular:drop:shadow",
         meta = "⟨shadow options⟩"
      },
      ["circular glow"] = {
         details = [[
This shadow works much like the circular shadow, only it is not shifted.
This creates a visual effect of a "glow" behind the circle. The
following options are preset for this shadow:

      shadow scale=1.25, shadow xshift=0pt, shadow yshift=0pt,
      fill=black, path fading={circle with fuzzy edge 15 percent},
      every shadow,

    \begin{tikzpicture}
      \foreach \i in {1,...,8}
      \node[circle,circular glow,fill=red!20,draw=red,thick]
        at (\i*45:1) {Circle \i};
    \end{tikzpicture}

    \begin{tikzpicture}
      \foreach \i in {1,...,8}
      \node[circle,circular glow={fill=white},fill=red!20,draw=red,thick]
        at (\i*45:1) {Circle \i};
    \end{tikzpicture}

    \begin{tikzpicture}
      \foreach \i in {1,...,8}
      \node[circle,circular glow={fill=green},fill=black,text=green!50!black]
        at (\i*45:1) {Circle \i};
    \end{tikzpicture}

An especially interesting effect can be achieved by only using the glow
and not filling the path:

    \begin{tikzpicture}
      \foreach \i in {1,...,8}
      \node[circle,circular glow={fill=red!\i0}]
        at (\i*45:1) {Circle \i};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/circular:glow",
         meta = "⟨shadow options⟩"
      },
      clip = {
         details = [[
This option causes all subsequent drawings to be clipped against the
current path and the size of subsequent paths will not be important for
the picture size. If you clip against a self-intersecting path, the
even-odd rule or the nonzero winding number rule is used to determine
whether a point is inside or outside the clipping region.

The clipping path is a graphic state parameter, so it will be reset at
the end of the current scope. Multiple clippings accumulate, that is,
clipping is always done against the intersection of all clipping areas
that have been specified inside the current scopes. The only way of
enlarging the clipping area is to end a {scope}.

    \begin{tikzpicture}
      \draw[clip] (0,0) circle (1cm);
      \fill[red] (1,0) circle (1cm);
    \end{tikzpicture}

It is usually a very good idea to apply the clip option only to the
first path command in a scope.

If you "only wish to clip" and do not wish to draw anything, you can use
the \clip command, which is a shorthand for \path[clip].

    \begin{tikzpicture}
      \clip (0,0) circle (1cm);
      \fill[red] (1,0) circle (1cm);
    \end{tikzpicture}

To keep clipping local, use {scope} environments as in the following
example:

    \begin{tikzpicture}
      \draw (0,0) -- ( 0:1cm);
      \draw (0,0) -- (10:1cm);
      \draw (0,0) -- (20:1cm);
      \draw (0,0) -- (30:1cm);
      \begin{scope}[fill=red]
        \fill[clip] (0.2,0.2) rectangle (0.5,0.5);

        \draw (0,0) -- (40:1cm);
        \draw (0,0) -- (50:1cm);
        \draw (0,0) -- (60:1cm);
      \end{scope}
      \draw (0,0) -- (70:1cm);
      \draw (0,0) -- (80:1cm);
      \draw (0,0) -- (90:1cm);
    \end{tikzpicture}

There is a slightly annoying catch: You cannot specify certain graphic
options for the command used for clipping. For example, in the above
code we could not have moved the fill=red to the \fill command. The
reasons for this have to do with the internals of the PDF specification.
You do not want to know the details. It is best simply not to specify
any options for these commands.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/clip"
      },
      ["clockwise from"] = {
         details = [[
This option also causes children to be arranged on a circle. However,
the rule for placing children is simpler than with the grow cyclic
style: The first child is placed at ⟨angle⟩ at a distance of
\tikzleveldistance. The second child is placed at the same distance from
the parent, but at angle ⟨angle⟩${}-{}$\tikzsiblingangle. The third
child is displaced by another \tikzsiblingangle in a clockwise fashion,
and so on.

Note that this function will not rotate the coordinate system.

    \begin{tikzpicture}
      \node {root}
      [clockwise from=30,sibling angle=30]
      child {node {$30$}}
      child {node {$0$}}
      child {node {$-30$}}
      child {node {$-60$}};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/clockwise:from",
         meta = "⟨angle⟩"
      },
      cm = {
         details = [[
applies the following transformation to all coordinates: Let $(x,y)$ be
the coordinate to be transformed and let ⟨coordinate⟩ specify the point
$(t_x,t_y)$. Then the new coordinate is given by
$\left(\begin{smallmatrix} a & c \\ b & d\end{smallmatrix}\right)
    \left(\begin{smallmatrix} x \\ y \end{smallmatrix}\right) +
    \left(\begin{smallmatrix} t_x \\ t_y \end{smallmatrix}\right)$.
Usually, you do not use this option directly.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                             (0,0) -- (1,1) -- (1,0);
      \draw[cm={1,1,0,1,(0,0)},blue]    (0,0) -- (1,1) -- (1,0);
      \draw[cm={0,1,1,0,(1cm,1cm)},red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cm",
         meta = "{⟨$a$⟩,⟨$b$⟩,⟨$c$⟩,⟨$d$⟩,⟨coordinate⟩}"
      },
      color = {
         details = [[
This option sets the color that is used for fill, drawing, and text
inside the current scope. Any special settings for filling colors or
drawing colors are immediately "overruled" by this option.

The ⟨color name⟩ is the name of a previously defined color. For
LaTeX users, this is just a normal "LaTeX-color" and the xcolor
extensions are allowed. Here is an example:

    \tikz \fill[color=red!20] (0,0) circle (1ex);

It is possible to "leave out" the color= part and you can also write:

    \tikz \fill[red!20] (0,0) circle (1ex);

What happens is that every option that TikZ does not know, like red!20,
gets a "second chance" as a color name.

For plain TeX users, it is not so easy to specify colors since plain
TeX has no "standardized" color naming mechanism. Because of this,
PGF emulates the xcolor package, though the emulation is extremely basic
(more precisely, what I could hack together in two hours or so). The
emulation allows you to do the following:

-   Specify a new color using \definecolor. Only the color models gray,
    rgb, and RGB are supported[1]. \definecolor{orange}{rgb}{1,0.5,0}

-   Use \colorlet to define a new color based on an old one. Here, the !
    mechanism is supported, though only "once" (use multiple \colorlet
    for more fancy colors). \colorlet{lightgray}{black!25}

-   Use \color{color name} to set the color in the current TeX group.
    \aftergroup-hackery is used to restore the color after the group.

[1] ConTeXt users should be aware that \definecolor has a different
meaning in ConTeXt. There is a low-level equivalent named
\pgfutil@definecolor which can be used instead.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/color",
         meta = "⟨color name⟩"
      },
      ["colored tokens"] = {
         details = [[
This option, which must also be given when a place node is being
created, gets a list of colors as parameter. It will then add as many
tokens to the place as there are colors in this list, each filled
correspondingly.

    \tikz  \node[place,colored tokens={black,black,red,blue}] {};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/colored:tokens",
         meta = "⟨color list⟩"
      },
      ["column sep"] = {
         details = [[
This option sets a default space that is added between every two
columns. This space can be positive or negative and is zero by default.
The ⟨spacing list⟩ normally contains a single dimension like 2pt.

    \begin{tikzpicture}
      \matrix [draw,column sep=1cm,nodes=draw]
      {
        \node(a) {123}; & \node (b) {1};   & \node {1}; \\
        \node    {12};  & \node     {12};  & \node {1}; \\
        \node(c) {1};   & \node (d) {123}; & \node {1}; \\
      };
      \draw [red,thick]  (a.east) -- (a.east |- c)
                         (d.west) -- (d.west |- b);
      \draw [<->,red,thick] (a.east) -- (d.west |- b)
        node [above,midway] {1cm};
    \end{tikzpicture}

More generally, the ⟨spacing list⟩ may contain a whole list of numbers,
separated by commas, and occurrences of the two key words
between origins and between borders. The effect of specifying such a
list is the following: First, all numbers occurring in the list are
simply added to compute the final spacing. Second, concerning the two
keywords, the last occurrence of one of the keywords is important. If
the last occurrence is between borders or if neither occurs, then the
space is inserted between the two columns normally. However, if the last
occurs is between origins, then the following happens: The distance
between the columns is adjusted such that the difference between the
origins of all the cells in the first column (remember that they all lie
on straight line) and the origins of all the cells in the second column
is exactly the given distance.

The between origins option can only be used for columns mentioned in the
first row, that is, you cannot specify this option for columns
introduced only in later rows.

    \begin{tikzpicture}
      \matrix [draw,column sep={1cm,between origins},nodes=draw]
      {
        \node(a) {123}; & \node (b) {1};   & \node {1}; \\
        \node    {12};  & \node     {12};  & \node {1}; \\
        \node    {1};   & \node     {123}; & \node {1}; \\
      };
      \draw [<->,red,thick] (a.center) -- (b.center) node [above,midway] {1cm};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/column:sep",
         meta = "⟨spacing list⟩"
      },
      ["column ⟨number⟩"] = {
         details = [[
This style is used for every cell in column ⟨number⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/column:⟨number⟩"
      },
      concept = {
         details = [[
This style should be used with all nodes that are concepts, although
some styles like extra concept install this style automatically.

Basically, this style makes the concept node circular and installs a
uniform color called concept color, see below. Additionally, the style
every concept is called.

    \tikz[mindmap,concept color=red!50] \node [concept] {Some concept};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/concept"
      },
      ["concept color"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/concept:color",
         meta = "⟨color⟩"
      },
      ["concept connection"] = {
         details = [[
This style can be used for lines between two concepts. Feel free to
redefine this style.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/concept:connection"
      },
      ["connect spies"] = {
         details = [[
Causes the spy-in and the spy-on nodes to be connected by a thin line.

    \begin{tikzpicture}
      [spy using overlays={circle, magnification=3, size=1cm}]

      \draw [decoration=Koch curve type 2]
        decorate{ decorate{ decorate{ (0,0) -- (2,0) }}};

      \spy [green] on (1.6,0.1) in node at (3,1);
      \spy [red,connect spies] on (0.5,0.4) in node at (1,1.5);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/connect:spies"
      },
      ["const plot"] = {
         details = [[
This option causes the points on the path to be connected using
piecewise constant series of lines:

    \tikz\draw plot[const plot] file{plots/pgfmanual-sine.table};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/const:plot"
      },
      ["const plot mark left"] = {
         details = [[
Just an alias for /tikz/const plot.

    \tikz\draw plot[const plot mark left,mark=*] file{plots/pgfmanual-sine.table};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/const:plot:mark:left"
      },
      ["const plot mark mid"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/const:plot:mark:mid"
      },
      ["const plot mark right"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/const:plot:mark:right"
      },
      ["continue branch"] = {
         details = [[
This option works like the continue chain option, only ⟨current
chain⟩/⟨branch name⟩ is used as the chain name, rather than just ⟨branch
name⟩.

    \begin{tikzpicture}[every on chain/.style=join,every join/.style=->,
                        node distance=2mm and 1cm]
      { [start chain=trunk]
        \node [on chain] {A};
        \node [on chain] {B};
        { [start branch=numbers going below] } % just a declaration,
        { [start branch=greek   going above] } % we will come back later
        \node [on chain] {C};

        % Now come the branches...
        { [continue branch=numbers]
          \node [on chain] {1};
          \node [on chain] {2};
        }
        { [continue branch=greek]
          \node [on chain] {$\alpha$};
          \node [on chain] {$\beta$};
        }
      }
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/continue:branch",
         meta = "⟨branch name⟩⟨direction⟩"
      },
      ["continue chain"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/continue:chain",
         meta = "⟨chain name⟩⟨direction⟩"
      },
      controls = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/controls",
         meta = "⟨coordinate⟩ and ⟨coordinate⟩"
      },
      ["copy shadow"] = {
         details = [[
This shadow installs the following default options:

      shadow scale=1, shadow xshift=.5ex, shadow yshift=-.5ex, every shadow

Furthermore, the options fill=⟨fill color⟩ and draw=⟨draw color⟩ are
also set, where the ⟨fill color⟩ and ⟨draw color⟩ are the fill and draw
colors used for the main path.

    \begin{tikzpicture}
      \node [copy shadow,fill=blue!20,draw=blue,thick] {Hello World!};

      \node at (0,-1) [copy shadow={shadow xshift=1ex,shadow yshift=1ex},
                       fill=blue!20,draw=blue,thick]
        {Hello World!};

      \node at (0,-2) [copy shadow={opacity=.5},tape,
                       fill=blue!20,draw=blue,thick]
        {Hello World!};

      % We have to repeat the left color since shadings are not
      % automatically applied to shadows
      \node at (0,-3) [copy shadow={left color=blue!50},
                       left color=blue!50,draw=blue,thick]
        {Hello World!};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/copy:shadow",
         meta = "⟨shadow options⟩"
      },
      ["counterclockwise from"] = {
         details = [[
Works the same way as clockwise from, but sibling angles are added
instead of subtracted.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/counterclockwise:from",
         meta = "⟨angle⟩"
      },
      ["cs/angle"] = {
         details = [[
It is also possible to provide an angle instead of an anchor. This
coordinate refers to a point of the node's border where a ray shot from
the center in the given angle hits the border. Here is an example:

    \begin{tikzpicture}
      \node (start) [draw,shape=ellipse] {start};
      \foreach \angle in {-90, -80, ..., 90}
        \draw (node cs:name=start,angle=\angle)
          .. controls +(\angle:1cm) and +(-1,0) .. (2.5,0);
      \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/angle",
         meta = "⟨degrees⟩"
      },
      ["cs/first line"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/first:line",
         meta = "{(⟨first % coordinate⟩)--(⟨second coordinate⟩)}"
      },
      ["cs/first node"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/first:node",
         meta = "⟨node⟩"
      },
      ["cs/horizontal line through"] = {
         details = [[
Specifies that one line is a horizontal line that goes through the given
coordinate.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/horizontal:line:through",
         meta = "{(⟨coordinate⟩)}"
      },
      ["cs/latitude"] = {
         details = [[
Angle of the coordinate between the $y$- and $z$-vector, measured from
the $y$-vector.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/latitude",
         meta = "⟨degrees⟩"
      },
      ["cs/longitude"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/longitude",
         meta = "⟨degrees⟩"
      },
      ["cs/name"] = {
         details = [[
Specifies the node that you wish to use to specify a coordinate. The
⟨node name⟩ is the name that was previously used to name the node using
the name=⟨node name⟩ option or the special node name syntax.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/name",
         meta = "⟨node name⟩"
      },
      ["cs/node"] = {
         details = [[
This key specifies the node on whose border the tangent should lie.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/node",
         meta = "⟨node⟩"
      },
      ["cs/point"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/point",
         meta = "⟨point⟩"
      },
      ["cs/radius"] = {
         details = [[
A factor by which the $x$-vector and $y$-vector are multiplied prior to
forming the ellipse.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/radius",
         meta = "⟨factor⟩"
      },
      ["cs/second line"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/second:line",
         meta = "{(⟨first % coordinate⟩)--(⟨second coordinate⟩)}"
      },
      ["cs/second node"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/second:node",
         meta = "⟨node⟩"
      },
      ["cs/solution"] = {
         details = [[
Specifies which solution should be used if there are more than one.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/solution",
         meta = "⟨number⟩"
      },
      ["cs/vertical line through"] = {
         details = [[
Specifies that the other line is vertical and goes through the given
coordinate.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/vertical:line:through",
         meta = "{(⟨coordinate⟩)}"
      },
      ["cs/x"] = {
         details = [[
Factor by which the $x$-vector is multiplied.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/x",
         meta = "⟨factor⟩"
      },
      ["cs/x radius"] = {
         details = [[
A specific factor by which only the $x$-vector is multiplied.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/x:radius",
         meta = "⟨dimension⟩"
      },
      ["cs/y"] = {
         details = [[
Works like x.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/y",
         meta = "⟨factor⟩"
      },
      ["cs/y radius"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/y:radius",
         meta = "⟨dimension⟩"
      },
      ["cs/z"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/cs/z",
         meta = "⟨number⟩"
      },
      ["current point is local"] = {
         details = [[
Normally, the scope path operation has no effect on the current point.
That is, curly braces on a path have no effect on the current position:

    \begin{tikzpicture}
      \draw      (0,0) -- ++(1,0)   -- ++(0,1)   -- ++(-1,0);
      \draw[red] (2,0) -- ++(1,0) { -- ++(0,1) } -- ++(-1,0);
    \end{tikzpicture}

If you set this key to true, this behavior changes. In this case, at the
end of a group created on a path, the last current position reverts to
whatever value it had at the beginning of the scope. More precisely,
when TikZ encounters } on a path, it checks whether at this particular
moment the key is set to true. If so, the current position reverts to
the value it had when the matching { was read.

    \begin{tikzpicture}
      \draw      (0,0) -- ++(1,0)   -- ++(0,1)   -- ++(-1,0);
      \draw[red] (2,0) -- ++(1,0)
         { [current point is local] -- ++(0,1) } -- ++(-1,0);
    \end{tikzpicture}

In the above example, we could also have given the option outside the
scope, for instance as a parameter to the whole scope.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/current:point:is:local",
         meta = "⟨boolean⟩"
      },
      ["curve to"] = {
         details = [[
Specifies that the to path should be a curve. This curve will leave the
start coordinate at a certain angle, which can be specified using the
out option. It reaches the target coordinate also at a certain angle,
which is specified using the in option. The control points of the curve
are at a certain distance that is computed in different ways, depending
on which options are set.

All of the following options implicitly cause the curve to style to be
installed.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/curve:to"
      },
      dash = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/dash",
         meta = "⟨dash pattern⟩phase⟨dash phase⟩"
      },
      ["dash dot"] = {
         details = [[
Shorthand for setting a dashed and dotted dash pattern.

    \tikz \draw[dash dot] (0pt,0pt) -- (50pt,0pt);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/dash:dot"
      },
      ["dash dot dot"] = {
         details = [[
Shorthand for setting a dashed and dotted dash pattern with more dots.

    \tikz \draw[dash dot dot] (0pt,0pt) -- (50pt,0pt);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/dash:dot:dot"
      },
      ["dash expand off"] = {
         details = [[
Makes the off part of a dash pattern expandable such that it can
stretch. This only works when there is a single on and a single off
field and requires the decorations library. Right now this option has to
be specified on the path where it is supposed to take effect after the
dash pattern option because the dash pattern has to be known at the
point where it is applied.

    \begin{tikzpicture}[|-|, dash pattern=on 4pt off 2pt]
      \draw [dash expand off] (0pt,30pt) -- (26pt,30pt);
      \draw [dash expand off] (0pt,20pt) -- (24pt,20pt);
      \draw [dash expand off] (0pt,10pt) -- (22pt,10pt);
      \draw [dash expand off] (0pt, 0pt) -- (20pt, 0pt);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/dash:expand:off"
      },
      ["dash pattern"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/dash:pattern",
         meta = "⟨dash pattern⟩"
      },
      ["dash phase"] = {
         details = [[
Shifts the start of the dash pattern by ⟨phase⟩.

    \begin{tikzpicture}[dash pattern=on 20pt off 10pt]
      \draw[dash phase=0pt] (0pt,3pt) -- (3.5cm,3pt);
      \draw[dash phase=10pt] (0pt,0pt) -- (3.5cm,0pt);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/dash:phase",
         meta = "⟨dash phase⟩"
      },
      dashed = {
         details = [[
Shorthand for setting a dashed dash pattern.

    \tikz \draw[dashed] (0pt,0pt) -- (50pt,0pt);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/dashed"
      },
      ["data visualizers/visualize as line"] = {
         details = [[
Creates a new visualizer named ⟨visualizer name⟩. Basically, this
visualizer connects all data points for which the /data point/set
attribute equals ⟨visualizer name⟩ by a line that is styled by the
visualizer's style.

In more detail, the following happens:

1.  A new object is created (of class plot handler visualizer) that is
    configured to collect the canvas positions of all data points whose
    set attribute equals ⟨visualizer name⟩.

2.  During the end of the data visualization, PGF's plotting mechanism
    (see Section ??) is used to plot the stream of recorded data points.

    This means that, in principle, all of the plot handlers available in
    TikZ could be used for the visualization (such as the smooth
    handler). However, some plot handlers such as, say, the xcomb are
    unsuitable as plot handlers since they do not support the advanced
    axis handling done by the data visualization engine. Because of this
    (and also for other reasons), you cannot set the plot handler
    directly, but must use one of the options like straight line,
    smooth line and others, documented in a moment.

3.  Additionally, plot marks can be drawn at the collected data points.
    Here, all of the options available to TikZ for drawing plot marks
    are available. To configure them, all options offered by TikZ for
    configuring marks are available such as mark repeat:

        \tikz \datavisualization
         [scientific axes=clean,
          visualize as line=my data,
          my data={style={mark=x, mark repeat=3}}]
        data [format=function] {
          var x : interval [0:pi] samples 10;
          func y = sin(\value x r);
        };

The line visualizer also provides a method of dealing with gaps in a
line. Take for instance the function $f(x) = \tan x$. When this function
is plotted over the interval $[0,\pi]$, then the function will go to
$\pm
    \infty$ at $\pi/2$. When we plot this, we might plot the function in
the interval $[0,\frac{\pi}{2}-\epsilon]$ and then continue in the
interval $[\frac{\pi}{2}+\epsilon,\pi]$. However, we do not want the
point at coordinate $\bigl(\frac{\pi}{2}- \epsilon, \tan(\frac{\pi}{2}-
    \epsilon)\bigr)$ to be connected to the coordinate
$\bigl(\frac{\pi}{2}+
    \epsilon, \tan(\frac{\pi}{2}+ \epsilon)\bigr)$ by a line. Rather,
there should be a "gap" or a "jump" between these coordinates. To
achieve this, the following key can be used:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualizers/visualize:as:line",
         meta = "⟨visualizer name⟩"
      },
      ["data visualizers/visualize as scatter"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualizers/visualize:as:scatter",
         meta = "⟨visualizer name⟩"
      },
      ["data visualizers/visualize as smooth line"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/data:visualizers/visualize:as:smooth:line",
         meta = "⟨visualizer name⟩"
      },
      dates = {
         details = [[
This option specifies the date range. Both the start and end date are
specified and described on page ??. In short: You can provide ISO-format
type dates like 2006-01-02, you can replace the day of month by last to
refer to the last day of a month (so 2006-02-last is the same as
2006-02-28), and you can add a plus sign followed by a number to specify
an offset (so 2006-01-01+-1 is the same as 2005-12-31).
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/dates",
         meta = "⟨start date⟩ to ⟨end date⟩"
      },
      ["day code"] = {
         details = [[
This option allows you to change the code that is executed for each day.
The default is to create a node with an appropriate name, but you can
change this:

    \tikz \calendar[dates=2000-01-01 to 2000-01-31,week list,
                    day code={\fill[blue] (0,0) circle (2pt);}];

The default code is the following:

    \node[name=\pgfcalendarsuggestedname,every day]{\tikzdaytext};

The first part causes the day nodes to be accessible via the following
names: If ⟨name⟩ is the name given to the calendar via a name= option or
via the specification element (⟨name⟩), then \pgfcalendarsuggestedname
will expand to ⟨name⟩-⟨date⟩, where ⟨date⟩ is the date of the day that
is currently being processed in ISO format.

For example, if January 1, 2006 is being processed and the calendar has
been named mycal, then the node containing the 1 for this date will be
names mycal-2006-01-01. You can later reference this node.

    \begin{tikzpicture}
      \calendar (mycal) [dates=2000-01-01 to 2000-01-31,week list];

      \draw[red] (mycal-2000-01-20) circle (4pt);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/day:code",
         meta = "⟨code⟩"
      },
      ["day list downward"] = {
         details = [[
This style causes the days of a month to be typeset one below the other.
The shift between days is given by day yshift. Between month an
additional shift of month yshift is added.

    \tikz
      \calendar [dates=2000-01-28 to 2000-02-03,
                 day list downward,month yshift=1em];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/day:list:downward"
      },
      ["day list left"] = {
         details = [[
As above, but the list grows left.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/day:list:left"
      },
      ["day list right"] = {
         details = [[
This style also works as before, but the list of days grows to the
right. Instead of day yshift and month yshift, the values of day xshift
and month xshift are used.

    \tikz
      \calendar [dates=2000-01-28 to 2000-02-03,
                 day list right,month xshift=1em];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/day:list:right"
      },
      ["day list upward"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/day:list:upward"
      },
      ["day text"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/day:text",
         meta = "⟨text⟩"
      },
      ["day xshift"] = {
         details = [[
Specifies the horizontal shift between days. This is not the gap between
days, but the shift between the anchors of their nodes.

    \tikz \calendar[dates=2000-01-01 to 2000-01-31,week list,day xshift=3ex];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/day:xshift",
         meta = "⟨dimension⟩"
      },
      ["day yshift"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/day:yshift",
         meta = "⟨dimension⟩"
      },
      decorate = {
         details = [[
When this key is set, the whole path is decorated after it has been
finished. The decoration used for decorating the path is set via the
decoration way, in exactly the same way as for the decorate path
command. Indeed, the following two commands have the same effect:

1.  \path decorate[⟨options⟩] {⟨path⟩};

2.  \path [decorate,⟨options⟩] ⟨path⟩;

The main use or the decorate option is the you can also use it with the
nodes. It then causes the background path of the node to be decorated.
Note that you can decorate a background path only once in this manner.
That is, in contrast to the decorate path command you cannot apply this
option twice (this would just set it to true, once more).

    \begin{tikzpicture}[decoration=zigzag]
      \draw [help lines] (0,0) grid (3,5);

      \draw [fill=blue!20,decorate] (1.5,4) circle (1cm);

      \node at (1.5,2.5) [fill=red!20,decorate,ellipse] {Ellipse};

      \node at (1.5,1) [inner sep=6mm,fill=red!20,decorate,ellipse,decoration=
        {text along path,text={This is getting silly}}] {Ellipse};
    \end{tikzpicture}

In the last example, the text along path decoration removes the path. In
such cases it is useful to use a pre- or postaction to cause the
decoration to be applied only before or after the main path has been
used. Incidentally, this is another application of the decorate option
that you cannot achieve with the decorate path command.

    \begin{tikzpicture}[decoration=zigzag]
      \node at (1.5,1) [inner sep=6mm,fill=red!20,ellipse,
        postaction={decorate,decoration=
        {text along path,text={This is getting silly}}}] {Ellipse};
    \end{tikzpicture}

Here is more useful example, where a postaction is used to add the path
after the main path has been drawn.

    \begin{tikzpicture}
    \draw [help lines] grid (3,2);
    \fill [draw=red,fill=red!20,
             postaction={decorate,decoration={raise=2pt,text along path,
               text=around and around and around and around we go}}]
      (0,1) arc (180:-180:1.5cm and 1cm);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/decorate",
         meta = "⟨boolean⟩"
      },
      ["delta angle"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/delta:angle",
         meta = "⟨degrees⟩"
      },
      ["densely dash dot"] = {
         details = [[
Shorthand for setting a densely dashed and dotted dash pattern.

    \tikz \draw[densely dash dot] (0pt,0pt) -- (50pt,0pt);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/densely:dash:dot"
      },
      ["densely dash dot dot"] = {
         details = [[
Shorthand for setting a densely dashed and dotted dash pattern with more
dots.

    \tikz \draw[densely dash dot dot] (0pt,0pt) -- (50pt,0pt);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/densely:dash:dot:dot"
      },
      ["densely dashed"] = {
         details = [[
Shorthand for setting a densely dashed dash pattern.

    \tikz \draw[densely dashed] (0pt,0pt) -- (50pt,0pt);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/densely:dashed"
      },
      ["densely dotted"] = {
         details = [[
Shorthand for setting a densely dotted dash pattern.

    \tikz \draw[densely dotted] (0pt,0pt) -- (50pt,0pt);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/densely:dotted"
      },
      distance = {
         details = [[
Set the minimum and maximum distance to the same value ⟨distance⟩. Note
that this causes any computed distance $d$ to be ignored and ⟨distance⟩
to be used instead.

    \begin{tikzpicture}[out=45,in=135,distance=1cm]
      \draw (0,0) to (1,0)
            (0,0) to (2,0)
            (0,0) to (3,0);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/distance",
         meta = "⟨distance⟩"
      },
      domain = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/domain",
         meta = "⟨start⟩:⟨end⟩"
      },
      dotted = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/dotted"
      },
      double = {
         details = [[
This option causes "two" lines to be drawn instead of a single one.
However, this is not what really happens. In reality, the path is drawn
twice. First, with the normal drawing color, secondly with the ⟨core
color⟩, which is normally white. Upon the second drawing, the line width
is reduced. The net effect is that it appears as if two lines had been
drawn and this works well even with complicated, curved paths:

    \tikz \draw[double]
      plot[smooth cycle] coordinates{(0,0) (1,1) (1,0) (0,1)};

You can also use the doubling option to create an effect in which a line
seems to have a certain "border":

    \begin{tikzpicture}
      \draw (0,0) -- (1,1);
      \draw[draw=white,double=red,very thick] (0,1) -- (1,0);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/double",
         meta = "⟨core color⟩"
      },
      ["double copy shadow"] = {
         details = [[
This shadow works like a copy shadow, only the shadow is added twice,
the second time with the double xshift and yshift.

    \begin{tikzpicture}
      \node [double copy shadow,fill=blue!20,draw=blue,thick] {Hello World!};

      \node at (0,-1) [double copy shadow={shadow xshift=1ex,shadow yshift=1ex},
                       fill=blue!20,draw=blue,thick]
        {Hello World!};

      \node at (0,-2) [double copy shadow={opacity=.5},tape,
                       fill=blue!20,draw=blue,thick]
        {Hello World!};

      \node at (0,-3) [double copy shadow={left color=blue!50},
                       left color=blue!50,draw=blue,thick]
        {Hello World!};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/double:copy:shadow",
         meta = "⟨shadow options⟩"
      },
      ["double distance"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/double:distance",
         meta = "⟨dimension⟩"
      },
      ["double distance between line centers"] = {
         details = [[
This option works like double distance, only the distance is not the
distance between (inner) borders of the two main lines, but between
their centers. Thus, the thickness the first time the path is drawn is
the normal line width plus the given ⟨dimension⟩, while the line width
of the second line that is drawn is ⟨dimension⟩ minus the normal line
width. As a side-effect, this option "selects" the double option.

    \begin{tikzpicture}[double distance between line centers=3pt]
      \foreach \lw in {0.5,1,1.5,2,2.5}
        \draw[line width=\lw pt,double] (\lw,0) -- ++(4mm,0);
    \end{tikzpicture}

    \begin{tikzpicture}[double distance=3pt]
      \foreach \lw in {0.5,1,1.5,2,2.5}
        \draw[line width=\lw pt,double] (\lw,0) -- ++(4mm,0);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/double:distance:between:line:centers",
         meta = "⟨dimension⟩"
      },
      ["double equal sign distance"] = {
         details = [[
This style selects a double line distance such that it corresponds to
the distance of the two lines in an equal sign.

    \Huge $=\implies$\tikz[baseline,double equal sign distance]
                        \draw[double,thick,-{Implies[]}](0,0.55ex) --++(3ex,0);

    \normalsize $=\implies$\tikz[baseline,double equal sign distance]
                              \draw[double,-{Implies[]}](0,0.6ex) --++(3ex,0);

    \tiny $=\implies$\tikz[baseline,double equal sign distance]
                       \draw[double,very thin,-{Implies[]}](0,0.5ex) -- ++(3ex,0);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/double:equal:sign:distance"
      },
      draw = {
         details = [[
Causes the path to be drawn. "Drawing" (also known as "stroking") can be
thought of as picking up a pen and moving it along the path, thereby
leaving "ink" on the canvas.

There are numerous parameters that influence how a line is drawn, like
the thickness or the dash pattern. These options are explained below.

If the optional ⟨color⟩ argument is given, drawing is done using the
given ⟨color⟩. This color can be different from the current filling
color, which allows you to draw and fill a path with different colors.
If no ⟨color⟩ argument is given, the last usage of the color= option is
used.

If the special color name none is given, this option causes drawing to
be "switched off". This is useful if a style has previously switched on
drawing and you locally wish to undo this effect.

Although this option is normally used on paths to indicate that the path
should be drawn, it also makes sense to use the option with a {scope} or
{tikzpicture} environment. However, this will not cause all paths to be
drawn. Instead, this just sets the ⟨color⟩ to be used for drawing paths
inside the environment.

    \begin{tikzpicture}
      \path[draw=red] (0,0) -- (1,1) -- (2,1) circle (10pt);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/draw",
         meta = "⟨color⟩"
      },
      ["draw opacity"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/draw:opacity",
         meta = "⟨value⟩"
      },
      ["drop shadow"] = {
         details = [[
This option adds a drop shadow to a \path or a node. It uses the
general shadow and passes the ⟨shadow options⟩ to it, plus, before them,
the following extra options:

      shadow scale=1, shadow xshift=.5ex, shadow yshift=-.5ex,
      opacity=.5, fill=black!50, every shadow

    \tikz [even odd rule]
      \filldraw [drop shadow,fill=white] (0,0) circle (.5) (0.5,0) circle (.5);

    \begin{tikzpicture}
      \foreach \i in {1,...,4}
        \node[starburst,drop shadow,fill=white,draw] at (0,\i) {Burst \i};
    \end{tikzpicture}

    \begin{tikzpicture}
      \draw [help lines] (0,0) grid (3,2);
      \filldraw [drop shadow={opacity=1},fill=white]
        (1,2)  circle (.5) (1.5,2)  circle (.5);

      \filldraw [drop shadow={opacity=0.25},fill=white]
        (1,.5) circle (.5) (1.5,.5) circle (.5);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/drop:shadow",
         meta = "⟨shadow options⟩"
      },
      ["edge from parent"] = {
         details = [[
This style is inserted right before the edge from parent path and before
the ⟨options⟩ are inserted.

    \begin{tikzpicture}
      [edge from parent/.style={draw,red,thick}]
      \node {root}
        child {node {left} edge from parent[dashed]}
        child {node {right}
          child {node {child}}
          child {node {child} edge from parent[draw=none]}
        };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/edge:from:parent"
      },
      ["edge from parent fork down"] = {
         details = [[
This style will draw a line from the parent downwards (for half the
level distance) and then on to the child using only horizontal and
vertical lines.

    \begin{tikzpicture}
      \node {root}
        [edge from parent fork down]
        child {node {left}}
        child {node {right}
          child[child anchor=north east] {node {child}}
          child {node {child}}
        };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/edge:from:parent:fork:down"
      },
      ["edge from parent fork left"] = {
         details = [[
Behaves similarly to the previous styles.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/edge:from:parent:fork:left"
      },
      ["edge from parent fork right"] = {
         details = [[
This style behaves similarly, only it will first draw its edge to the
right.

    \begin{tikzpicture}
      \node {root}
        [edge from parent fork right,grow=right]
        child {node {left}}
        child {node {right}
          child {node {child}}
          child {node {child}}
        };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/edge:from:parent:fork:right"
      },
      ["edge from parent fork up"] = {
         details = [[
Behaves similarly to the previous styles.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/edge:from:parent:fork:up"
      },
      ["edge from parent macro"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/edge:from:parent:macro",
         meta = "⟨macro⟩"
      },
      ["edge from parent path"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/edge:from:parent:path",
         meta = "⟨path⟩"
      },
      ["edge label"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/edge:label",
         meta = "⟨text⟩"
      },
      ["edge label'"] = {
         details = [[
A shorthand for edge node={node[auto,swap]{⟨text⟩}}.

    \tikz \draw (0,0) to [edge label=x, edge label'=y] (3,2);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/edge:label'",
         meta = "⟨text⟩"
      },
      ["edge node"] = {
         details = [[
This key can be used inside the ⟨options⟩ of a to path command. It will
add the ⟨node specification⟩ to the list of nodes to be placed on the
connecting line, just as if you had written the ⟨node specification⟩
directly after the to keyword:

    \begin{tikzpicture}
      \draw (0,0) to [edge node={node [sloped,above] {x}}] (3,2);

      \draw (0,0) to [out=90,in=180,
                      edge node={node [sloped,above] {x}}] (3,2);
    \end{tikzpicture}

This key is mostly useful to create labels automatically using other
keys.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/edge:node",
         meta = "⟨node specification⟩"
      },
      ["end angle"] = {
         details = [[
Sets the end angle.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/end:angle",
         meta = "⟨degrees⟩"
      },
      entity = {
         details = [[
This style is to be used with nodes that represent entity types. It
causes the node's shape to be set to a rectangle that is drawn and whose
minimum size and width are set to sensible values.

Note that this style is called entity despite the fact that it is to be
used for nodes representing entity types (the difference between an
entity and an entity type is the same as the difference between an
object and a class in object-oriented programming). If this bothers you,
feel free to define a style entity type instead.

    \begin{tikzpicture}
      \node[entity] (sheep)                   {Sheep};
      \node[entity] (genome) [right=of sheep] {Genome};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/entity"
      },
      evaluate = {
         details = [[
This key simply executes \tikzmath{⟨statements⟩}.

    \tikz[x=0.25cm,y=0.25cm,
      evaluate={
        int \i, \j;
        for \i in {0,...,10} {
          for \j in {0,...,10} {
            \a{\i,\j} = (\i+\j)*5;
          };
        };
      }
    ]
    \foreach \i in {0,...,10}
      \foreach \j in {0,...,10}
        \fill [red!\a{\i,\j}!yellow]  (\i,\j) rectangle ++(1, 1);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/evaluate",
         meta = "{⟨statements⟩}"
      },
      ["even odd rule"] = {
         details = [[
This option causes a different method to be used for determining the
inside and outside of paths. While it is less flexible, it turns out to
be more intuitive.

With this method, we also shoot rays from the point for which we wish to
determine whether it is inside or outside the filling area. However,
this time we only count how often we "hit" the path and declare the
point to be "inside" if the number of hits is odd.

Using the even-odd rule, it is easy to "drill holes" into a path.

    \begin{tikzpicture}
      \filldraw[fill=yellow!80!black,even odd rule]
        (0,0) rectangle (1,1) (0.5,0.5) circle (0.4cm);
      \draw[->] (0.5,0.5) -- +(0,1) [above] node{crossings: $1+1 = 2$};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/even:odd:rule"
      },
      ["every above delimiter"] = {
         details = [[
Works as above.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:above:delimiter"
      },
      ["every accepting by arrow"] = {
         details = [[
Executed at the beginning of every path that contains the arrow and the
text.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:accepting:by:arrow"
      },
      ["every annotation"] = {
         details = [[
This style is included by annotation.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:annotation"
      },
      ["every attribute"] = {
         details = [[
This style is used with every attribute, and therefore also for every
key attribute.

    \begin{tikzpicture}
      [text depth=1pt,
       every attribute/.style={fill=black!20,draw=black},
       every entity/.style={fill=blue!20,draw=blue,thick},
       every relationship/.style={fill=orange!20,draw=orange,thick,aspect=1.5}]

      \node[entity] (sheep)  at (0,0)   {Sheep}
        child {node  [key attribute] {name}};
      \node[entity] (genome) at (2,0)   {Genome};
      \node[relationship]    at (1,1.5) {has}
        edge (sheep)
        edge (genome);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:attribute"
      },
      ["every below delimiter"] = {
         details = [[
Works as above.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:below:delimiter"
      },
      ["every calendar"] = {
         details = [[
This style is used with every calendar.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:calendar"
      },
      ["every cell"] = {
         details = [[
This style is installed at the beginning of each cell picture with the
two parameters being the current ⟨row⟩ and ⟨column⟩ of the cell. Note
that setting this style to draw will not cause all nodes to be drawn
since the draw option has to be passed to each node individually.

Inside this style (and inside all cells), the current ⟨row⟩ and ⟨column⟩
number are also accessible via the counters \pgfmatrixcurrentrow and
\pgfmatrixcurrentcolumn.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:cell",
         meta = "{row}{column}"
      },
      ["every child"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:child"
      },
      ["every child node"] = {
         details = [[
This style is used at the beginning of each child node in addition to
the every node style.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:child:node"
      },
      ["every circle"] = {
         details = [[
You can use this key to set up, say, a default radius for every circle.
The key will also be used with the ellipse operation.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:circle"
      },
      ["every circle connection bar"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:circle:connection:bar"
      },
      ["every circuit ee"] = {
         details = [[
Use this key to configure the appearance of logical circuits.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:circuit:ee"
      },
      ["every circuit logic"] = {
         details = [[
Use this key to configure the appearance of logical circuits.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:circuit:logic"
      },
      ["every circuit symbol"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:circuit:symbol"
      },
      ["every concept"] = {
         details = [[
In order to change the appearance of concept nodes, you should change
this style. Note, however, that the color of a concept should be uniform
for some of the connection bar stuff to work, so you should not change
the color or the draw/fill state of concepts using this option. It is
mostly useful for changing the text color and font.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:concept"
      },
      ["every cut"] = {
         details = [[
Executed for every line that should be cut using scissors.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:cut"
      },
      ["every data"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:data"
      },
      ["every day"] = {
         details = [[
This style is executed by the default node code for each day. The
every day style is useful for changing the way days look. For example,
let us make all days red:

    \tikz[every day/.style=red]
      \calendar[dates=2000-01-01 to 2000-01-31,week list];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:day"
      },
      ["every delimiter"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:delimiter"
      },
      ["every edge"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:edge"
      },
      ["every edge quotes"] = {
         details = [[
This style is auto by default, which causes labels specified using the
quotes-syntax to be placed next to the edges. Unless the setting of auto
has been changed, they will be placed to the left.

    \tikz \draw (0,0) edge ["left", ->] (2,0);

In order to place all labels to the right by default, change this style
to auto=right:

    \tikz [every edge quotes/.style={auto=right}]
      \draw (0,0) edge ["right", ->] (2,0);

To place all nodes "on" the edge, just make this style empty (and,
possibly, make your labels opaque):

    \tikz [every edge quotes/.style={fill=white,font=\footnotesize}]
      \draw (0,0) edge ["mid", ->] (2,1);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:edge:quotes"
      },
      ["every entity"] = {
         details = [[
This style is evoked by the style entity. To change the appearance of
entities, you can change this style.

    \begin{tikzpicture}
      [every entity/.style={draw=blue!50,fill=blue!20,thick}]
      \node[entity] (sheep)                   {Sheep};
      \node[entity] (genome) [right=of sheep] {Genome};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:entity"
      },
      ["every even column"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:even:column"
      },
      ["every even row"] = {
         details = [[
This style is used for every cell in an even row.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:even:row"
      },
      ["every extra concept"] = {
         details = [[
Change this style to change the appearance of extra concepts.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:extra:concept"
      },
      ["every fit"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:fit"
      },
      ["every fold"] = {
         details = [[
Executed for every line that should be folded.

    \tikz \pic[
      every cut/.style=red,
      every fold/.style=dotted,
      folding line length=6mm
    ] { tetrahedron folding };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:fold"
      },
      ["every info"] = {
         details = [[
Set this style to configure the styling of info labels. Since this key
is not used with normal labels, it provides an easy way of changing the
way info labels look without changing other labels.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:info"
      },
      ["every initial by arrow"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:initial:by:arrow"
      },
      ["every join"] = {
         details = [[
This style is executed each time this command is used.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:join"
      },
      ["every label"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:label"
      },
      ["every label quotes"] = {
         details = [[
    \tikz [every label quotes/.style=red]
      \node ["90:$90^\circ$", "left:$180^\circ$", circle, draw] {circle};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:label:quotes"
      },
      ["every left delimiter"] = {
         details = [[
This style is additionally executed for every left delimiter.

    \begin{tikzpicture}
      [every left delimiter/.style={red,xshift=1ex},
       every right delimiter/.style={xshift=-1ex}]
      \matrix [matrix of math nodes,left delimiter=(,right delimiter=\}]
      {
        a_8 & a_1 & a_6 \\
        a_3 & a_5 & a_7 \\
        a_4 & a_9 & a_2 \\
      };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:left:delimiter"
      },
      ["every loop"] = {
         details = [[
This style is installed at the beginning of every loop.

    \begin{tikzpicture}[every loop/.style={}]
      \draw (0,0) to [loop above] () to [loop right] ()
                  to [loop below] () to [loop left]  ();
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:loop"
      },
      ["every mark"] = {
         details = [[
This style is installed before drawing plot marks. For example, you can
scale (or otherwise transform) the plot mark or set its color.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:mark"
      },
      ["every matrix"] = {
         details = [[
This style is used in every matrix.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:matrix"
      },
      ["every mindmap"] = {
         details = [[
This style is included by the mindmap style. Change this style to add
special settings to your mindmaps.

    \tikz[large mindmap,concept color=red!50]
      \node [concept] {Root concept}
        child[grow=right] {node[concept] {Child concept}};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:mindmap"
      },
      ["every month"] = {
         details = [[
This style can be used to change the appearance of month labels.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:month"
      },
      ["every new --"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:new:--"
      },
      ["every new ->"] = {
         details = [[
This key gets executed by default for a new ->.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:new:->"
      },
      ["every new <-"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:new:<-"
      },
      ["every new <->"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:new:<->"
      },
      ["every node"] = {
         details = [[
This style is installed at the beginning of every node.

    \begin{tikzpicture}[every node/.style={draw}]
      \draw (0,0) node {A} -- (1,1) node {B};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:node"
      },
      ["every odd column"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:odd:column"
      },
      ["every odd row"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:odd:row"
      },
      ["every on background layer"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:on:background:layer"
      },
      ["every on chain"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:on:chain"
      },
      ["every outer matrix"] = {
         details = [[
While the every matrix key also applies to the matrix contents, this
only applies to the outer node which holds the matrix.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:outer:matrix"
      },
      ["every path"] = {
         details = [[
This style is installed at the beginning of every path. This can be
useful for (temporarily) adding, say, the draw option to everything in a
scope.

    \begin{tikzpicture}
      [fill=yellow!80!black,      % only sets the color
       every path/.style={draw}]  % all paths are drawn
      \fill  (0,0) rectangle +(1,1);
      \shade (2,0) rectangle +(1,1);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:path"
      },
      ["every pic"] = {
         details = [[
This style is installed at the beginning of every pic.

     (0,0) to [bend left] (3mm,0);
      },
    }}]
    \begin{tikzpicture}[every pic/.style={scale=2,transform shape}]
      \pic foreach \x in {1,2,3} at (\x,0) {seagull};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:pic"
      },
      ["every pic quotes"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:pic:quotes"
      },
      ["every picture"] = {
         details = [[
This style is installed at the beginning of each picture.

    \tikzset{every picture/.style=semithick}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:picture"
      },
      ["every pin"] = {
         details = [[
This style is used in every node created by the pin option.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:pin"
      },
      ["every pin edge"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:pin:edge"
      },
      ["every pin quotes"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:pin:quotes"
      },
      ["every place"] = {
         details = [[
This style is evoked by the style place. To change the appearance of
places, you can change this style.

    \begin{tikzpicture}
      [every place/.style={draw=blue,fill=blue!20,thick,minimum size=9mm}]
      \node[place,tokens=7,label=above:$p_1$]  (p1) {};
      \node[place,structured tokens={3,2,9},
            label=below:$p_2\ge1$,right=of p1] (p2) {};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:place"
      },
      ["every plot"] = {
         details = [[
This style is installed in each plot, that is, as if you always said

      plot[every plot,...]

This is most useful for globally setting a prefix for all plots by
saying:

    \tikzset{every plot/.style={prefix=plots/}}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:plot"
      },
      ["every relationship"] = {
         details = [[
Works like every entity.

    \begin{tikzpicture}
      [every entity/.style={fill=blue!20,draw=blue,thick},
       every relationship/.style={fill=orange!20,draw=orange,thick,aspect=1.5}]
      \node[entity] (sheep)  at (0,0)   {Sheep};
      \node[entity] (genome) at (2,0)   {Genome};
      \node[relationship]    at (1,1.5) {has}
        edge (sheep)
        edge (genome);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:relationship"
      },
      ["every right delimiter"] = {
         details = [[
Works as above.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:right:delimiter"
      },
      ["every scope"] = {
         details = [[
This style is installed at the beginning of every scope.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:scope"
      },
      ["every shadow"] = {
         details = [[
This style is executed in addition to any ⟨shadow options⟩ for each
shadow. Use this style to reconfigure the way shadows are drawn.

    \begin{tikzpicture}[every shadow/.style={opacity=.8,fill=blue!50!black}]
      \filldraw [drop shadow,fill=white] (0,0) circle (.5) (0.5,0) circle (.5);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:shadow"
      },
      ["every spy in node"] = {
         details = [[
This style is used with every spy-in node.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:spy:in:node"
      },
      ["every spy on node"] = {
         details = [[
This style is used with every spy-on node.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:spy:on:node"
      },
      ["every state"] = {
         details = [[
This style is used by state with output and also by
state without output. By default, it does nothing, but you can use it to
make your state look more fancy:

    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,>={Stealth[round]},
        every state/.style={draw=blue!50,very thick,fill=blue!20}]

      \node[state,initial]  (q_0)                      {$q_0$};
      \node[state]          (q_1) [above right=of q_0] {$q_1$};
      \node[state]          (q_2) [below right=of q_0] {$q_2$};

      \path[->] (q_0) edge              node [above left]  {0} (q_1)
                      edge              node [below left]  {1} (q_2)
                (q_1) edge [loop above] node               {0} ()
                (q_2) edge [loop below] node               {1} ();
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:state"
      },
      ["every subgraph node"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:subgraph:node"
      },
      ["every to"] = {
         details = [[
This style is installed at the beginning of every to.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:to"
      },
      ["every token"] = {
         details = [[
Change this style to change the appearance of tokens.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:token"
      },
      ["every transition"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:transition"
      },
      ["every year"] = {
         details = [[
Works like every month, only for years.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:year"
      },
      ["every ⟨part name⟩ node part"] = {
         details = [[
This style is installed at the beginning of every node part named ⟨part
name⟩.

    \tikz [every lower node part/.style={red}]
      \node [circle split,draw] {$q_1$ \nodepart{lower} $00$};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:⟨part:name⟩:node:part"
      },
      ["every ⟨shape⟩ node"] = {
         details = [[
These styles are installed at the beginning of a node of a given
⟨shape⟩. For example, every rectangle node is used for rectangle nodes,
and so on.

    \begin{tikzpicture}
      [every rectangle node/.style={draw},
       every circle node/.style={draw,double}]
      \draw (0,0) node[rectangle] {A} -- (1,1) node[circle] {B};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/every:⟨shape⟩:node"
      },
      ["execute after day scope"] = {
         details = [[
This is executed at the very end of the current date, outside the scope.
The accumulation is also in reverse.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/execute:after:day:scope",
         meta = "⟨code⟩"
      },
      ["execute at begin cell"] = {
         details = [[
The code will be executed at the beginning of each nonempty cell.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:begin:cell",
         meta = "⟨code⟩"
      },
      ["execute at begin day scope"] = {
         details = [[
This code is execute before everything else inside the scope of the
current date. Again, the effect is accumulative.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:begin:day:scope",
         meta = "⟨code⟩"
      },
      ["execute at begin node"] = {
         details = [[
This option causes ⟨code⟩ to be executed at the beginning of a node.
Using this option multiple times will cause the code to accumulate.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:begin:node",
         meta = "⟨code⟩"
      },
      ["execute at begin picture"] = {
         details = [[
This option causes ⟨code⟩ to be executed at the beginning of the
picture. This option must be given in the argument of the {tikzpicture}
environment itself since this option will not have an effect otherwise.
After all, the picture has already "started" later on. The effect of
multiply setting this option accumulates.

This option is mainly used in styles like the every picture style to
execute certain code at the start of a picture.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:begin:picture",
         meta = "⟨code⟩"
      },
      ["execute at begin scope"] = {
         details = [[
This option install some code that will be executed at the beginning of
the scope. This option must be given in the argument of the {scope}
environment.

The effect applies only to the current scope, not to subscopes.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:begin:scope",
         meta = "⟨code⟩"
      },
      ["execute at begin to"] = {
         details = [[
The ⟨code⟩ is executed prior to the to. This can be used to draw one or
more additional paths or to do additional computations.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:begin:to",
         meta = "⟨code⟩"
      },
      ["execute at empty cell"] = {
         details = [[
The code will be executed inside each empty cell.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:empty:cell",
         meta = "⟨code⟩"
      },
      ["execute at end cell"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:end:cell",
         meta = "⟨code⟩"
      },
      ["execute at end day scope"] = {
         details = [[
This code is executed just before the day scope is closed. The effect is
also accumulative, however, in reverse order. This is useful to pair,
say, \scope and \endscope commands in at-begin- and at-end-code.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:end:day:scope",
         meta = "⟨code⟩"
      },
      ["execute at end node"] = {
         details = [[
This option installs ⟨code⟩ that will be executed at the end of the
node. Using this option multiple times will cause the code to
accumulate.

    \begin{tikzpicture}
      [execute at begin node={A},
       execute at end node={D}]
      \node[execute at begin node={B}] {C};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:end:node",
         meta = "⟨code⟩"
      },
      ["execute at end picture"] = {
         details = [[
This option installs ⟨code⟩ that will be executed at the end of the
picture. Using this option multiple times will cause the code to
accumulate. This option must also be given in the optional argument of
the {tikzpicture} environment.

    \begin{tikzpicture}[execute at end picture=%
      {
        \begin{pgfonlayer}{background}
          \path[fill=yellow,rounded corners]
            (current bounding box.south west) rectangle
            (current bounding box.north east);
        \end{pgfonlayer}
      }]
      \node at (0,0) {X};
      \node at (2,1) {Y};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:end:picture",
         meta = "⟨code⟩"
      },
      ["execute at end scope"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:end:scope",
         meta = "⟨code⟩"
      },
      ["execute at end to"] = {
         details = [[
Works like the previous option, only this code is executed after the to
path has been added.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/execute:at:end:to",
         meta = "⟨code⟩"
      },
      ["execute before day scope"] = {
         details = [[
The ⟨code⟩ is executed before everything else for each date. Multiple
calls of this option have an accumulative effect. Thus, if you use this
option twice, the code from the first use is used first for each day,
followed by the code given the second time.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/execute:before:day:scope",
         meta = "⟨code⟩"
      },
      ["external/aux in dpth"] = {
         details = [[
Allows to enable or disable the feature which handles references and
labels as part of image externalization. Disabling it will safe one
\newwrite command, i.e. a write register.

Also see the disable dependency files feature.

Here are some implementation details on how references within/from
external graphics work for those who would like to know the details:

For point a), a \ref inside of an externalized graphics works by reading
the main document's .aux file. To this end, the standard
mode=convert with system call detects such references and reschedules
the externalization to \end{document}.[1] Other values of mode require
just one attempt to externalize the picture.

Note that \pageref is not supported (sorry).

Point b) works as follows: a \label inside of an externalized graphics
causes the external library to generate separate auxiliary files for
every external image. These files are called ⟨imagename⟩.dpth. The
extension .dpth indicates that the file also contains the image's depth
(the baseline key of TikZ). Furthermore, anything which would have been
written to an .aux file will be redirected to the .dpth file -- but only
things which occur inside of the externalized tikzpicture environment.
When the main document loads the image, it will copy the .dpth file into
the main .aux file. Then, successive compilations of the main document
contain the external \label information. In other words, a \label in an
external graphics needs the following work flow:

1.  The external graphics needs to be generated together with its .dpth
    (usually automatically by TikZ).

2.  The main document includes the external graphics and copies the
    .dpth content into its main .aux file.

3.  The main document needs to be translated once again to re-read its
    .aux file[2].

This does also work if a \label/\ref combination is implemented itsself
by a tikzpicture (a feature offered by pgfplots).

[1] Note that this requires the atveryend package. The purpose to
reschedule the externalization is to access the main job's aux file, but
only after it has been written completely.

[2] Note that it is not possible to activate the content of an auxiliary
file after \ begin{document} in LaTeX.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/aux:in:dpth",
         meta = "{boolean}"
      },
      ["external/disable dependency files"] = {
         details = [[
Allows to (irreversibly) disable the generation of file dependencies.
Disabling it will safe one \newwrite command, i.e. a write register.
Note that the write register is only allocated if the feature has been
used at all. This key needs to be provided as argument to
\tikzexternalize (or it needs to be set before calling
\tikzexternalize).

Also see the aux in dpth key.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/disable:dependency:files"
      },
      ["external/export"] = {
         details = [[
A boolean which can be used to disable the export mechanism for all
pictures inside of the current TeX-scope.

    \begin{document}
    \begin{tikzpicture} % will be exported
        ...
    \end{tikzpicture}

    {
    \tikzset{external/export=false}
    \begin{tikzpicture} % won't be exported
        ...
    \end{tikzpicture}
    ...
    }

    \begin{tikzpicture} % will be exported
        ...
    \end{tikzpicture}
    \end{document}

For LaTeX, the feature lasts until the next \end{\cdot} (this holds for
every call to \tikzset).
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/export",
         meta = "{boolean}"
      },
      ["external/export next"] = {
         details = [[
A boolean which can be used to disable the export mechanism for single
pictures.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/export:next",
         meta = "{boolean}"
      },
      ["external/figure list"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/figure:list",
         meta = "{boolean}"
      },
      ["external/figure name"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/figure:name",
         meta = "{name}"
      },
      ["external/force remake"] = {
         details = [[
A boolean which is used to customize the up-to-date checks of all
following figures. Every up-to-date check will fail, resulting in
automatic regeneration of every following figure.

    \tikzset{external/force remake}
    \begin{tikzpicture}
        \draw (0,0) circle(5pt);
    \end{tikzpicture}

You can also use force remake inside of a local TeX group to remake only
selected pictures. The example

    \tikz \draw (0,0) -- (1,1);

    {
    \tikzset{external/force remake}
    \begin{tikzpicture}
       \draw (0,0) circle(5pt);
    \end{tikzpicture}
    }

    \tikz \draw (0,0) -- (1,1);

will only apply force remake to the second figure.

Up-to-date checks are applied for mode=convert with system call and the
makefile generated by mode=list and make.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/force:remake",
         meta = "{boolean}"
      },
      ["external/mode"] = {
         details = [[
Configures what to do with TikZ pictures (unless we are currently
externalizing one particular image, in that case, these modes are
ignored).

The preconfigured mode convert with system call checks whether external
graphics files are up-to-date and includes them if that is the case. Any
picture which is not up-to-date will be generated automatically using a
system call. The system call can be configured using the system call
template. The up-to-date check is applied according to the
up to date check key. As soon as convert with system call is set, the
figure list will be disabled -- such a file is not required. In case you
still need or want it, you can enable it after setting mode.

Please note that system calls may be disabled for security reasons. For
pdflatex, they can be enabled using

    pdflatex -shell-escape

while other TeX variants may need other switches. The feature is
sometimes called \write18.

The choice only graphics always tries to replace pictures with external
graphics. It is an error if the graphics file does not exist.

The choice no graphics (or, equivalently, only pictures) typesets
TikZ pictures without checking for external graphics.

A mixture is graphics if exists, it checks whether a suitable graphics
file exists and includes it if that is the case. If it does not exist,
the picture is typeset using TeX.

Mode list only skips every TikZ picture; it only generates the file
{main file}.figlist containing file names for every picture, the
contents of any picture environment is thrown away and a replacement
text is shown. This implies figure list=true. See also the list and make
mode which includes available graphics.

The mode list and make is similar to list only: it generates the same
file {main file}.figlist, but any images which exist already are
included as graphics instead of ignoring them. Furthermore, this mode
generates an additional file: {main file}.makefile. This allows to use a
work flow like

    % step 1: generate main.makefile:
    pdflatex main
    % step 2: generate ALL graphics on 2 processors:
    make -j 2 -f main.makefile
    % step 3: include the graphics:
    pdflatex main

This last make method is optional: list and make just assumes that
images are generated somehow (not necessarily with the generated
makefile). The generated makefile allows parallel externalization of
graphics on multi-core systems and it supports any file dependencies
configured with \tikzpicturedependsonfile. Furthermore, it respects the
force remake and remake next keys.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/mode",
         meta = "{choice}"
      },
      ["external/only named"] = {
         details = [[
If enabled, only pictures for which file names have been set explicitly
using \tikzsetnextfilename will be considered, no file names will be
generated automatically.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/only:named",
         meta = "{boolean}"
      },
      ["external/optimize"] = {
         details = [[
Configures whether the conversion process shall be optimized. This
affects only the case when \jobname differs from the main file name,
i.e. when single pictures are converted.

In that case, the main file is compiled as usual -- but everything
except the selected picture is thrown away. If optimization is enabled,
all other pictures won't be processed at all. Furthermore, expensive
commands which do not contribute to the selected picture will be thrown
away as well.

The default implementation discards \includegraphics commands which are
not inside of the selected picture to reduce conversion time.

It is possible to add commands which shall be optimized away, see below.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/optimize",
         meta = "{boolean}"
      },
      ["external/optimize command away"] = {
         details = [[
Installs commands to optimize ⟨\command⟩ away. As is described above,
optimization applies to the case when single pictures are converted: one
usually doesn't need to process (probably expensive) commands which do
not contribute to the selected picture.

The argument {required argument count} is either empty or a non-negative
integer between $0$ and $9$. It denotes the number of arguments which
should be consumed after ⟨\command⟩. In any case, one argument in square
brackets after the command will be recognized as well. To be more
precise, the following cases for arguments of ⟨\command⟩ are supported:

1.  If {required argument count} is empty (the default), ⟨\command⟩ may
    take one optional argument in square brackets and one in curly
    braces (which is also optional).

2.  If {required argument count} is not empty, {\command} may take one
    optional argument in square brackets. Furthermore, it expects
    exactly {required argument count} following arguments.

Example:

    \tikzset{external/optimize command away=\includegraphics}

    \newcommand{\myExpensiveMacro}[1]{Very expensive!}

    \tikzset{external/optimize command away=\myExpensiveMacro}

    \newcommand{\myExpensiveMacroWithThreeArgs}[3]{Very expensive!}

    \tikzset{external/optimize command away={\myExpensiveMacroWithThreeArgs}{3}}

    % A command with optional argument:
    \newcommand{\aFurtherExample}[3][]{Very expensive!}

    % consume only two arguments: the first optional one will be processed
    % anyway:
    \tikzset{external/optimize command away={\myExpensiveMacroWithThreeArgs}{2}}

The argument ⟨\command⟩ must be the name of a single macro. Any
occurrence of this macro, together with its arguments, will be removed.

    \begin{tikzpicture}
        % this picture is currently converted!
    \end{tikzpicture}

    This here is outside of the converted picture and contains \myExpensiveMacro. It will be discarded.

    This call: \myExpensiveMacro[argument=value]{Argument} as well.
    And this here: \myExpensiveMacro{Argument} also.

The default is to optimize \includegraphics away.

This key is actually a style which sets the optimize/install and
optimize/restore keys.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/optimize:command:away",
         meta = "⟨\\command⟩{required argument count}"
      },
      ["external/optimize/install"] = {
         details = [[
A command key which contains code to install optimizations. You can
append code here (or clear the macro) if you need to modify the
optimization.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/optimize/install"
      },
      ["external/optimize/restore"] = {
         details = [[
A command key which contains code to undo optimizations. You can append
code here (or clear the macro) if you need to modify the optimization.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/optimize/restore"
      },
      ["external/prefix"] = {
         details = [[
A shortcut for \tikzsetexternalprefix{file name prefix}, see below.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/prefix",
         meta = "{file name prefix}"
      },
      ["external/remake next"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/remake:next",
         meta = "{boolean}"
      },
      ["external/shell escape"] = {
         details = [[
Contains the command line option for latex which enables the \write18
feature. For TeX-Live, this is -shell-escape. For MiKTeX, you should use
\tikzexternalize[shell escape=-enable-write18].
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/shell:escape",
         meta = "{command-line arg}"
      },
      ["external/system call"] = {
         details = [[
[extlib:systemcall:option] A template string used to generate system
calls. Inside of {template}, the macro \image can be used as placeholder
for the image which is about to be generated while \texsource contains
the main file name (in truth, it contains \input{main file name}, but
that doesn't matter).

The default depends on the value of \pgfsysdriver. For
pgfsys-pdftex.def, it is

    \tikzset{external/system call={pdflatex \tikzexternalcheckshellescape -halt-on-error
        -interaction=batchmode -jobname "\image" "\texsource"}}

where \tikzexternalcheckshellescape inserts the value of the
configuration key shell escape if and only if the current document has
been typeset with -shell-escape[1].

Other drivers result in slightly different calls. There is support for
lualatex, xelatex, and dvips. The precise values are written to the .log
file as soon as you attempt to compile a document.

The argument {template} will be expanded using \edef, so any control
sequences will be expanded. During this evaluation, '\\' will result in
a normal backslash, '\'. Furthermore, double quotes '"', single quotes
'’', semicolons and dashes '-' will be made to normal characters if any
package uses them as macros. This ensures compatibility with the german
package, for example.

[1] Note that this is always true for the default configuration. This
security consideration applies mainly for mode=list and make which will
also work without shell escapes.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/system:call",
         meta = "{template}"
      },
      ["external/up to date check"] = {
         details = [[
The external lib has to decide when some existing figure is up-to-date.
In such a case, it can be used without remaking it. Outdated pictures
will be remade.

The key up to date check allows to choose among a couple of heuristics
which are supposed to catch the most important reasons to remake a
figure.

The up to date check can be overrule by any of the force remake or
remake next keys: if one of them is true, the figure is not up-to-date.

The choice simple is based on the existence of the file: the file is
up-to-date if and only if it exists.

The choice md5 generates an MD5 checksum of the picture for which the
up-to-date check is running. The MD5 is compared against the MD5 of the
previous run, which, in turn, will be written into an extra file with
the extension .md5. This file will be modified if and only if the MD5
comparison indicates a difference. The MD5 computation is based on the
pdfTeX method \pdfmdfivesum. If it is unavailable for some reason, the
choice diff will be used instead.

The choice diff is the same as MD5 -- except that it compares the
picture content as-is instead of a hash. The .md5 file will be used to
compare an old version with the current one -- but its content is some
"normalized" version of the picture for internal use.

Attention:

the content--based strategies md5 and diff operate on the picture
content -- and only on the picture content. Here, "picture content" only
includes the top--level tokens; no expansion is applied and no included
files are part of the strategies. If you change preamble styles, you
have to rebuild the figures manually (for example by deleting the
generated graphics files). If you have include files, consider using
\tikzpicturedependsonfile and its variants. Since this key provides
heuristics, you should always remake your figures before you finally
publish your document. Example: Suppose we have the following picture
which depends on a command \mycommand:

    \def\mycommand{My comment}

    \begin{tikzpicture}

    \node at (0,0) {\mycommand};

    \end{tikzpicture}

What happens if you change "My comment" to "My super comment"? Well,
external will not pick it up; you will need to handle this manually.
However, if you modify anything between \begin{tikzpicture} and
\end{tikzpicture}, the external library will pick it up and regenerate
the picture.

The up to date check is applied for mode=convert with system call and
mode=list and make.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/up:to:date:check",
         meta = "{choice}"
      },
      ["external/verbose"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/verbose",
         meta = "{boolean}"
      },
      ["external/verbose IO"] = {
         details = [[
A boolean which configures whether I/O operations shall be listed in the
logfile.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/verbose:IO",
         meta = "{boolean}"
      },
      ["external/verbose optimize"] = {
         details = [[
A boolean which configures whether optimization operations shall be
listed in the logfile.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/external/verbose:optimize",
         meta = "{boolean}"
      },
      ["extra concept"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/extra:concept"
      },
      ["face 1"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/face:1",
         meta = "⟨code⟩"
      },
      ["face 2"] = {
         details = [[
Same as face 1, but for the second face.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/face:2",
         meta = "⟨code⟩"
      },
      ["face 3"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/face:3",
         meta = "⟨code⟩"
      },
      ["face 4"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/face:4",
         meta = "⟨code⟩"
      },
      ["fading angle"] = {
         details = [[
A shortcut for fading transform={rotate=⟨degree⟩}.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/fading:angle",
         meta = "⟨degree⟩"
      },
      ["fading transform"] = {
         details = [[
The ⟨transformation options⟩ are applied to the fading before it is
used. For instance, if ⟨transformation options⟩ is set to rotate=90, the
fading is rotated by 90 degrees.

    \begin{tikzpicture}[path fading=fade down]
      % Checker board
      \fill [black!20] (0,0) rectangle (4,1.5);
      \path [pattern=checkerboard,pattern color=black!30] (0,0) rectangle (4,1.5);

      \fill [red,path fading,fading transform={rotate=90}]
        (1,0.75) ellipse (.75 and .5);
      \fill [red,path fading,fading transform={rotate=30}]
        (3,0.75) ellipse (.75 and .5);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/fading:transform",
         meta = "⟨transformation options⟩"
      },
      fill = {
         details = [[
This option causes the path to be filled. All unclosed parts of the path
are first closed, if necessary. Then, the area enclosed by the path is
filled with the current filling color, which is either the last color
set using the general color= option or the optional color ⟨color⟩. For
self-intersection paths and for paths consisting of several closed
areas, the "enclosed area" is somewhat complicated to define and two
different definitions exist, namely the nonzero winding number rule and
the even odd rule, see the explanation of these options, below.

Just as for the draw option, setting ⟨color⟩ to none disables filling
locally.

    \begin{tikzpicture}
      \fill (0,0) -- (1,1) -- (2,1);
      \fill (4,0) circle (.5cm)  (4.5,0) circle (.5cm);
      \fill[even odd rule] (6,0) circle (.5cm)  (6.5,0) circle (.5cm);
      \fill (8,0) -- (9,1) -- (10,0) circle (.5cm);
    \end{tikzpicture}

If the fill option is used together with the draw option (either because
both are given as options or because a \filldraw command is used), the
path is filled first, then the path is drawn second. This is especially
useful if different colors are selected for drawing and for filling.
Even if the same color is used, there is a difference between this
command and a plain fill: A "filldrawn" area will be slightly larger
than a filled area because of the thickness of the "pen".

    \begin{tikzpicture}[fill=yellow!80!black,line width=5pt]
      \filldraw (0,0) -- (1,1) -- (2,1);
      \filldraw (4,0) circle (.5cm)  (4.5,0) circle (.5cm);
      \filldraw[even odd rule] (6,0) circle (.5cm)  (6.5,0) circle (.5cm);
      \filldraw (8,0) -- (9,1) -- (10,0) circle (.5cm);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/fill",
         meta = "⟨color⟩"
      },
      ["fill opacity"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/fill:opacity",
         meta = "⟨value⟩"
      },
      fit = {
         details = [[
This option must be given to a node path command. The ⟨coordinates or
nodes⟩ should be a sequence of TikZ coordinates or node names, one
directly after the other without commas (like with the plot coordinates
path operation). Examples are (1,0) (2,2) or (a) (1,0) (b), where a and
b are nodes.

For this sequence of coordinates, a minimal bounding box is computed
that encompasses all the listed ⟨coordinates or nodes⟩. For coordinates
in the list, the bounding box is guaranteed to contain this coordinate,
for nodes it is guaranteed to contain the east, west, north and south
anchors of the node. In principle (the details will be explained in a
moment), things are now set up such that the text box of the node will
be exactly this bounding box.

Here is an example: We fit several points in a rectangular node. By
setting the inner sep to zero, we see exactly the text box of the node.
Then we fit these points again in a circular node. Note how the circle
encompasses exactly the same bounding box.

    \begin{tikzpicture}[inner sep=0pt,thick,
                        dot/.style={fill=blue,circle,minimum size=3pt}]
      \draw[help lines] (0,0) grid (3,2);
      \node[dot] (a) at (1,1) {};
      \node[dot] (b) at (2,2) {};
      \node[dot] (c) at (1,2) {};
      \node[dot] (d) at (1.25,0.25) {};
      \node[dot] (e) at (1.75,1.5) {};

      \node[draw=red,   fit=(a) (b) (c) (d) (e)] {box};
      \node[draw,circle,fit=(a) (b) (c) (d) (e)] {};
    \end{tikzpicture}

Every time the fit option is used, the following style is also applied
to the node:

The exact effects of the fit option are the following:

1.  A minimal bounding box containing all coordinates is computed. Note
    that if a coordinate like (a) is used that contains a node name,
    this has the same effect as explicitly providing the (a.north) and
    (a.south) and (a.west) and (a.east). If you wish to refer only to
    the center of the a node, use (a.center) instead.

2.  The text width option is set to the width of this bounding box.

3.  The align=center option is set.

4.  The anchor is set to center.

5.  The at position of the node is set to the center of the computed
    bounding box.

6.  After the node has been typeset, its height and depth are adjusted
    such that they add up to the height of the computed bounding box and
    such that the text of the node is vertically centered inside the
    box.

The above means that, generally speaking, if the node contains text like
box in the above example, it will be centered inside the box. It will be
difficult to put the text elsewhere, in particular, changing the anchor
of the node will not have the desired effect. Instead, what you should
do is to create a node with the fit option that does not contain any
text, give it a name, and then use normal nodes to add text at the
desired positions. Alternatively, consider using the label or pin
options.

Suppose, for instance, that in the above example we want the word "box"
to appear inside the box, but at its top. This can be achieved as
follows:

    \begin{tikzpicture}[inner sep=0pt,thick,
                        dot/.style={fill=blue,circle,minimum size=3pt}]
      \draw[help lines] (0,0) grid (3,2);
      \node[dot] (a) at (1,1) {};
      \node[dot] (b) at (2,2) {};
      \node[dot] (c) at (1,2) {};
      \node[dot] (d) at (1.25,0.25) {};
      \node[dot] (e) at (1.75,1.5) {};

      \node[draw=red,fit=(a) (b) (c) (d) (e)] (fit) {};
      \node[below] at (fit.north) {box};
    \end{tikzpicture}

Here is a real-life example that uses fitting:

    \begin{tikzpicture}
      [vertex/.style={minimum size=2pt,fill,draw,circle},
       open/.style={fill=none},
       sibling distance=1.5cm,level distance=.75cm,
       every fit/.style={ellipse,draw,inner sep=-2pt},
       leaf/.style={label={[name=#1]below:$#1$}},auto]

      \node [vertex] (root) {}
      child { node [vertex,open] {}
        child { node [vertex,open] {}
          child { node [vertex] (b's parent) {}
            child { node [vertex] {}
              child { node [vertex,leaf=d] {} }
              child { node [vertex,leaf=e] {} } }
            child { node [vertex,leaf=b] {} } }
          child { node [vertex,leaf=a] {} } }
        child { node [coordinate] {}
          child[missing]
          child { node [vertex] (f's parent) {}
            child { node [vertex,leaf=c] {} }
            child { node [vertex,leaf=f] {} } } }
        edge from parent node {$\rho$} };

      \node [fit=(d) (e) (b) (b's parent),label=above left:$F^{(b,R)}$] {};
      \node [fit=(c) (f) (f's parent),label=above right:$F^{(c,R)}$]    {};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/fit",
         meta = "⟨coordinates or nodes⟩"
      },
      ["fit fading"] = {
         details = [[
When set to true, the fading is shifted and resized (in exactly the same
way as a shading) so that it covers the current path. When set to false,
the fading is only shifted so that it is centered on the path's center,
but it is not resized. This can be useful for special-purpose fadings,
for instance when you use a fading to "punch out" something.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/fit:fading",
         meta = "⟨boolean⟩"
      },
      ["folding line length"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/folding:line:length",
         meta = "⟨dimension⟩"
      },
      font = {
         details = [[
Sets the font used for the text inside nodes. However, this font will
not (yet) be installed when any of the dimensions of the node are being
computed, so dimensions like 1em will be with respect to the font used
outside the node (usually the font that was in force when the picture
started).

    \begin{tikzpicture}
      \node [font=\itshape] {italic};
    \end{tikzpicture}

    \tikz \node [font=\tiny,  minimum height=3em, draw] {tiny};
    \tikz \node [font=\small, minimum height=3em, draw] {small};

A useful example of how the font option can be used is the following:

    \tikz [every text node part/.style={font=\itshape},
           every lower node part/.style={font=\footnotesize}]
      \node [circle split,draw] {state \nodepart{lower} output};

As can be seen, the font can be changed for each node part. This does
not work with the node font command since, as the name suggests, this
command can only be used to select the "overall" font for the node and
this is done very early.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/font",
         meta = "⟨font commands⟩"
      },
      framed = {
         details = [[
This is a shorthand for show background rectangle.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/framed"
      },
      ["general shadow"] = {
         details = [[
This option should be given to a \path or a node. It has the following
effect: Before the path is used normally, it is used once with the
⟨shadow options⟩ in force. Furthermore, when the path is "preused" in
this way, it is shifted and scaled a little bit.

In detail, the following happens: A preaction is used to paint the path
in a special manner before it is actually painted. This "special" manner
is as follows: The options in ⟨shadow options⟩ are used for painting
this path. Typically, the ⟨shadow options⟩ will contain options like
fill=black to create, say, a black shadow. Furthermore, after the
⟨shadow options⟩ have been set up, the following extra canvas
transformations are applied to the path: It is scaled by shadow scale
(with the origin of scaling at the path's center) and it is shifted by
shadow xshift and shadow yshift.

Note that since scaling and shifting is done using canvas
transformations, shadows are not taken into account when the picture's
bounding box is computed.

    \tikz [even odd rule]
      \draw [general shadow={fill=red}] (0,0) circle (.5) (0.5,0) circle (.5);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/general:shadow",
         meta = "⟨shadow options⟩"
      },
      ["graph/level"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graph/level",
         meta = "⟨level⟩"
      },
      ["graph/level ⟨level⟩"] = {
         details = [[
This key also gets executed for each newly created node with ⟨level⟩ set
to the current level of the node.

    \tikz \graph [
      branch down=5mm,
      level 1/.style={nodes=red},
      level 2/.style={nodes=green!50!black},
      level 3/.style={nodes=blue}]
    {
      a -> {
        b,
        c -> {
          d,
          e -> {f,g},
          h
        },
        j
      }
    };

    \tikz \graph [
      branch down=5mm,
      level 1/.style={grow right=2cm},
      level 2/.style={grow right=1cm},
      level 3/.style={grow right=5mm}]
    {
      a -> {
        b,
        c -> {
          d,
          e -> {f,g},
          h
        },
        j
      }
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graph/level:⟨level⟩"
      },
      ["graph/parse"] = {
         details = [[
This key can only be used inside the ⟨options⟩ of a ⟨group
specification⟩. Its effect is that the ⟨text⟩ is inserted at the
beginning of the current group as if you had entered it there.
Naturally, it makes little sense to just write down some static ⟨text⟩
since you could just as well directly place it at the beginning of the
group. The real power of this command stems from the fact that the keys
mechanism allows you to say, for instance, parse/.expand once to insert
the text stored in some macro into the group.

    \def\mychain{ a -> b -> c; }
    \tikz \graph { [parse/.expand once=\mychain] d -> e };

In the following, more fancy example we use a loop to create a chain of
dynamic length.

    \def\mychain#1{
      \def\mytext{1}
      \foreach \i in {2,...,#1} {
        \xdef\mytext{\mytext -> \i}
      }
    }
    \tikzgraphsset{my chain/.style={
        /utils/exec=\mychain{#1},
        parse/.expand once=\mytext}
    }
    \tikz \graph { [my chain=4] };

Multiple uses of this key accumulate, that is, all the texts given in
the different uses is inserted in the order it is given.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/graph/parse",
         meta = "⟨text⟩"
      },
      gridded = {
         details = [[
This is a shorthand for show background grid.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/gridded"
      },
      grow = {
         details = [[
This key is used to define the ⟨direction⟩ in which the tree will grow.
The ⟨direction⟩ can either be an angle in degrees or one of the
following special text strings: down, up, left, right, north, south,
east, west, north east, north west, south east, and south west. All of
these have "their obvious meaning", so, say, south west is the same as
the angle $-135^\circ$.

As a side effect, this option installs the default growth function.

In addition to setting the direction, this option also has a seemingly
strange effect: It sets the sibling distance for the current level to
0pt, but leaves the sibling distance for later levels unchanged.

This somewhat strange behavior has a highly desirable effect: If you
give this option before the list of children of a node starts, the
"current level" is still the parent level. Each child will be on a later
level and, hence, the sibling distance will be as specified originally.
This will cause the children to be neatly aligned in a line orthogonal
to the given ⟨direction⟩. However, if you give this option locally to a
single child, then "current level" will be the same as the child's
level. The zero sibling distance will then cause the child to be placed
exactly at a point at distance level distance in the direction
⟨direction⟩. However, the children of the child will be placed
"normally" on a line orthogonal to the ⟨direction⟩.

These placement effects are best demonstrated by some examples:

    \tikz \node {root} [grow=right] child child;

    \tikz \node {root} [grow=south west] child child;

    \begin{tikzpicture}[level distance=10mm,sibling distance=5mm]
      \node {root}
        [grow=down]
        child
        child
        child[grow=right] {
          child child child
        };
    \end{tikzpicture}

    \begin{tikzpicture}[level distance=2em]
      \node {C}
        child[grow=up]    {node {H}}
        child[grow=left]  {node {H}}
        child[grow=down]  {node {H}}
        child[grow=right] {node {C}
            child[grow=up]    {node {H}}
            child[grow=right] {node {H}}
            child[grow=down]  {node {H}}
          edge from parent[double]
            coordinate (wrong)
        };
      \draw[<-,red] ([yshift=-2mm]wrong) -- +(0,-1)
        node[below]{This is wrong!};
    \end{tikzpicture}

    \begin{tikzpicture}
      \node[rectangle,draw] (a) at (0,0) {start node};
      \node[rectangle,draw] (b) at (2,1) {end};

      \draw (a) -- (b)
        node[coordinate,midway] {}
          child[grow=100,<-] {node[above] {the middle is here}};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/grow",
         meta = "⟨direction⟩"
      },
      ["grow cyclic"] = {
         details = [[
This style causes the children to be arranged "on a circle". For this,
the children are placed at distance \tikzleveldistance from the parent
node, but not on a straight line, but on points on a circle. Instead of
a sibling distance, there is a sibling angle that denotes the angle
between two given children.

Note that this function will rotate the coordinate system of the
children to ensure that the grandchildren will grow in the right
direction.

    \begin{tikzpicture}
      [grow cyclic,
       level 1/.style={level distance=8mm,sibling angle=60},
       level 2/.style={level distance=4mm,sibling angle=45},
       level 3/.style={level distance=2mm,sibling angle=30}]
      \coordinate [rotate=-90] % going down
        child foreach \x in {1,2,3}
          {child foreach \x in {1,2,3}
            {child foreach \x in {1,2,3}}};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/grow:cyclic"
      },
      ["grow via three points"] = {
         details = [[
This option installs a growth function that works as follows: If a
parent node has just one child, this child is placed at ⟨x⟩. If the
parent node has two children, these are placed at ⟨y⟩ and ⟨z⟩. If the
parent node has more than two children, the children are placed at
points that are linearly extrapolated from the three points ⟨x⟩, ⟨y⟩,
and ⟨z⟩. In detail, the position is $x + \frac{n-1}{2}(y-x) +
    (c-1)(z-y)$, where $n$ is the number of children and $c$ is the
number of the current child (starting with $1$).

The net effect of all this is that if you have a certain "linear
arrangement" in mind and use this option to specify the placement of a
single child and of two children, then any number of children will be
placed correctly.

Here are some arrangements based on this growth function. We start with
a simple "above" arrangement:

    \begin{tikzpicture}[grow via three points={%
        one child at (0,1) and two children at (-.5,1) and (.5,1)}]
      \node at (0,0) {one} child;
      \node at (0,-1.5) {two} child child;
      \node at (0,-3) {three} child child child;
      \node at (0,-4.5) {four} child child child child;
    \end{tikzpicture}

The next arrangement places children above, but "grows only to the
right".

    \begin{tikzpicture}[grow via three points={%
        one child at (0,1) and two children at (0,1) and (1,1)}]
      \node at (0,0) {one} child;
      \node at (0,-1.5) {two} child child;
      \node at (0,-3) {three} child child child;
      \node at (0,-4.5) {four} child child child child;
    \end{tikzpicture}

In the final arrangement, the children are placed along a line going
down and right.

    \begin{tikzpicture}[grow via three points={%
        one child at (-1,-.5) and two children at (-1,-.5) and (0,-.75)}]
      \node at (0,0) {one} child;
      \node at (0,-1.5) {two} child child;
      \node at (0,-3) {three} child child child;
      \node at (0,-4.5) {four} child child child child;
    \end{tikzpicture}

These examples should make it clear how you can create new styles to
arrange your children along a line.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/grow:via:three:points",
         meta = "one child at (⟨x⟩ ) and two children at (⟨y⟩) and (⟨z⟩)"
      },
      ["grow'"] = {
         details = [[
This key has the same effect as grow, only the children are arranged in
the opposite order.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/grow'",
         meta = "⟨direction⟩"
      },
      ["growth function"] = {
         details = [[
This rather low-level option allows you to set a new growth function.
The ⟨macro name⟩ must be the name of a macro without parameters. This
macro will be called for each child of a node. The initial function is
an internal function that corresponds to downward growth.

The effect of executing the macro should be the following: It should
transform the coordinate system in such a way that the origin becomes
the place where the current child should be anchored. When the macro is
called, the current coordinate system will be set up such that the
anchor of the parent node is in the origin. Thus, in each call, the
⟨macro name⟩ must essentially do a shift to the child's origin. When the
macro is called, the TeX counter \tikznumberofchildren will be set to
the total number of children of the parent node and the counter
\tikznumberofcurrentchild will be set to the number of the current
child.

The macro may, in addition to shifting the coordinate system, also
transform the coordinate system further. For example, it could be
rotated or scaled.

Additional growth functions are defined in the library, see Section ??.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/growth:function",
         meta = "⟨macro name⟩"
      },
      ["growth parent anchor"] = {
         details = [[
This key allows you to specify which anchor of the parent node is to be
used for computing the children's position. For example, when there is
only one child and the level distance is 2cm, then the child node will
be placed two centimeters below the ⟨anchor⟩ of the parent node. "Being
placed" means that the child node's anchor (which is the anchor
specified using the anchor= option in the node command of the child) is
two centimeters below the parent node's ⟨anchor⟩.

In the following example, the two red lines both have length 1cm.

    \begin{tikzpicture}[level distance=1cm]
      \node [rectangle,draw] (a) at (0,0) {root}
      [growth parent anchor=south] child;

      \node [rectangle,draw] (b) at (2,0) {root}
      [growth parent anchor=north east] child;

      \draw [red,thick,dashed] (a.south) -- (a-1);
      \draw [red,thick,dashed] (b.north east) -- (b-1);
    \end{tikzpicture}

In the next example, the top and bottom nodes are aligned at the top and
the bottom, respectively.

    \begin{tikzpicture}
      [level distance=2cm,growth parent anchor=north,
       every node/.style={anchor=north,rectangle,draw}
       every child node/.style={anchor=south}]

      \node at (0,0) {root} child {node {small}};

      \node at (2,0) {big root} child {node {\large big}};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/growth:parent:anchor",
         meta = "⟨anchor⟩"
      },
      ["handle active characters in code"] = {
         details = [[
When this key is set, at the beginning of every \tikz command and every
{tikzpicture}, the character codes of all symbols used by TikZ are reset
to their normal values. Furthermore, at the beginning of each node, the
catcodes are restored to the values they had prior to the current
picture.

The net effect of this is that, in most cases, symbols having a special
character code can be used nicely both in TikZ code and also in node
texts.

In the following, slightly silly, example we make the dot an active
character and define it in some strange way. Now, in the later
TikZ command, the dot in 3.0cm may no longer be active and setting the
handle... option achieves exactly this. However, as can be seen, the dot
is once more active inside the node.

    \catcode`\.=\active
    \def.{\o}

    \tikz [handle active characters in code]
      \node [draw, minimum width=3.0cm] {hall. pe.ple};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/handle:active:characters:in:code",
         meta = "⟨true or false⟩"
      },
      ["handle active characters in nodes"] = {
         details = [[
This key is needed for a special situation: As explained for the
handle ... code key, that key switches off all special meaning of
symbols and switches them back on again at the beginning of nodes.
However, there is one situation when this is not possible: When some
text has already been read by TeX, the catcodes can no longer change.
Now, for normal nodes this is not a problem since their contents has not
been read at the moment the catcodes are restored. In contrast for label
nodes for edges, nodes produced by the graph and quotes libraries, and
some others nodes, their text has already been read when the catcodes
get adjusted.

The present key may help in such situations: It causes the text of all
such "indirectly created" nodes to be surrounded by a call to the
\scantokens command. This command attempts to reread an already read
text, but allows catcodes to change. As users of this command will know,
it is not a perfect substitute for directly reading the text by TeX, but
it normally has the desired effect.

    \catcode`\.=\active
    \def.{\o}

    \tikz [handle active characters in code,
           handle active characters in nodes]
      \node [draw, label=f..] {hall. pe.ple};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/handle:active:characters:in:nodes",
         meta = "⟨true or false⟩"
      },
      height = {
         details = [[
Inside a spy scope, this is a shortcut for minimum height.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/height",
         meta = "⟨dimension⟩"
      },
      ["help lines"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/help:lines"
      },
      ["huge circuit symbols"] = {
         details = [[
This style sets the default circuit symbol unit to 10pt.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/huge:circuit:symbols"
      },
      ["huge mindmap"] = {
         details = [[
This style causes concepts to be even bigger and it is best used with A2
paper and above.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/huge:mindmap"
      },
      id = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/id",
         meta = "⟨id⟩"
      },
      ["if"] = {
         details = [[
This option has the same effect as giving a corresponding if in the
⟨calendar specification⟩. The option is mostly useful for use in the
every calendar style, where you cannot provide if conditionals
otherwise.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/if",
         meta = "(⟨conditions⟩)⟨code or options⟩else⟨else code or options⟩"
      },
      ["in"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/in",
         meta = "⟨angle⟩"
      },
      ["in control"] = {
         details = [[
This option causes the ⟨coordinate⟩ to be used as the target control
point. You can use a coordinate like +(1,0) to specify a point relative
to the end coordinate.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/in:control",
         meta = "⟨coordinate⟩"
      },
      ["in distance"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/in:distance",
         meta = "⟨distance⟩"
      },
      ["in front of path"] = {
         details = [[
This is the opposite of behind path: It causes nodes to be drawn on top
of the path. Since this is the default behavior, you usually do not need
this option; it is only needed when an enclosing scope has used
behind path and you now wish to "switch back" to the normal behavior.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/in:front:of:path"
      },
      ["in looseness"] = {
         details = [[
Specifies the looseness factor for the in distance only.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/in:looseness",
         meta = "⟨number⟩"
      },
      ["in max distance"] = {
         details = [[
The maximum distance set only for the target coordinate.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/in:max:distance",
         meta = "⟨distance⟩"
      },
      ["in min distance"] = {
         details = [[
The minimum distance set only for the target coordinate.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/in:min:distance",
         meta = "⟨distance⟩"
      },
      info = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/info",
         meta = "[⟨options⟩]⟨angle⟩:⟨text⟩"
      },
      ["info sloped"] = {
         details = [[
This key works like info, only the transform shape option is set when
the label is drawn, causing it to follow the sloping of the main node.

    \begin{tikzpicture}[circuit ee IEC,every info/.style=red]
      \draw (0,0) to[resistor={info sloped={$3\Omega$}}] (3,0)
                  to[resistor={info sloped={$4\Omega$}}] (3,2);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/info:sloped",
         meta = "[⟨options⟩]⟨angle⟩:⟨text⟩"
      },
      ["info'"] = {
         details = [[
This key works exactly like the info key, only in case the ⟨angle⟩ is
missing, it defaults to below instead of the current value of
label position, which is usually above. This means that when you use
info, you get a label above the node, while when you use the info’ key
you get a label below the node. In case the node has been rotated, the
positions of the info nodes are rotated accordingly.

    \begin{tikzpicture}[circuit ee IEC,every info/.style=red]
      \draw (0,0) to[resistor={info={$3\Omega$},info'={$R_1$}}] (3,0)
                  to[resistor={info={$4\Omega$},info'={$R_2$}}] (3,2);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/info'",
         meta = "[⟨options⟩]⟨angle⟩:⟨text⟩"
      },
      ["info' sloped"] = {
         details = [[
This is a combination of info’ and info sloped.

    \begin{tikzpicture}[circuit ee IEC,every info/.style=red]
      \draw (0,0) to[resistor={info' sloped={$3\Omega$}}] (3,0)
                  to[resistor={info' sloped={$4\Omega$}}] (3,2);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/info':sloped",
         meta = ""
      },
      initial = {
         details = [[
This style is used to draw initial states.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/initial"
      },
      ["initial above"] = {
         details = [[
This is a shorthand for initial by arrow,initial where=above.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/initial:above"
      },
      ["initial below"] = {
         details = [[
Works similarly to the previous option.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/initial:below"
      },
      ["initial by arrow"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/initial:by:arrow"
      },
      ["initial by diamond"] = {
         details = [[
This style uses a diamond to indicate an initial node.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/initial:by:diamond"
      },
      ["initial distance"] = {
         details = [[
Sets the length of the arrow leading from the text to the state node.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/initial:distance",
         meta = "⟨distance⟩"
      },
      ["initial left"] = {
         details = [[
Works similarly to the previous option.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/initial:left"
      },
      ["initial right"] = {
         details = [[
Works similarly to the previous option.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/initial:right"
      },
      ["initial text"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/initial:text",
         meta = "⟨text⟩"
      },
      ["initial where"] = {
         details = [[
Set the place where the text should be shown. Allowed values are above,
below, left, and right.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/initial:where",
         meta = "⟨direction⟩"
      },
      ["inner color"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/inner:color",
         meta = "⟨color⟩"
      },
      ["inner frame sep"] = {
         details = [[
Sets the horizontal and vertical separator distances simultaneously.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/inner:frame:sep",
         meta = "⟨dimension⟩"
      },
      ["inner frame xsep"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/inner:frame:xsep",
         meta = "⟨dimension⟩"
      },
      ["inner frame ysep"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/inner:frame:ysep",
         meta = "⟨dimension⟩"
      },
      inputs = {
         details = [[
This key is defined only inside the scope of a circuit logic. There, it
has the same effect as logic gate inputs, described on page ??.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/inputs",
         meta = "⟨inputs⟩"
      },
      ["insert path"] = {
         details = [[
This key can be used inside an option to add something to the current
path. This is mostly useful for defining styles that create graphic
contents. This option should be used with care, for instance it should
not be used as an argument of, say, a node. In the following example, we
use a style to add little circles to a path.

    \tikz [c/.style={insert path={circle[radius=2pt]}}]
      \draw (0,0) -- (1,1) [c] -- (3,2) [c];

The effect is the same as of
(0,0) – (1,1) circle[radius=2pt] – (3,2) circle[radius=2pt].
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/insert:path",
         meta = "⟨path⟩"
      },
      ["intersection/by"] = {
         details = [[
This key allows you to specify a list of names for the intersection
coordinates. The intersection coordinates will still be named
⟨prefix⟩-⟨number⟩, but additionally the first coordinate will also be
named by the first element of the ⟨comma-separated list⟩. What happens
is that the ⟨comma-separated list⟩ is passed to the \foreach statement
and for ⟨list member⟩ a coordinate is created at the already-named
intersection.

    \begin{tikzpicture}
      \clip (-2,-2) rectangle (2,2);
      \draw [name path=curve 1] (-2,-1) .. controls (8,-1) and (-8,1) .. (2,1);
      \draw [name path=curve 2] (-1,-2) .. controls (-1,8) and (1,-8) .. (1,2);

      \fill [name intersections={of=curve 1 and curve 2, by={a,b}}]
            (a) circle (2pt)
            (b) circle (2pt);
    \end{tikzpicture}

You can also use the ... notation of the \foreach statement inside the
⟨comma-separated list⟩.

In case an element of the ⟨comma-separated list⟩ starts with options in
square brackets, these options are used when the coordinate is created.
A coordinate name can still, but need not, follow the options. This
makes it easy to add labels to intersections:

    \begin{tikzpicture}
      \clip (-2,-2) rectangle (2,2);
      \draw [name path=curve 1] (-2,-1) .. controls (8,-1) and (-8,1) .. (2,1);
      \draw [name path=curve 2] (-1,-2) .. controls (-1,8) and (1,-8) .. (1,2);

      \fill [name intersections={
              of=curve 1 and curve 2,
              by={[label=center:a],[label=center:...],[label=center:i]}}];
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/intersection/by",
         meta = "⟨comma-separated list⟩"
      },
      ["intersection/name"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/intersection/name",
         meta = "⟨prefix⟩"
      },
      ["intersection/of"] = {
         details = [[
This key is used to specify the names of the paths to use for the
intersection.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/intersection/of",
         meta = "⟨name path 1⟩ and ⟨name path 2⟩"
      },
      ["intersection/sort by"] = {
         details = [[
By default, the intersections are simply returned in the order that the
intersection algorithm finds them. Unfortunately, this is not
necessarily a "helpful" ordering. This key can be used to sort the
intersections along the path specified by ⟨path name⟩, which should be
one of the paths mentioned in the /tikz/intersection/of key.

    \begin{tikzpicture}
    \clip (-0.5,-0.75) rectangle (3.25,2.25);
    \foreach \pathname/\shift in {line/0cm, curve/2cm}{
      \tikzset{xshift=\shift}
      \draw [->, name path=curve] (1,1.5) .. controls (-1,1) and (2,0.5) .. (0,0);
      \draw [->, name path=line]  (0,-.5) -- (1,2) ;
      \fill [name intersections={of=line and curve,sort by=\pathname, name=i}]
        [red, opacity=0.5, every node/.style={left=.25cm, black, opacity=1}]
        \foreach \s in {1,2,3}{(i-\s) circle (2pt) node {\footnotesize\s}};
    }
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/intersection/sort:by",
         meta = "⟨path name⟩"
      },
      ["intersection/total"] = {
         details = [[
This key means that the total number of intersections found will be
stored in ⟨macro⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/intersection/total",
         meta = "⟨macro⟩"
      },
      ["isometric view"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/isometric:view"
      },
      join = {
         details = [[
When this key is given to any node on a chain (except possibly for the
first node), an edge command is added after the node. The with part
specifies which node should be used for the start point of the edge; if
the with part is omitted, the \tikzchainprevious is used. This edge
command gets the ⟨options⟩ as parameter and the current node as its
target. If there is no previous node and no with is given, no edge
command gets executed.

Note that it makes sense to call this option several times for a node,
in order to connect it to several nodes. This is especially useful for
joining in branches, see the next section.

    \begin{tikzpicture}[start chain,node distance=5mm,
                        every join/.style={->,red}]
      \node [draw,on chain,join] {};
      \node [draw,on chain,join] {Hallo};
      \node [draw,on chain,join] {Welt};
      \node [draw,on chain=going below,
             join,join=with chain-1 by {blue,<-}] {foo};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/join",
         meta = "with ⟨with⟩ by ⟨options⟩"
      },
      ["jump mark left"] = {
         details = [[
This option causes the points on the path to be drawn using piecewise
constant, non-connected series of lines. If there are any marks, they
will be placed on left open ends:

    \tikz\draw plot[jump mark left, mark=*] file{plots/pgfmanual-sine.table};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/jump:mark:left"
      },
      ["jump mark mid"] = {
         details = [[
This option causes the points on the path to be drawn using piecewise
constant, non-connected series of lines. If there are any marks, they
will be placed in the middle of the horizontal line segments:

    \tikz\draw plot[jump mark mid, mark=*] file{plots/pgfmanual-sine.table};

In case of non-constant mesh widths, the same remarks as for
const plot mark mid apply.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/jump:mark:mid"
      },
      ["jump mark right"] = {
         details = [[
This option causes the points on the path to be drawn using piecewise
constant, non-connected series of lines. If there are any marks, they
will be placed on right open ends:

    \tikz\draw plot[jump mark right, mark=*] file{plots/pgfmanual-sine.table};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/jump:mark:right"
      },
      ["key attribute"] = {
         details = [[
This style is intended for key attributes. By default, the will cause
the attribute to be typeset in italics. Typically, underlining is used
instead, but that looks ugly and it is difficult to implement in TeX.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/key:attribute"
      },
      label = {
         details = [[
[label-option] When this option is given to a node operation, it causes
another node to be added to the path after the current node has been
finished. This extra node will have the text ⟨text⟩. It is placed, in
principle, in the direction ⟨angle⟩ relative to the main node, but the
exact rules are a bit complex. Suppose the node currently under
construction is called main node and let us call the label node
label node. Then the following happens:

1.  The ⟨angle⟩ is used to determine a position on the border of the
    main node. If the ⟨angle⟩ is missing, the value of the following key
    is used instead:

    The ⟨angle⟩ determines the position on the border of the shape in
    two different ways. Normally, the border position is given by
    main node.⟨angle⟩. This means that the ⟨angle⟩ can either be a
    number like 0 or -340, but it can also be an anchor like north.
    Additionally, the special angles above, below, left, right,
    above left, and so on are automatically replaced by the
    corresponding angles 90, 270, 180, 0, 135, and so on.

    A special case arises when the following key is set:

2.  Then, an anchor point for the label node is computed. It is
    determined in such a way that the label node will "face away" from
    the border of the main node. The anchor that is chosen depends on
    the position of the border point that is chosen and its position
    relative to the center of the main node and on whether the
    transform shape option is set. In detail, when the computed border
    point is at $0^\circ$, the anchor west will be used. Similarly, when
    the border point is at $90^\circ$, the anchor south will be used,
    and so on for $180^\circ$ and $270^\circ$.

    For angles between these "major" angles, like $30^\circ$ or
    $110^\circ$, combined anchors, like south west for $30^\circ$ or
    south east for $110^\circ$, are used. However, for angles close to
    the major angles, (differing by up to $2^\circ$ from the major
    angle), the anchor for the major angle is used. Thus, a label at a
    border point for $2^\circ$ will have the anchor west, while a label
    for $3^\circ$ will have the anchor south west, resulting in a "jump"
    of the anchor. You can set the anchor "by hand" using the anchor key
    or indirect keys like left.

        \tikz
          \node [circle, draw,
                 label=default,
                 label=60:$60^\circ$,
                 label=below:$-90^\circ$,
                 label=3:$3^\circ$,
                 label=2:$2^\circ$,
                 label={[below]180:$180^\circ$},
                 label={[centered]135:$135^\circ$}] {my circle};

3.  One ⟨angle⟩ is special: If you set the ⟨angle⟩ to center, then the
    label will be placed on the center of the main node. This is mainly
    useful for adding a label text to an existing node, especially if it
    has been rotated.

        \tikz \node [transform shape,rotate=90,
                     rectangle,draw,label={[red]center:R}] {main node};

You can pass ⟨options⟩ to the node label node. For this, you provide the
options in square brackets before the ⟨angle⟩. If you do so, you need to
add braces around the whole argument of the label option and this is
also the case if you have brackets or commas or semicolons or anything
special in the ⟨text⟩.

    \tikz \node [circle,draw,label={[red]above:X}] {my circle};

    \begin{tikzpicture}
      \node [circle,draw,label={[name=label node]above left:$a,b$}] {};
      \draw (label node) -- +(1,1);
    \end{tikzpicture}

If you provide multiple label options, then multiple extra label nodes
are added in the order they are given.

The following styles influence how labels are drawn:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/label",
         meta = "[⟨options⟩]⟨angle⟩:⟨text⟩"
      },
      ["label distance"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/label:distance",
         meta = "⟨distance⟩"
      },
      ["label position"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/label:position",
         meta = "⟨angle⟩"
      },
      ["large circuit symbols"] = {
         details = [[
This style sets the default circuit symbol unit to 8pt.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/large:circuit:symbols"
      },
      ["large mindmap"] = {
         details = [[
This style includes the mindmap style, but additionally changes the
default size of concepts, fonts and distances so that a medium-sized
mindmap will fit on an A3 page (A3 pages are twice as large as A4
pages).
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/large:mindmap"
      },
      ["late options"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/late:options",
         meta = "⟨options⟩"
      },
      left = {
         details = [[
Similar to above.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/left",
         meta = "⟨offset⟩"
      },
      ["left color"] = {
         details = [[
This option does exactly the same as top color, except that the shading
angle is set to $90^\circ$.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/left:color",
         meta = "⟨color⟩"
      },
      ["left delimiter"] = {
         details = [[
This option can be given to a any node that has the standard anchors
north, south and so on. The ⟨delimiter⟩ can be any delimiter that is
acceptable to TeX's \left command.

    \begin{tikzpicture}
      \matrix [matrix of math nodes,left delimiter=(,right delimiter=\}]
      {
        a_8 & a_1 & a_6 \\
        a_3 & a_5 & a_7 \\
        a_4 & a_9 & a_2 \\
      };
    \end{tikzpicture}

    \begin{tikzpicture}
      \node [fill=red!20,left delimiter=(,right delimiter=\}]
        {$\displaystyle\int_0^1 x\,dx$};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/left:delimiter",
         meta = "⟨delimiter⟩"
      },
      ["left of"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/left:of",
         meta = "⟨node⟩"
      },
      lens = {
         details = [[
The ⟨options⟩ should contain transformation commands like scale or
rotate. These transformations are applied to the picture when it is
shown inside the spy-on node.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/lens",
         meta = "⟨options⟩"
      },
      level = {
         details = [[
This style is executed at the beginning of each set of children, where
⟨number⟩ is the current level in the current tree. For example, when you
say \node {x} child child;, then level=1 is used before the first child.
The style or code of this key will be passed ⟨number⟩ as its first
parameter. If this first child has children itself, then level=2 would
be used for them.

    \begin{tikzpicture}[level/.style={sibling distance=20mm/#1}]
      \node {root}
        child { child child }
        child { child child child };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/level",
         meta = "⟨number⟩"
      },
      ["level 1 concept"] = {
         details = [[
The mindmap style adds this style to the level 1 style. This means that
the first level children of a mindmap tree will use this style.

    \tikz
      [root concept/.append style={concept color=blue!80},
       level 1 concept/.append style={concept color=red!50},
       mindmap]
      \node [concept] {Root concept}
        child[grow=30] {node[concept] {child}}
        child[grow=0 ] {node[concept] {child}};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/level:1:concept"
      },
      ["level 2 concept"] = {
         details = [[
Works like level 1 concept, only for second level children.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/level:2:concept"
      },
      ["level 3 concept"] = {
         details = [[
Works like level 1 concept.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/level:3:concept"
      },
      ["level 4 concept"] = {
         details = [[
Works like level 1 concept. Note that there are no fifth and higher
level styles, you need to modify level 5 directly in such cases.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/level:4:concept"
      },
      ["level distance"] = {
         details = [[
This key determines the distance between different levels of the tree,
more precisely, between the parent and the line on which its children
are arranged. When given to a single child, this will set the distance
for this child only.

    \begin{tikzpicture}
      \node {root}
        [level distance=20mm]
        child
        child {
          [level distance=5mm]
          child
          child
          child
        }
        child[level distance=10mm];
    \end{tikzpicture}

    \begin{tikzpicture}
      [level 1/.style={level distance=10mm},
       level 2/.style={level distance=5mm}]
      \node {root}
        child
        child {
          child
          child[level distance=10mm]
          child
        }
        child;
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/level:distance",
         meta = "⟨distance⟩"
      },
      ["level ⟨number⟩"] = {
         details = [[
This style is used in addition to the level style. So, when you say
\node {x} child child;, then the following key list is executed:
level=1,level 1.

    \begin{tikzpicture}
      [level 1/.style={sibling distance=20mm},
       level 2/.style={sibling distance=5mm}]
      \node {root}
        child { child child }
        child { child child child };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/level:⟨number⟩"
      },
      ["light emitting"] = {
         details = [[
Like a unit, an annotation should be given as an additional option to a
node. It causes some drawings (in this case, two parallel lines) to be
placed next to the node.

    \tikz [circuit ee IEC] \draw (0,0) to [diode=light emitting] (2,0);

The ⟨options⟩ can be used for three different things:

1.  You can use keys like red to change the appearance of this
    annotation, locally.

2.  You can use keys like <- or -latex to change the direction and kinds
    of arrows used in the annotation.

3.  You can use info labels like ohm=5 or info=foo inside the ⟨options⟩.
    These info labels will be added to the main node (not to the
    annotation itself), but the label distance will have been changed to
    accommodate for the space taken up by the annotation.

        \tikz [circuit ee IEC]
        {
          \draw (0,2) to [diode={light emitting,info=not good}] (2,2);
          \draw (0,0) to [diode={light emitting={info=better},
                                 info'=also good}]  (2,0);
        }

In addition to light emitting there is also a key called
light emitting’, which simply places the annotation on the other side of
the node.

You can configure the appearance of annotations in three ways:

-   You can set the every circuit annotation style.

-   You can set the every light emitting style.

-   You can set the following key:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/light:emitting",
         meta = "⟨options⟩"
      },
      ["line cap"] = {
         details = [[
Specifies how lines "end". Permissible ⟨type⟩ are round, rect, and butt.
They have the following effects:

    \begin{tikzpicture}
      \begin{scope}[line width=10pt]
        \draw[line cap=round] (0,1 ) -- +(1,0);
        \draw[line cap=butt]  (0,.5) -- +(1,0);
        \draw[line cap=rect]  (0,0 ) -- +(1,0);
      \end{scope}
      \draw[white,line width=1pt]
        (0,0 ) -- +(1,0) (0,.5) -- +(1,0) (0,1 ) -- +(1,0);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/line:cap",
         meta = "⟨type⟩"
      },
      ["line join"] = {
         details = [[
Specifies how lines "join". Permissible ⟨type⟩ are round, bevel, and
miter. They have the following effects:

    \begin{tikzpicture}[line width=10pt]
      \draw[line join=round] (0,0) -- ++(.5,1) -- ++(.5,-1);
      \draw[line join=bevel] (1.25,0) -- ++(.5,1) -- ++(.5,-1);
      \draw[line join=miter] (2.5,0) -- ++(.5,1) -- ++(.5,-1);
      \useasboundingbox (0,1.5); % enlarge bounding box
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/line:join",
         meta = "⟨type⟩"
      },
      ["line to"] = {
         details = [[
Causes a straight line to be added to the path upon a to or an edge
operation.

    \tikz {\draw (0,0) to[line to] (1,0);}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/line:to"
      },
      ["line width"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/line:width",
         meta = "⟨dimension⟩"
      },
      loop = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/loop"
      },
      ["loop above"] = {
         details = [[
Sets the loop style and sets in and out angles such that loop is above
the node. Furthermore, the above option is set, which causes a node
label to be placed at the correct position.

    \begin{tikzpicture}
      \node [circle,draw] {a} edge [loop above] node {x} ();
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/loop:above"
      },
      ["loop below"] = {
         details = [[
Works like the previous option.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/loop:below"
      },
      ["loop left"] = {
         details = [[
Works like the previous option.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/loop:left"
      },
      ["loop right"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/loop:right"
      },
      ["loose background"] = {
         details = [[
Sets the inner frame separator to 2ex.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/loose:background"
      },
      ["loosely dash dot"] = {
         details = [[
Shorthand for setting a loosely dashed and dotted dash pattern.

    \tikz \draw[loosely dash dot] (0pt,0pt) -- (50pt,0pt);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/loosely:dash:dot"
      },
      ["loosely dash dot dot"] = {
         details = [[
Shorthand for setting a loosely dashed and dotted dash pattern with more
dots.

    \tikz \draw[loosely dash dot dot] (0pt,0pt) -- (50pt,0pt);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/loosely:dash:dot:dot"
      },
      ["loosely dashed"] = {
         details = [[
Shorthand for setting a loosely dashed dash pattern.

    \tikz \draw[loosely dashed] (0pt,0pt) -- (50pt,0pt);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/loosely:dashed"
      },
      ["loosely dotted"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/loosely:dotted"
      },
      looseness = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/looseness",
         meta = "⟨number⟩"
      },
      ["lower left"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/lower:left",
         meta = "⟨color⟩"
      },
      ["lower right"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/lower:right",
         meta = "⟨color⟩"
      },
      magnification = {
         details = [[
This has the same effect as saying lens={scale=⟨number⟩}.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/magnification",
         meta = "⟨number⟩"
      },
      ["make snapshot after"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/make:snapshot:after",
         meta = "⟨time⟩"
      },
      ["make snapshot if necessary"] = {
         details = [[
This key makes a snapshot of ⟨time⟩ only when the output format does not
provide support for animations; if the output format supports animations
(like SVG), then the command has no effect and animations are created
normally.

This manual is typeset with the following being set once are for all in
preamble:

    \tikzset{make snapshot if necessary}

Because of this setting, in the PDF version of this document, all
animations are shown at the value they would have at moment $0s$. In
contrast, in the SVG version, the animations are created normally.

In both versions, the smaller pictures showing how the animation
proceeds over time are created using make snapshot of for the indicated
times.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/make:snapshot:if:necessary",
         meta = "⟨time⟩"
      },
      ["make snapshot of"] = {
         details = [[
When this key is used in a TeX scope, animation commands given in the
scope do not add animation code to the output. Instead, TikZ computes
the values the attributes of the animation would have at the specified
⟨time⟩ and inserts the necessary system layer command to set the
attribute to the computed values (some care has been taken to make this
computation match the computations done by viewer applications as best
as possible).

    \tikz [make snapshot of = 1s] {
      \fill :fill = { 0s = "black", 2s = "white" } (0,0) rectangle ++(1,1);
      \fill :fill = { 1s = "black", 3s = "white" } (2,0) rectangle ++(1,1);
    }

The moment ⟨time⟩ is best thought of as ⟨time⟩ seconds after the "moment
zero" where all timelines start by default. Now, "real" animation may
start at different time through user interaction, which clearly makes no
sense for snapshots. Nevertheless, you will sometimes wish to have more
control over when a timeline starts for the purposes of taking
snapshots. You can use the following key for this:

The computations of the values the animation "would have" are done
entirely by TikZ, which has the big advantage is that no support from
the viewer application or the output format is needed -- snapshots work
with all output formats, not just with SVG. However, computations done
by TikZ are not always very precise and can be slow because of TeX's
limitations. In addition, there are some further limitations when it
comes to TikZ's computation of snapshot values:

-   As mentioned above, except for begin snapshot, other commands for
    specifying the beginning or end of a timeline based on user
    interaction make no sense for timelines: The keys begin, begin on,
    end, and end on are silently ignored.

-   The value current value for a value is forbidden since this value is
    almost impossible to compute by TikZ.

-   Accumulating repeats of a motion are (currently) not supported, but
    should not rely on this.

When ⟨time⟩ is empty, "snapshot taking" is switched off and animation
commands are inserted once more.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/make:snapshot:of",
         meta = "⟨time⟩"
      },
      mark = {
         details = [[
Sets the mark to a mnemonic that has previously been defined using the
\pgfdeclareplotmark. By default, *, +, and x are available, which draw a
filled circle, a plus, and a cross as marks. Many more marks become
available when the library plotmarks is loaded. Section ?? lists the
available plot marks.

One plot mark is special: the ball plot mark is available only in TikZ.
The ball color option determines the balls's color. Do not use this
option with a large number of marks since it will take very long to
render in PostScript.

  Option                 Effect
  --------------------- --------
  height14pt width0pt   
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/mark",
         meta = "⟨mark mnemonic⟩"
      },
      ["mark indices"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/mark:indices",
         meta = "⟨list⟩"
      },
      ["mark options"] = {
         details = [[
Redefines every mark such that it sets {options}.

    \tikz \fill[fill=blue!20]
      plot[mark=triangle*,mark options={color=blue,rotate=180}]
        file{plots/pgfmanual-sine.table} |- (0,0);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/mark:options",
         meta = "⟨options⟩"
      },
      ["mark phase"] = {
         details = [[
This option tells TikZ that the first mark to be draw should be the
$p$th, followed by the $(p+r)$th, then the $(p+2r)$th, and so on.

    \tikz \draw plot[mark=x,mark repeat=3,mark phase=6,smooth] file {plots/pgfmanual-sine.table};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/mark:phase",
         meta = "⟨p⟩"
      },
      ["mark repeat"] = {
         details = [[
This option tells TikZ that only every $r$th mark should be drawn.

    \tikz \draw plot[mark=x,mark repeat=3,smooth] file {plots/pgfmanual-sine.table};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/mark:repeat",
         meta = "⟨r⟩"
      },
      ["mark size"] = {
         details = [[
Sets the size of the plot marks. For circular plot marks, ⟨dimension⟩ is
the radius, for other plot marks ⟨dimension⟩ should be about half the
width and height.

This option is not really necessary, since you achieve the same effect
by specifying scale=⟨factor⟩ as a local option, where ⟨factor⟩ is the
quotient of the desired size and the default size. However, using
mark size is a bit faster and more natural.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/mark:size",
         meta = "⟨dimension⟩"
      },
      matrix = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/matrix",
         meta = "⟨true or false⟩"
      },
      ["matrix anchor"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/matrix:anchor",
         meta = "⟨anchor⟩"
      },
      ["matrix of math nodes"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/matrix:of:math:nodes"
      },
      ["matrix of nodes"] = {
         details = [[
Conceptually, this key adds \node{ at the beginning and }; at the end of
each cell and sets the anchor of the node to base. Furthermore, it adds
the option name option to each node, where the name is set to ⟨matrix
name⟩-⟨row number⟩-⟨column number⟩. For example, if the matrix has the
name my matrix, then the node in the upper left cell will get the name
my matrix-1-1.

    \begin{tikzpicture}
      \matrix (magic) [matrix of nodes]
      {
        8 & 1 & 6 \\
        3 & 5 & 7 \\
        4 & 9 & 2 \\
      };

      \draw[thick,red,->] (magic-1-1) |- (magic-2-3);
    \end{tikzpicture}

You may wish to add options to certain nodes in the matrix. This can be
achieved in three ways.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/matrix:of:nodes"
      },
      ["matrix/inner style order"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/matrix/inner:style:order"
      },
      ["matrix/inner style/cell"] = {
         details = [[
Wraps /tikz/row ⟨number⟩ column ⟨number⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/matrix/inner:style/cell"
      },
      ["matrix/inner style/column"] = {
         details = [[
Wraps /tikz/column ⟨number⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/matrix/inner:style/column"
      },
      ["matrix/inner style/even odd column"] = {
         details = [[
Wraps /tikz/every even column and /tikz/every odd column.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/matrix/inner:style/even:odd:column"
      },
      ["matrix/inner style/even odd row"] = {
         details = [[
Wraps /tikz/every even row and /tikz/every odd row.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/matrix/inner:style/even:odd:row"
      },
      ["matrix/inner style/every cell"] = {
         details = [[
Wraps /tikz/every cell.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/matrix/inner:style/every:cell"
      },
      ["matrix/inner style/row"] = {
         details = [[
Wraps /tikz/row ⟨number⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/matrix/inner:style/row"
      },
      ["max distance"] = {
         details = [[
If the computed distance for the start and target coordinates are above
⟨distance⟩, then ⟨distance⟩ is used instead.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/max:distance",
         meta = "⟨distance⟩"
      },
      ["medium circuit symbols"] = {
         details = [[
This style sets the default circuit symbol unit to 7pt.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/medium:circuit:symbols"
      },
      meet = {
         details = [[
Use this key with a scope to establish a view for the scope. In the
argument to the meet key, both rectangle texts are optional. Also,
everything following at is optional; when it is missing, the ⟨window
corner⟩s are assumed to be the same as the ⟨to-be-viewed corner⟩s. The
latter are two corners of a rectangle that should be transformed in such
a way that it fits inside the rectangle described by the two window
corners.

More precisely, at the beginning of the scope a canvas transformation is
installed that scales and translates the canvas is such a way that

1.  the center of the to-be-viewed rectangle lies at the center of the
    window rectangle and

2.  the to-be-viewed rectangle has maximum size that it still fits
    inside the window rectangle.

    \tikz {
      \draw [red, very thick] (0,0) rectangle (20mm,20mm);
      \begin{scope}[meet = {(0.5,0.5) (2.5,1.5) at (0,0) (2,2)}]
        \draw [blue, very thick] (5mm,5mm) rectangle (25mm,15mm);
        \draw [thick] (1,1) circle [x radius=5mm, y radius=10mm] node {Hi};
      \end{scope} }

    \tikz {
      \draw [red, very thick] (0,0) rectangle (20mm,20mm);
      \begin{scope}[slice = {(0.5,0.5) (2.5,1.5) at (0,0) (2,2)}]
        \draw [blue, very thick] (5mm,5mm) rectangle (25mm,15mm);
        \draw [thick] (1,1) circle [x radius=5mm, y radius=10mm] node {Hi};
      \end{scope} }

As mentioned earlier, the main use of views is in conjunction with
animations. In order to animate a view, you specify the scope containing
the meet command as the target object and then animate its :view
attribute:

    \tikz [animate = {
      my scope:view = {
        begin on = { click, of next = here },
        0s = "{(0.5,0.5) (2.5,1.5)}",
        2s = "{(0.5,0) (1.5,2)}", forever
      }}] {
      \draw [red, fill=red!20, very thick, name=here]
        (0,0) rectangle (20mm,20mm);
      \begin{scope}[name = my scope,
                    meet = {(0.5,0.5) (2.5,1.5) at (0,0) (2,2)}]
        \draw [blue, very thick] (5mm,5mm) rectangle (25mm,15mm);
        \draw [thick] (1,1) circle [x radius=5mm, y radius=10mm] node {Hi};
      \end{scope} }

You can, of course, also specify the animation using the animate myself:
key when you specify the animation inside the scope:

    \tikz [animate = {
      my scope:view = {
      }}] {
      \draw [red, fill=red!20, very thick, name=here]
        (0,0) rectangle (20mm,20mm);
      \begin{scope}[animate = { myself: = { :view = {
                      begin on = { click, of = here },
                      0s = "{(0.5,0.5) (2.5,1.5)}",
                      2s = "{(0.5,0) (1.5,2)}", forever }}},
                    slice = {(0.5,0.5) (2.5,1.5) at (0,0) (2,2)}]
        \draw [blue, very thick] (5mm,5mm) rectangle (25mm,15mm);
        \draw [thick] (1,1) circle [x radius=5mm, y radius=10mm] node {Hi};
      \end{scope} }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/meet",
         meta = "⟨to-be-viewed corner⟩ rectangle ⟨to-be-viewed corner⟩ at ⟨window corner⟩ rectangle ⟨window corner⟩"
      },
      ["mid left"] = {
         details = [[
Works like base left, but with mid east and mid west anchors instead of
base east and base west.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/mid:left",
         meta = "⟨specification⟩"
      },
      ["mid right"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/mid:right",
         meta = "⟨specification⟩"
      },
      ["middle color"] = {
         details = [[
This option specifies the color for the middle of an axis shading. It
also sets the shade and shading=axis options, but it does not change the
rotation angle.

Note: Since both top color and bottom color change the middle color,
this option should be given last if all of these options need to be
given:

    \tikz \draw[top color=white,bottom color=black,middle color=red]
      (0,0) rectangle (2,1);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/middle:color",
         meta = "⟨color⟩"
      },
      midway = {
         details = [[
This has the same effect as pos=0.5.

    \tikz \draw (0,0) .. controls +(up:2cm) and +(left:3cm) .. (1,5)
           node[at end]          {\texttt{at end}}
           node[very near end]   {\texttt{very near end}}
           node[near end]        {\texttt{near end}}
           node[midway]          {\texttt{midway}}
           node[near start]      {\texttt{near start}}
           node[very near start] {\texttt{very near start}}
           node[at start]        {\texttt{at start}};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/midway"
      },
      ["min distance"] = {
         details = [[
If the computed distance for the start and target coordinates are below
⟨distance⟩, then ⟨distance⟩ is used instead.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/min:distance",
         meta = "⟨distance⟩"
      },
      mindmap = {
         details = [[
Use this style with all pictures or at least scopes that contain a
mindmap. It installs a whole bunch of settings that are useful for
drawing mindmaps.

    \tikz[mindmap,concept color=red!50]
      \node [concept] {Root concept}
        child[grow=right] {node[concept] {Child concept}};

The sizes of concepts are predefined in such a way that a medium-size
mindmap will fit on an A4 page (more or less).

Remark:

Note that mindmap redefines font sizes and sibling angle depending on
the current concept level (i.e. inside of level 1 concept,
level 2 concept etc.). Thus, if you need to redefine these variables,
use

level 1 concept/.append style={font=\small}

or

level 2 concept/.append style={sibling distance=90}

after the mindmap style.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/mindmap"
      },
      missing = {
         details = [[
If this option is given to a child, the current child counter is
increased, but the child is otherwise ignored. In particular, the normal
contents of the child is completely ignored.

    \begin{tikzpicture}[level distance=10mm,sibling distance=5mm]
      \node {root} [grow=down]
        child          { node {1} }
        child          { node {2} }
        child          { node {3} }
        child[missing] { node {4} }
        child          { node {5} }
        child          { node {6} };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/missing",
         meta = "⟨true or false⟩"
      },
      ["miter limit"] = {
         details = [[
When you use the miter join and there is a very sharp corner (a small
angle), the miter join may protrude very far over the actual joining
point. In this case, if it were to protrude by more than ⟨factor⟩ times
the line width, the miter join is replaced by a bevel join.

    \begin{tikzpicture}[line width=5pt]
      \draw                 (0,0) -- ++(5,.5) -- ++(-5,.5);
      \draw[miter limit=25] (6,0) -- ++(5,.5) -- ++(-5,.5);
      \useasboundingbox (14,0); % make bounding box bigger
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/miter:limit",
         meta = "⟨factor⟩"
      },
      ["month code"] = {
         details = [[
This option allows you to specify what the macro \tikzmonthcode should
expand to.

By default, the \tikzmonthcode it is set to

    \node[every month]{\tikzmonthtext};

Note that this node is not named by default.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/month:code",
         meta = "⟨code⟩"
      },
      ["month label above centered"] = {
         details = [[
Works as above, only the label is centered above the row containing the
first day.

    \tikz
      \calendar [dates=2000-02-01 to 2000-02-last,
                 day list right,month label above centered];

    \tikz
      \calendar [dates=2000-01-20 to 2000-02-10,
                 week list,month label above centered];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:above:centered"
      },
      ["month label above left"] = {
         details = [[
This style places the month label above of the row of the first day,
flushed left to the leftmost column. The amount by which the label is
raised is fixed to 1.25em; use the yshift option with the month node to
modify this.

    \tikz
      \calendar [dates=2000-01-28 to 2000-02-03,
                 day list right,month xshift=1em,
                 month label above left];

    \tikz
      \calendar [dates=2000-01-20 to 2000-02-10,
                 week list,month label above left];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:above:left"
      },
      ["month label above right"] = {
         details = [[
Works as above, but flushed right

    \tikz
      \calendar [dates=2000-01-20 to 2000-02-10,
                 week list,month label above right];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:above:right"
      },
      ["month label below centered"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:below:centered"
      },
      ["month label below left"] = {
         details = [[
Works like month label above left, only the label is placed below the
row. This placement is not really useful with the week list arrangement,
but rather with the day list right or month list arrangement.

    \tikz
      \calendar [dates=2000-02-01 to 2000-02-last,
                 day list right,month label below left];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:below:left"
      },
      ["month label left"] = {
         details = [[
Places the month label to the left of the first day of the month. (For
week list and month list where a month does not start on a Monday, the
position is chosen "as if" the month had started on a Monday -- which is
usually exactly what you want.)

    \tikz
      \calendar [dates=2000-01-28 to 2000-02-03,
                 day list downward,month yshift=1em,
                 month label left];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:left"
      },
      ["month label left vertical"] = {
         details = [[
This style works like the above style, only the label is rotated
counterclockwise by 90 degrees.

    \tikz
      \calendar [dates=2000-01-28 to 2000-02-03,
                 day list downward,month yshift=1em,
                 month label left vertical];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:left:vertical"
      },
      ["month label right"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:right"
      },
      ["month label right vertical"] = {
         details = [[
Works as above, only the label is rotated clockwise by 90 degrees.

    \tikz
      \calendar [dates=2000-01-28 to 2000-02-03,
                 day list downward,month yshift=1em,
                 month label right vertical];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/month:label:right:vertical"
      },
      ["month list"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/month:list"
      },
      ["month text"] = {
         details = [[
This option allows you to change the macro \tikzmonthtext. By default,
the month text is a long textual presentation of the current month being
typeset.

    \tikz \calendar[dates=2000-01-01 to 2000-01-31,week list,
                    month label above centered,
                    month text=\textcolor{red}{\%mt} \%y-];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/month:text",
         meta = "⟨text⟩"
      },
      ["month xshift"] = {
         details = [[
Specifies an additional horizontal shift between different months.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/month:xshift",
         meta = "⟨dimension⟩"
      },
      ["month yshift"] = {
         details = [[
Specifies an additional vertical shift between different months.

    \tikz \calendar[dates=2000-01-01 to 2000-02-last,week list,
                    month yshift=0pt];

    \tikz \calendar[dates=2000-01-01 to 2000-02-last,week list,
                    month yshift=1cm];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/month:yshift",
         meta = "⟨dimension⟩"
      },
      ["move to"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/move:to"
      },
      name = {
         details = [[
Assigns a name to the path for reference (specifically, for reference in
animations; for reference in intersections, use the name path command,
which has a different purpose, see the intersections library for
details). Since the name is a "high-level" name (drivers never know of
it), you can use spaces, number, letters, or whatever you like when
naming a path, but the name may not contain any punctuation like a dot,
a comma, or a colon.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/name",
         meta = "⟨path name⟩"
      },
      ["name intersections"] = {
         details = [[
This key changes the key path to /tikz/intersection and processes
⟨options⟩. These options determine, among other things, which paths to
use for the intersection. Having processed the options, any
intersections are then found. A coordinate is created at each
intersection, which by default, will be named intersection-1,
intersection-2, and so on. Optionally, the prefix intersection can be
changed, and the total number of intersections stored in a TeX-macro.

    \begin{tikzpicture}[every node/.style={opacity=1, black, above left}]
      \draw [help lines] grid (3,2);
      \draw [name path=ellipse] (2,0.5) ellipse (0.75cm and 1cm);
      \draw [name path=rectangle, rotate=10] (0.5,0.5) rectangle +(2,1);
      \fill [red, opacity=0.5, name intersections={of=ellipse and rectangle}]
        (intersection-1) circle (2pt) node {1}
        (intersection-2) circle (2pt) node {2};
    \end{tikzpicture}

The following keys can be used in ⟨options⟩:

    \begin{tikzpicture}
      \clip (-2,-2) rectangle (2,2);
      \draw [name path=curve 1] (-2,-1) .. controls (8,-1) and (-8,1) .. (2,1);
      \draw [name path=curve 2] (-1,-2) .. controls (-1,8) and (1,-8) .. (1,2);

      \fill [name intersections={of=curve 1 and curve 2, name=i, total=\t}]
            [red, opacity=0.5, every node/.style={above left, black, opacity=1}]
            \foreach \s in {1,...,\t}{(i-\s) circle (2pt) node {\footnotesize\s}};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/name:intersections",
         meta = "{options}"
      },
      ["name prefix"] = {
         details = [[
The value of this key is prefixed to every node inside the current
scope. This includes both the naming of the node (via the name key or
via the implicit (⟨name⟩) syntax) as well as any referencing of the
node. Outside the scope, the nodes can (and need to) be referenced using
"full name" consisting of the prefix and the node name.

The net effect of this is that you can set the name prefix at the
beginning of a scope to some value and then use short and simple names
for the nodes inside the scope. Later, outside the scope, you can
reference the nodes via their full name:

    \tikz {
      \begin{scope}[name prefix = top-]
        \node (A) at (0,1) {A};
        \node (B) at (1,1) {B};
        \draw (A) -- (B);
      \end{scope}
      \begin{scope}[name prefix = bottom-]
        \node (A) at (0,0) {A};
        \node (B) at (1,0) {B};
        \draw (A) -- (B);
      \end{scope}

      \draw [red] (top-A) -- (bottom-B);
    }

As can be seen, name prefixing makes it easy to write reusable code.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/name:prefix",
         meta = "⟨text⟩"
      },
      ["name prefix .."] = {
         details = [[
This key is available only inside the code of a pic. There, it (locally)
changes the name prefix to the value it had outside the pic. This allows
you to access nodes outside the current pic.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/name:prefix:.."
      },
      ["name suffix"] = {
         details = [[
Works as name prefix, only the ⟨text⟩ is appended to every node name in
the current scope.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/name:suffix",
         meta = "⟨text⟩"
      },
      ["near end"] = {
         details = [[
Set to pos=0.75.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/near:end"
      },
      ["near start"] = {
         details = [[
Set to pos=0.25.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/near:start"
      },
      ["nearly opaque"] = {
         details = [[
    \tikz{\fill[red]           (0,0)   rectangle (1,0.5);
          \fill[nearly opaque] (0.5,0) rectangle (1.5,0.25); }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/nearly:opaque"
      },
      ["nearly transparent"] = {
         details = [[
    \tikz{\fill[red]                (0,0)   rectangle (1,0.5);
          \fill[nearly transparent] (0.5,0) rectangle (1.5,0.25); }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/nearly:transparent"
      },
      ["new set"] = {
         details = [[
This will setup a node set named ⟨set name⟩ within the current scope.
Inside the scope, you can add nodes to the node set using the set key.
If a node set of the same name already exists in the current scope, it
will be reset and made empty for the current scope.

Note that this command has the path /tikz and is normally used outside
the graph command.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/new:set",
         meta = "⟨set name⟩"
      },
      ["no markers"] = {
         details = [[
Disables markers (the same as mark=none).
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/no:markers"
      },
      ["no marks"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/no:marks"
      },
      ["node contents"] = {
         details = [[
[option-node-contents] This key sets the contents of the node to the
given text as if you had given it at the end in curly braces. When the
option is used inside the options of a node, the parsing of the node
stops immediately after the end of the option block. In particular, the
option block cannot be followed by further option blocks or curly braces
(or, rather, these do not count as part of the node specification.) Also
note that the ⟨node contents⟩ may not contain fragile stuff since the
catcodes get fixed upon reading the options. Here is an example:

    \tikz {
      \path (0,0) node [red]                    {A}
            (1,0) node [blue]                   {B}
            (2,0) node [green, node contents=C]
            (3,0) node [node contents=D]           ;
    }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/node:contents",
         meta = "⟨node contents⟩"
      },
      ["node distance"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/node:distance",
         meta = "⟨dimension⟩"
      },
      ["node font"] = {
         details = [[
This option sets the font used for all text used in a node.

    \begin{tikzpicture}
      \draw[node font=\itshape] (1,0) -- +(1,1) node[above] {italic};
    \end{tikzpicture}

Since the ⟨font commands⟩ are executed at a very early stage in the
construction of the node, the font selected using this command will also
dictate the values of dimensions defined in terms of em or ex. For
instance, when the minimum height of a node is 3em, the actual height
will be (at least) three times the line distance selected by the ⟨font
commands⟩:

    \tikz \node [node font=\tiny,  minimum height=3em, draw] {tiny};
    \tikz \node [node font=\small, minimum height=3em, draw] {small};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/node:font",
         meta = "⟨font commands⟩"
      },
      ["node halign header"] = {
         details = [[
This is the key that is used by align internally for alignment without
line breaking. Read the following only if you are familiar with the
\halign command.

This key only has an effect if text width is empty, otherwise it is
ignored. Furthermore, if ⟨macro storing a header⟩ is empty, then this
key also has no effect. So, suppose text width is empty, but ⟨header⟩ is
not. In this case the following happens:

When the node text is parsed, the command \\ is redefined internally.
This redefinition is done in such a way that the text from the start of
the node to the first occurrence of \\ is put in an \hbox. Then the text
following \\ up to the next \\ is put in another \hbox. This goes on
until the text between the last \\ and the closing } is also put in an
\hbox.

The ⟨macro storing a header⟩ should be a macro that contains some text
suitable for use as a header for the \halign command. For instance, you
might define

    \def\myheader{\hfil\hfil##\hfil\cr}
    \tikz [node halign header=\myheader] ...

You cannot just say node halign header=\hfil\hfil# \hfil\cr because this
confuses TeX inside matrices, so this detour via a macro is needed.

Next, conceptually, all these boxes are recursively put inside an
\halign command. Assuming that ⟨first⟩ is the first of the above boxes,
the command \halign{⟨header⟩ \box⟨first⟩ \cr} is used to create a new
box, which we will call the ⟨previous box⟩. Then, the following box is
created, where ⟨second⟩ is the second input box: \halign{⟨header⟩
\box⟨previous box⟩ \cr \box⟨second⟩\cr}. Let us call the resulting box
the ⟨previous box⟩ once more. Then the next box that is created is
\halign{⟨header⟩ \box⟨previous box⟩ \cr \box⟨third⟩\cr}.

All of this means that if ⟨header⟩ is an \halign header like
\hfil# \hfil\cr, then all boxes will be centered relative to one
another. Similarly, a ⟨header⟩ of \hfil# \cr causes the text to be
flushed right.

Note that this mechanism is not flexible enough to all multiple columns
inside ⟨header⟩. You will have to use a tabular or a matrix in such
cases.

One further note: Since the text of each line is placed in a box,
settings will be local to each "line". This is very similar to the way a
cell in a tabular or a matrix behaves.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/node:halign:header",
         meta = "⟨macro storing a header⟩"
      },
      ["node quotes mean"] = {
         details = [[
This key allows you to define your own handler for quotes options.
Inside the options of a node, whenever a key--value pair with the syntax

  "⟨text⟩"’⟨options⟩

is encountered, the following happens: The above string gets replaced by
⟨replacement⟩ where inside the ⟨replacement⟩ the parameter # 1 is ⟨text⟩
and # 2 is ⟨options⟩. If the apostrophe is present (see also the
discussion of quotes mean label), the ⟨options⟩ start with ’,.

The ⟨replacement⟩ is then parsed normally as options (using \pgfkeys).

Here is an example, where the quotes are used to define labels that are
automatically named according to the text:

    \tikzset{node quotes mean={label={[#2,name={#1}]#1}}}

    \tikz {
      \node ["1", "2" label position=left, circle, draw] {circle};
      \draw (1) -- (2);
    }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/node:quotes:mean",
         meta = "⟨replacement⟩"
      },
      nodes = {
         details = [[
This key adds the ⟨options⟩ to the style every node. It is mainly just a
shorthand for the code every node/.append style=⟨options⟩.

The main use of this option is the install some options for the nodes
inside the matrix that should not apply to the matrix itself.

    \begin{tikzpicture}
      \matrix [nodes={fill=blue!20,minimum size=5mm}]
      {
        \node {8}; & \node{1}; & \node {6}; \\
        \node {3}; & \node{5}; & \node {7}; \\
        \node {4}; & \node{9}; & \node {2}; \\
      };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/nodes",
         meta = "⟨options⟩"
      },
      ["nodes in empty cells"] = {
         details = [[
When set to true, a node (with empty contents) is put in empty cells.
Normally, empty cells are just, well, empty. The style can be used
together with both a matrix of nodes and a matrix of math nodes.

    \begin{tikzpicture}
      \matrix [matrix of math nodes,nodes={circle,draw}]
      {
        a_8 &     & a_6 \\
        a_3 &     & a_7 \\
        a_4 & a_9 &     \\
      };
    \end{tikzpicture}

    \begin{tikzpicture}
      \matrix [matrix of math nodes,nodes={circle,draw},nodes in empty cells]
      {
        a_8 &     & a_6 \\
        a_3 &     & a_7 \\
        a_4 & a_9 &     \\
      };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/nodes:in:empty:cells",
         meta = "⟨true or false⟩"
      },
      ["nonzero rule"] = {
         details = [[
If this rule is used (which is the default), the following method is
used to determine whether a given point is "inside" the path: From the
point, shoot a ray in some direction towards infinity (the direction is
chosen such that no strange borderline cases occur). Then the ray may
hit the path. Whenever it hits the path, we increase or decrease a
counter, which is initially zero. If the ray hits the path as the path
goes "from left to right" (relative to the ray), the counter is
increased, otherwise it is decreased. Then, at the end, we check whether
the counter is nonzero (hence the name). If so, the point is deemed to
lie "inside", otherwise it is "outside". Sounds complicated? It is.

    \begin{tikzpicture}
      \filldraw[fill=yellow!80!black]
      % Clockwise rectangle
      (0,0) -- (0,1) -- (1,1) -- (1,0) -- cycle
      % Counter-clockwise rectangle
      (0.25,0.25) -- (0.75,0.25) -- (0.75,0.75) -- (0.25,0.75) -- cycle;

      \draw[->] (0,1) -- (.4,1);
      \draw[->] (0.75,0.75) -- (0.3,.75);

      \draw[->] (0.5,0.5) -- +(0,1) node[above] {crossings: $-1+1 = 0$};

      \begin{scope}[yshift=-3cm]
        \filldraw[fill=yellow!80!black]
        % Clockwise rectangle
        (0,0) -- (0,1) -- (1,1) -- (1,0) -- cycle
        % Clockwise rectangle
        (0.25,0.25) -- (0.25,0.75) -- (0.75,0.75) -- (0.75,0.25) -- cycle;

        \draw[->] (0,1) -- (.4,1);
        \draw[->] (0.25,0.75) -- (0.4,.75);

        \draw[->] (0.5,0.5) -- +(0,1) node[above] {crossings: $1+1 = 2$};
      \end{scope}
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/nonzero:rule"
      },
      ["numbered faces"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/numbered:faces"
      },
      ohm = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/ohm",
         meta = "⟨value⟩"
      },
      ["on background layer"] = {
         details = [[
This key can (only) be used with a {scope} or \scoped. It will cause
everything inside the scope to be typeset on a background layer.

The ⟨options⟩ will be executed inside background scope. This is useful
since other options passed to the {scope} environment will be executed
before the actual background material starts and, thus, will have no
effect on it.

    \begin{tikzpicture}
      % On main layer:
      \fill[blue] (0,0) circle (1cm);

      \begin{scope}[on background layer={color=yellow}]
        \fill (-1,-1) rectangle (1,1);
      \end{scope}

      \begin{scope}[on background layer]
        \fill[black] (-.8,-.8) rectangle (.8,.8);
      \end{scope}

      % On main layer again:
      \fill[blue!50] (-.5,-1) rectangle (.5,1);
    \end{tikzpicture}

A scope with this option set should not be "deeply nested" inside the
picture since changes to the graphic state (like the color or the
transformation matrix) "do not survive a layer switch", see also
Section ?? for details. In particular, setting, say, the line width at
the beginning of a picture will not have an effect on the background
picture.

For this reason, it may be useful to setup the following style:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/on:background:layer",
         meta = "⟨options⟩"
      },
      ["on chain"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/on:chain",
         meta = "⟨chain name⟩⟨direction⟩"
      },
      ["on grid"] = {
         details = [[
When this key is set to true, an ⟨of-part⟩ of the current form behaves
differently: The anchors set for the current node as well as the anchor
used for the other ⟨node name⟩ are set to center.

This has the following effect: When you say above=1cm of somenode with
on grid set to true, the new node will be placed in such a way that its
center is 1cm above the center of somenode. Repeatedly placing nodes in
this way will result in nodes that are centered on "grid coordinate",
hence the name of the option.

    \begin{tikzpicture}[every node/.style=draw]
      \draw[help lines] (0,0) grid (2,3);

      % Not gridded
      \node (a1) at (0,0) {not gridded};
      \node (b1) [above=1cm of a1] {fooy};
      \node (c1) [above=1cm of b1] {a};

      % gridded
      \node (a2) at (2,0) {gridded};
      \node (b2) [on grid,above=1cm of a2] {fooy};
      \node (c2) [on grid,above=1cm of b2] {a};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/on:grid",
         meta = "⟨boolean⟩"
      },
      ["only marks"] = {
         details = [[
This option causes only marks to be shown; no path segments are added to
the actual path. This can be useful for quickly adding some marks to a
path.

    \tikz \draw (0,0) sin (1,1) cos (2,0)
      plot[only marks,mark=x] coordinates{(0,0) (1,1) (2,0) (3,-1)};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/only:marks"
      },
      opacity = {
         details = [[
Sets both the drawing and filling opacity to ⟨value⟩.

The following predefined styles make it easier to use this option:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/opacity",
         meta = "⟨value⟩"
      },
      opaque = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/opaque"
      },
      out = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/out",
         meta = "⟨angle⟩"
      },
      ["out control"] = {
         details = [[
This option causes the ⟨coordinate⟩ to be used as the start control
point. All computations of $d$ are ignored. You can use a coordinate
like +(1,0) to specify a point relative to the start coordinate.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/out:control",
         meta = "⟨coordinate⟩"
      },
      ["out distance"] = {
         details = [[
Sets the minimum and maximum out distance.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/out:distance",
         meta = "⟨distance⟩"
      },
      ["out looseness"] = {
         details = [[
Specifies the looseness factor for the out distance only.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/out:looseness",
         meta = "⟨number⟩"
      },
      ["out max distance"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/out:max:distance",
         meta = "⟨distance⟩"
      },
      ["out min distance"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/out:min:distance",
         meta = "⟨distance⟩"
      },
      ["outer color"] = {
         details = [[
This option sets the color used at the border and outside of a radial
shading.

    \tikz \draw[outer color=red,inner color=white]
      (0,0) rectangle (2,1);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/outer:color",
         meta = "⟨color⟩"
      },
      ["outer frame sep"] = {
         details = [[
Sets both the $x$- and $y$-separation.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/outer:frame:sep",
         meta = "⟨dimension⟩"
      },
      ["outer frame xsep"] = {
         details = [[
The ⟨dimension⟩ is added at the left and right side of the line.

    \begin{tikzpicture}
      [background rectangle/.style={fill=yellow},
       framed,
       show background top,
       outer frame xsep=1ex]
      \draw (0,0) ellipse (10mm and 5mm);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/outer:frame:xsep",
         meta = "⟨dimension⟩"
      },
      ["outer frame ysep"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/outer:frame:ysep",
         meta = "⟨dimension⟩"
      },
      overlay = {
         details = [[
This option is mainly intended for use when nodes in other pictures are
referenced, but you can also use it in other situations. The effect of
this option is that everything within the current scope is not taken
into consideration when the bounding box of the current picture is
computed.

You need to specify this option on all paths (or at least on all parts
of paths) that contain a reference to a node in another picture. The
reason is that, otherwise, TikZ will attempt to make the current picture
large enough to encompass the node in the other picture. However, on a
second run of TeX this will create an even bigger picture, leading to
larger and larger pictures. Unless you know what you are doing, I
suggest specifying the overlay option with all pictures that contain
references to other pictures.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/overlay",
         meta = "⟨boolean⟩"
      },
      ["parabola height"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/parabola:height",
         meta = "⟨dimension⟩"
      },
      parametric = {
         details = [[
Sets whether the plot is a parametric plot. If true, then t must be used
instead of x as the parameter and two comma-separated functions must be
given in the ⟨gnuplot formula⟩. An example is the following:

    \tikz \draw[scale=0.5,domain=-3.141:3.141,smooth]
      plot[parametric,id=parametric-example] function{t*sin(t),t*cos(t)};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/parametric",
         meta = "⟨boolean⟩"
      },
      ["parent anchor"] = {
         details = [[
This option works the same way as the child anchor, only for the parent.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/parent:anchor",
         meta = "⟨anchor⟩"
      },
      ["path fading"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/path:fading",
         meta = "⟨name⟩"
      },
      ["path picture"] = {
         details = [[
When this option is given on a path and when the ⟨code⟩ is not empty,
the following happens: After all other "filling" operations are done
with the path, which are caused by the options fill, pattern and shade,
a local scope is opened and the path is temporarily installed as a
clipping path. Then, the ⟨code⟩ is executed, which can now draw
something. Then, the local scope ends and, possibly, the path is
stroked, provided the draw option has been given.

As with other keys like fill or draw this option needs to be given on a
path, setting the path picture outside a path has no effect (the path
picture is cleared at the beginning of each path).

The ⟨code⟩ can be any normal TikZ code like \draw ... or \node .... As
always, when you include an external graphic, you need to put it inside
a \node.

Note that no special actions are taken to transform the origin in any
way. This means that the coordinate (0,0) is still where is was when the
path was being constructed and not -- as one might expect -- at the
lower left corner of the path. However, you can use the following
special node to access the size of the path:

path picture bounding box This node is of shape rectangle. Its size and
position are those of current path bounding box just before the ⟨code⟩
of the path picture started to be executed. The ⟨code⟩ can construct its
own paths, so accessing the current path bounding box inside the ⟨code⟩
yields the bounding box of any path that is currently being constructed
inside the ⟨code⟩.

    \begin{tikzpicture}
      \draw [help lines] (0,0) grid (3,2);
      \filldraw [fill=blue!10,draw=blue,thick] (1.5,1) circle (1)
        [path picture={
          \node at (path picture bounding box.center) {
            This is a long text.
          };}
        ];
    \end{tikzpicture}

    \begin{tikzpicture}[cross/.style={path picture={
          \draw[black]
                (path picture bounding box.south east) --
                (path picture bounding box.north west)
                (path picture bounding box.south west) --
                (path picture bounding box.north east);
        }}]
      \draw [help lines] (0,0) grid (3,2);
      \filldraw [cross,fill=blue!10,draw=blue,thick] (1,1) circle (1);
      \path     [cross,top color=red,draw=red,thick] (2,0) -- (3,2) -- (3,0);
    \end{tikzpicture}

      \begin{tikzpicture}[path image/.style={
          path picture={
            \node at (path picture bounding box.center) {
              \includegraphics[height=3cm]{#1}
            };}}]
      \draw     [help lines] (0,0) grid (3,2);

      \draw [path image=brave-gnu-world-logo,draw=blue,thick]
              (0,1) circle (1);
      \draw [path image=brave-gnu-world-logo,draw=red,very thick,->]
              (1,0) parabola[parabola height=2cm] (3,0);

    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/path:picture",
         meta = "⟨code⟩"
      },
      pattern = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/pattern",
         meta = "⟨name⟩"
      },
      ["pattern color"] = {
         details = [[
This option is used to set the color to be used for form-only patterns.
This option has no effect on inherently colored patterns.

    \begin{tikzpicture}
      \draw[pattern color=red,pattern=fivepointed stars]  (0,0) circle (1cm);
      \draw[pattern color=blue,pattern=fivepointed stars] (0,0) rectangle (3,1);
    \end{tikzpicture}

    \begin{tikzpicture}
      \def\mypath{(0,0) -- +(0,1) arc (180:0:1.5cm) -- +(0,-1)}
      \fill   [red]                                \mypath;
      \pattern[pattern color=white,pattern=bricks] \mypath;
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/pattern:color",
         meta = "⟨color⟩"
      },
      ["patterns/bottom left"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/patterns/bottom:left",
         meta = "⟨point⟩"
      },
      ["patterns/bounding box"] = {
         details = [[
This is a shorthand to set the bounding box. It will assign the first
point to bottom left and the second point to top right.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/patterns/bounding:box",
         meta = "⟨point⟩ and ⟨point⟩"
      },
      ["patterns/infer tile bounding box"] = {
         details = [[
Instead of specifying the bounding box by hand, you can ask TikZ to
infer the size of the bounding box for you. The ⟨dimension⟩ parameter is
padding that is added around the bounding box.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/patterns/infer:tile:bounding:box",
         meta = "⟨dimension⟩"
      },
      ["patterns/tile size"] = {
         details = [[
Instead of a PGF name point, this key takes a TikZ point, e.g. (3,3).
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/patterns/tile:size",
         meta = "⟨point⟩"
      },
      ["patterns/tile transformation"] = {
         details = [[
Instead of a PGF transformation, this key takes a list of keys and value
and extracts the resulting transformation from them, e.g. rotate=30.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/patterns/tile:transformation",
         meta = "⟨transformation⟩"
      },
      ["patterns/top right"] = {
         details = [[
Instead of a PGF name point, this key takes a TikZ point,
e.g. (3.1,3.1).
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/patterns/top:right",
         meta = "⟨point⟩"
      },
      perspective = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/perspective",
         meta = "⟨vanishing points⟩"
      },
      ["perspective/p"] = {
         details = [[
The location of the vanishing point that determines the 'strength' of
the perspective in $x$-direction can be set with the p key.

    \begin{tikzpicture}[
      3d view,
      perspective={
        p = {(5,0,0)}}]
      \simplecuboid{2}{2}{2}
      \simpleaxes{2}{2}{2}
    \end{tikzpicture}

Note also that when only p is provided, the perspective in $y$ and $z$
direction is turned off.

To turn off the perspective in $x$-direction, one must set the $x$
component of p to 0 (e.g. p={(0,a,b)}, where a and b can be any number
and will be ignored). Or one can provide q and r and omit p.

By changing the $y$ and $z$ components of p, one can achieve various
effects.

    \begin{tikzpicture}[
      3d view,
      perspective={
        p = {(5,0,1)}}]
      \simplecuboid{2}{2}{2}
      \simpleaxes{2}{2}{2}
    \end{tikzpicture}

    \begin{tikzpicture}[
      3d view,
      perspective={
        p = {(5,1,0)}}]
      \simplecuboid{2}{2}{2}
      \simpleaxes{2}{2}{2}
    \end{tikzpicture}

    \begin{tikzpicture}[
      3d view,
      perspective={
        p = {(5,1,1)}}]
      \simplecuboid{2}{2}{2}
      \simpleaxes{2}{2}{2}
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/perspective/p",
         meta = "{x,y,z}"
      },
      ["perspective/q"] = {
         details = [[
Similar to p, but can be turned off by setting its $y$ component to 0.

    \begin{tikzpicture}[
      3d view,
      perspective={
        q = {(0,5,0)}}]
      \simplecuboid{2}{2}{2}
      \simpleaxes{2}{2}{2}
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/perspective/q",
         meta = "{x,y,z}"
      },
      ["perspective/r"] = {
         details = [[
Similar to p, but can be turned off by setting its $z$ component to 0.

    \begin{tikzpicture}[
      3d view,
      perspective={
        r = {(0,0,5)}}]
      \simplecuboid{2}{2}{2}
      \simpleaxes{2}{2}{2}
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/perspective/r",
         meta = "{x,y,z}"
      },
      ["pic actions"] = {
         details = [[
This key is a style that can be used (only) inside the code of a pic.
There, it will set the "action" keys set inside the ⟨options⟩ of the pic
("actions" are drawing, filling, shading, and clipping or any
combination thereof).

To see how this key works, let us define the following pic:

    \tikzset{
      my pic/.pic = {
        \path [pic actions] (0,0) circle[radius=3mm];
        \draw (-3mm,-3mm) rectangle (3mm,3mm);
      }
    }

In the code, whether or not the circle gets drawn/filled/shaded depends
on which options where given to the pic command when it is used. In
contrast, the rectangle will always (just) be drawn.

     (0,0) circle[radius=3mm];
        \draw (-3mm,-3mm) rectangle (3mm,3mm);
      }
    }}]
    \tikz \pic                      {my pic}; \space
    \tikz \pic [red]                {my pic}; \space
    \tikz \pic [draw]               {my pic}; \space
    \tikz \pic [draw=red]           {my pic}; \space
    \tikz \pic [draw, shading=ball] {my pic}; \space
    \tikz \pic [fill=red!50]        {my pic};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/pic:actions"
      },
      ["pic text"] = {
         details = [[
This macro stores the ⟨text⟩ in the macro \tikzpictext, which is \let to
\relax by default. Setting the pic text to some value is the "preferred"
way of communicating a (single) piece of text that should become part of
a pic (typically of a node). In particular, the quotes library maps
quoted parameters to this key.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/pic:text",
         meta = "⟨text⟩"
      },
      ["pic text options"] = {
         details = [[
This macro stores the ⟨options⟩ in the macro \tikzpictextoptions, which
is \let to the empty string by default. The quotes library maps options
for quoted parameters to this key.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/pic:text:options",
         meta = "⟨options⟩"
      },
      ["pic type"] = {
         details = [[
This key sets the pic type of the current pic. When this option is used
inside an option block of a pic, the parsing of the pic ends immediately
and no pic type in braces is expected. (In other words, this option
behaves exactly like the node contents option and, indeed, the two are
interchangeable.)

     (0,0) to [bend left] (3mm,0);
      },
    }}]
    \tikz {
      \path (0,0) pic [pic type = seagull]
            (1,0) pic                      {seagull};
    }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/pic:type",
         meta = "⟨pic type⟩"
      },
      ["pics/background code"] = {
         details = [[
Like foreground code, only that the ⟨code⟩ is always put behind the
path, except when the behind path option is applied to the pic, then the
background code is drawn in front of the "behind path" code.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/pics/background:code",
         meta = "⟨code⟩"
      },
      ["pics/code"] = {
         details = [[
This key stores the ⟨code⟩ that should be drawn in the current pic.
Normally, setting this key is done by the ⟨pic type⟩, but you can also
set it in the ⟨options⟩ and leave the ⟨pic type⟩ empty:

    \tikz \pic [pics/code={\draw (-3mm,0) to[bend left] (0,0)
                                          to[bend left] (3mm,0);}]
          {}; % no pic type specified
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/pics/code",
         meta = "⟨code⟩"
      },
      ["pics/foreground code"] = {
         details = [[
This key stores ⟨code⟩ that will always be drawn in front of the current
path, even when behind path is used. If behind path is not used and code
is (also) set, the code of code is drawn first, following by the
foreground ⟨code⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/pics/foreground:code",
         meta = "⟨code⟩"
      },
      pin = {
         details = [[
This option is quite similar to the label option, but there is one
difference: In addition to adding an extra node to the picture, it also
adds an edge from this node to the main node. This causes the node to
look like a pin that has been added to the main node:

    \tikz \node [circle,fill=blue!50,minimum size=1cm,pin=60:$q_0$] {};

The meaning of the ⟨options⟩ and the ⟨angle⟩ and the ⟨text⟩ is exactly
the same as for the node option. Only, the options and styles the
influence the way pins look are different:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/pin",
         meta = "[⟨options⟩]⟨angle⟩:⟨text⟩"
      },
      ["pin distance"] = {
         details = [[
This ⟨distance⟩ is used instead of the label distance for the distance
between the main node and the label node.

    \tikz[pin distance=1cm]
      \node [circle,draw,pin=right:X,
                         pin=above right:Y,
                         pin=above:Z]       {my circle};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/pin:distance",
         meta = "⟨distance⟩"
      },
      ["pin edge"] = {
         details = [[
This option can be used to set the options that are to be used in the
edge created by the pin option.

    \tikz[pin distance=10mm]
      \node [circle,draw,pin={[pin edge={blue,thick}]right:X},
                         pin=above:Z]       {my circle};

    \tikz [every pin edge/.style={},
           initial/.style={pin={[pin distance=5mm,
                                 pin edge={<-,shorten <=1pt}]left:start}}]
      \node [circle,draw,initial] {my circle};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/pin:edge",
         meta = "⟨options⟩"
      },
      ["pin position"] = {
         details = [[
The default pin position. Works like label position.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/pin:position",
         meta = "⟨angle⟩"
      },
      place = {
         details = [[
This style indicates that a node is a place of a Petri net. Usually, the
text of the node should be empty since places do not contain any text.
You should use the label option to add text outside the node like its
name or its capacity. You should use the tokens options, explained in
Section ??, to add tokens inside the place.

    \begin{tikzpicture}
      \node[place,label=above:$p_1$,tokens=2]        (p1) {};
      \node[place,label=below:$p_2\ge1$,right=of p1] (p2) {};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/place"
      },
      ["plane origin"] = {
         details = [[
Origin of the plane.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/plane:origin",
         meta = "⟨point⟩"
      },
      ["plane x"] = {
         details = [[
Unit vector of the $x$-direction in the new plane.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/plane:x",
         meta = "⟨point⟩"
      },
      ["plane y"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/plane:y",
         meta = "⟨point⟩"
      },
      ["point down"] = {
         details = [[
This is the same as rotate=-90.

    \tikz [circuit ee IEC] \node [diode,point down] {};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/point:down"
      },
      ["point left"] = {
         details = [[
This is the same as rotate=-180.

    \tikz [circuit ee IEC] \node [diode,point left] {};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/point:left"
      },
      ["point right"] = {
         details = [[
This key has no effect.

    \tikz [circuit ee IEC] \node [diode,point right] {};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/point:right"
      },
      ["point up"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/point:up"
      },
      ["polar comb"] = {
         details = [[
This option causes a line from the origin to the point to be added to
the path for each plot point.

    \tikz \draw plot[polar comb,
         mark=pentagon*,mark options={fill=white,draw=red},mark size=4pt]
       coordinates {(0:1cm) (30:1.5cm) (160:.5cm) (250:2cm) (-60:.8cm)};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/polar:comb"
      },
      pos = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/pos",
         meta = "⟨fraction⟩"
      },
      post = {
         details = [[
This style is also used with paths leading from a transition to a place,
but this time the place is in the post-set of the transition. Again,
feel free to redefine it.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/post"
      },
      postaction = {
         details = [[
The postactions work in the same way as the preactions, only they are
applied after the main action has been taken. Like preactions, multiple
postaction options may be given to a \path command, in which case the
path is reused several times, each time with a different set of options
in force.

If both pre- and postactions are specified, then the preactions are
taken first, then the main action, and then the post actions.

In the first example, we use a postaction to draw the path, after it has
already been drawn:

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);

      \draw
        [postaction={draw,line width=2mm,blue}]
        [line width=4mm,red,fill=white] (0,0) rectangle (2,2);
    \end{tikzpicture}

In another example, we use a postaction to "colorize" a path:

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw
        [postaction={path fading=south,fill=white}]
        [postaction={path fading=south,fading angle=45,fill=blue,opacity=.5}]
        [left color=black,right color=red,draw=white,line width=2mm]
                   (0,0) rectangle (1,2)
                   (1,2) circle (5mm);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/postaction",
         meta = "⟨options⟩"
      },
      pre = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/pre"
      },
      ["pre and post"] = {
         details = [[
This style is to be used to indicate that a place is both in the pre-
and post-set of a transition.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/pre:and:post"
      },
      preaction = {
         details = [[
This option can be given to a \path command (or to derived commands like
\draw which internally call \path). Similarly to options like draw, this
option only has an effect when given to a \path or as part of the
options of a node; as an option to a {scope} it has no effect.

When this option is used on a \path, the effect is the following: When
the path has been completely constructed and is about to be used, a
scope is created. Inside this scope, the path is used but not with the
original path options, but with ⟨options⟩ instead. Then, the path is
used in the usual manner. In other words, the path is used twice: Once
with ⟨options⟩ in force and then again with the normal path options in
force.

Here is an example in which the path consists of a rectangle. The main
action is to draw this path in red (which is why we see a red
rectangle). However, the preaction is to draw the path in blue, which is
why we see a blue rectangle behind the red rectangle.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);

      \draw
        [preaction={draw,line width=4mm,blue}]
        [line width=2mm,red] (0,0) rectangle (2,2);
    \end{tikzpicture}

Note that when the preactions are preformed, then the path is already
"finished". In particular, applying a coordinate transformation to the
path has no effect. By comparison, applying a canvas transformation does
have an effect. Let us use this to add a "shadow" to a path. For this,
we use the preaction to fill the path in gray, shifted a bit to the
right and down:

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw
        [preaction={fill=black,opacity=.5,
                    transform canvas={xshift=1mm,yshift=-1mm}}]
        [fill=red] (0,0) rectangle (1,2)
                   (1,2) circle (5mm);
    \end{tikzpicture}

Naturally, you would normally create a style shadow that contains the
above code. The shadows library, see Section ??, contains predefined
shadows of this kind.

It is possible to use the preaction option multiple times. In this case,
for each use of the preaction option, the path is used again (thus, the
⟨options⟩ do not accumulate in a single usage of the path). The path is
used in the order of preaction options given.

In the following example, we use one preaction to add a shadow and
another to provide a shading, while the main action is to use a pattern.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw [pattern=fivepointed stars]
        [preaction={fill=black,opacity=.5,
                    transform canvas={xshift=1mm,yshift=-1mm}}]
        [preaction={top color=blue,bottom color=white}]
                   (0,0) rectangle (1,2)
                   (1,2) circle (5mm);
    \end{tikzpicture}

A complicated application is shown in the following example, where the
path is used several times with different fadings and shadings to create
a special visual effect:

    \begin{tikzpicture}
      [
        % Define an interesting style
        button/.style={
          % First preaction: Fuzzy shadow
          preaction={fill=black,path fading=circle with fuzzy edge 20 percent,
                     opacity=.5,transform canvas={xshift=1mm,yshift=-1mm}},
          % Second preaction: Background pattern
          preaction={pattern=#1,
                     path fading=circle with fuzzy edge 15 percent},
          % Third preaction: Make background shiny
          preaction={top color=white,
                     bottom color=black!50,
                     shading angle=45,
                     path fading=circle with fuzzy edge 15 percent,
                     opacity=0.2},
          % Fourth preaction: Make edge especially shiny
          preaction={path fading=fuzzy ring 15 percent,
                     top color=black!5,
                     bottom color=black!80,
                     shading angle=45},
          inner sep=2ex
        },
        button/.default=horizontal lines light blue,
        circle
      ]

      \draw [help lines] (0,0) grid (4,3);

      \node [button] at (2.2,1) {\Huge Big};
      \node [button=crosshatch dots light steel blue,
             text=white] at (1,1.5) {Small};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/preaction",
         meta = "⟨options⟩"
      },
      prefix = {
         details = [[
The ⟨prefix⟩ is put before each plot file name. The default is
\jobname., but if you have many plots, it might be better to use, say
plots/ and have all plots placed in a directory. You have to create the
directory yourself.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/prefix",
         meta = "⟨prefix⟩"
      },
      ["prefix after command"] = {
         details = [[
Works like append after command, only the accumulation order is inverse:
The ⟨path⟩ is added before any earlier paths added using either
append after command or prefix after command.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/prefix:after:command",
         meta = "⟨path⟩"
      },
      ["quotes mean label"] = {
         details = [[
When this option is used (which is the default when this library is
loaded), then, as described above, inside the options of a node a
special syntax check is done.

The syntax. For each string in the list of options it is tested whether
it starts with a quotation mark (note that this will never happen for
normal keys since the normal keys of TikZ do not start with quotation
marks). When this happens, the ⟨string⟩ should not be a key--value pair,
but, rather, must have the form:

  "⟨text⟩"’⟨options⟩

(We will discuss the optional apostrophe in a moment. It is not really
important for the current option, but only for edge labels, which are
discussed later).

Transformation to a label option. When a ⟨string⟩ has the above form, it
is treated (almost) as if you had written

  label={[⟨options⟩]⟨text⟩}

instead. The "almost" refers to the following additional feature: In
reality, before the ⟨options⟩ are executed inside the label command, the
direction keys above, left, below right and so on are redefined so that
above is a shorthand for label position=90 and similarly for the other
keys. The net effect is that in order to specify the position of the
⟨text⟩ relative to the main node you can just put something like left or
above right inside the ⟨options⟩:

    \tikz
      \node ["$90^\circ$" above, "$180^\circ$" left, circle, draw] {circle};

Alternatively, you can also use ⟨direction⟩:⟨actual text⟩ as your
⟨text⟩. This works since the label command allows you to specify a
direction at the beginning when it is separated by a colon:

    \tikz
      \node ["90:$90^\circ$", "left:$180^\circ$", circle, draw] {circle};

Arguably, placing above or left behind the ⟨text⟩ seems more natural
than having it inside the ⟨text⟩.

In addition to the above, before the ⟨options⟩ are executed, the
following style is also executed:

Handling commas and colons inside the text. The ⟨text⟩ may not contain a
comma, unless it is inside curly braces. The reason is that the key
handler separates the total options of a node along the commas it finds.
So, in order to have text containing a comma, just add curly braces
around either the comma or just around the whole ⟨text⟩:

    \tikz \node ["{yes, we can}", draw] {foo};

The same is true for a colon, only in this case you may need to surround
specifically the colon by curly braces to stop the label option from
interpreting everything before the colon as a direction:

    \tikz \node ["yes{:} we can", draw] {foo};

The optional apostrophe. Following the closing quotation marks in a
⟨string⟩ there may (but need not) be a single quotation mark (an
apostrophe), possibly surrounded by whitespaces. If it is present, it is
simply added to the ⟨options⟩ as another option (and, indeed, a single
apostrophe is a legal option in TikZ, it is a shorthand for swap):

  String         has the same effect as
  -------------- ----------------------------------------------
  "foo"’         "foo" {’}
  "foo"’ red     "foo" {’,red}
  "foo"’{red}    "foo" {’,red}
  "foo"{’,red}   "foo" {’,red}
  "foo"{red,’}   "foo" {red,’}
  "foo"{’red}    "foo" {’red} (illegal; there is no key ’red)
  "foo" red’     "foo" {red’} (illegal; there is no key red’)
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/quotes:mean:label"
      },
      ["quotes mean pin"] = {
         details = [[
This option has exactly the same effect as quotes mean label, only
instead of transforming quoted text to the label option, they get
transformed to the pin option:

    \tikz [quotes mean pin]
      \node ["$90^\circ$" above, "$180^\circ$" left, circle, draw] {circle};

Instead of every label quotes, the following style is executed with each
such pin:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/quotes:mean:pin"
      },
      radius = {
         details = [[
Sets the x radius and y radius simultaneously.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/radius",
         meta = "⟨value⟩"
      },
      range = {
         details = [[
This key sets the range of the plot. If set, all points whose
$y$-coordinates lie outside this range will be considered to be outliers
and will cause jumps in the plot, by default:

    \tikz \draw[scale=0.5,domain=-3.141:3.141, samples=100, smooth, range=-3:3]
      plot[id=tan-example] function{tan(x)};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/range",
         meta = "⟨start⟩:⟨end⟩"
      },
      ["raw gnuplot"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/raw:gnuplot"
      },
      ["rdf engine"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine",
         meta = "⟨rdf keys⟩"
      },
      ["rdf engine on"] = {
         details = [[
Switches "on" the generation of RDF information for the current
TeX scope. The idea is that libraries can internally use the rdf engine
key (explained below) a lot in order to provide good semantic
information in the output when desired, but need not worry that this
will bloat output files since users have to use this key explicitly to
include semantic information in the output.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine:on"
      },
      ["rdf engine/get new resource curie"] = {
         details = [[
The ⟨macro⟩ will be set to a new unique curie that can be used anywhere
where a curie is allowed. Here is an example how we can add a state and
a transition container to an automaton, both of which have no
corresponding scope in TikZ.

    \tikz [ name = my automaton,
            rdf engine = {
              get new resource curie = \statecurie,
              get new resource curie = \transitiocurie,
              statement = {
                subject   = (my automaton),
                predicate = automata:hasStateSet,
                object    = \statecurie },
              statement = {
                subject   = \statecurie,
                hat type  = automata:stateSet },
              statement = {
                subject   = (my automaton),
                predicate = automata:hasTransitionSet,
                object    = \transitiocurie },
              statement = {
                subject   = \transitiocurie,
                hat type  = automata:transitionSet } } ] { ... }

The ⟨macro⟩ will be valid for the whole scope.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/get:new:resource:curie",
         meta = "⟨macro⟩"
      },
      ["rdf engine/get scope curie"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/get:scope:curie",
         meta = "⟨macro⟩"
      },
      ["rdf engine/prefix"] = {
         details = [[
Inside the current scope, you can use ⟨prefix⟩: inside curies (compact
universal resource identifier expressions, see the RDFA specification)
as an abbreviation for the ⟨iri⟩. (It has the same effect as the prefix
attribute in RDFa.) You can use this key several times for a given
scope.

    \scoped [rdf engine = {
      prefix = {rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns\tikzrdfhashmark},
      prefix = {automata: http://www.tcs.uni-luebeck.de/ontologies/2016/04/28/automata/},
      statement = { ..., predicate = rdf:type, object = automata:state },
      statement = { ..., predicate = rdf:type, object = automata:final },
      }] ...

The above could also be written more verbosely as

    \scoped [rdf engine = {
      statement = { ...,
        predicate = http://www.w3.org/1999/02/22-rdf-syntax-ns\tikzrdfhashmark type,
        object = http://www.tcs.uni-luebeck.de/ontologies/2016/04/28/automata/state }
      },
      statement = { ...,
        predicate = http://www.w3.org/1999/02/22-rdf-syntax-ns\tikzrdfhashmark type,
        object = http://www.tcs.uni-luebeck.de/ontologies/2016/04/28/automata/final }
      }] ...

The use of the command \tikzrdfhashmark is necessary since TeX assigns a
special meaning to hash marks. The command simple expands to a "normal"
hash mark for use in texts.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/prefix",
         meta = "⟨prefix: iri⟩"
      },
      ["rdf engine/scope is new context"] = {
         details = [[
This key executes get scope curie=\tikzrdfcontext, thereby setting the
macro \tikzrdfcontext to the current scope. The idea is the key is used
with "major resources" and that keys can use this macro as the subject
of statements if no subject is given explicitly. For instance, a title
key might be defined as follows:

    title/.style = {
      rdf engine = { statement = {
          subject   = \tikzrdfcontext,
          predicate = dc:Title,
          object    = "#1"
    } } }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/scope:is:new:context"
      },
      ["rdf engine/statement"] = {
         details = [[
Each use of this key will add one RDF statement to the output file. The
⟨options⟩ will be executed with the path prefix
/tikz/rdf engine/statements and must use the three keys subject,
predicate, and object to specify the three components of the statement
(these keys can, however, be called by styles internally, so not all
statements will explicitly set these three keys). Note that all three
must always be set, it is not possible to setup, say, just a subject for
a scope and then omit the subject for statements inside the scope.
(However, using styles you can setup things in such a way that a certain
subject is used for several statements.)

    \tikz [rdf engine = {
      statement = {
        subject   = http://www.example.org/persons/Einstein,
        predicate = http://www.example.org/predicates/isA,
        object    = http://www.example.org/professions/physicist
      },
      statement = {
        subject   = http://www.example.org/persons/Curie,
        predicate = http://www.example.org/predicates/isA,
        object    = http://www.example.org/professions/physicist
      }}] { ... }

The statements are normally added at the beginning of the scope where
the rdf enging command is used (except when the object is scope content,
which is explained later). This means that when you use prefix inside an
rdf engine command, it will apply to all statements, regardless of the
order.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statement",
         meta = "{options}"
      },
      ["rdf engine/statements/has as member"] = {
         details = [[
This key may only be added to statements whose subject was previously
used as a subject in a statement containing the is a container key. In
this case, the internal counter will be increased and the predicate will
be set to rdf:_ ⟨count⟩. This means that we can write the above code as:

    \tikz { ...

      \scoped [rdf engine = {
        statement = {
          subject   = (safe),
          has type  = rdf:Seq,
          is a container,
        },
        statement = {
          subject   = (safe),
          has as member,
          object    = (coins)
        },
        statement = {
          subject   = (safe),
          has as member,
          object    = (gold)
        } }];
    }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/has:as:member"
      },
      ["rdf engine/statements/has type"] = {
         details = [[
This style is a shorthand for predicate=rdf:type and object=⟨type⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/has:type",
         meta = "⟨type⟩"
      },
      ["rdf engine/statements/is a bag"] = {
         details = [[
This is a shorthand for predicate = rdf:Bag, is a container.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/is:a:bag"
      },
      ["rdf engine/statements/is a container"] = {
         details = [[
Add this key to a statement in order to tell TikZ that it should setup a
special counter for the subject of the statement that keeps track of the
container's children.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/is:a:container"
      },
      ["rdf engine/statements/is a sequence"] = {
         details = [[
This is a shorthand for predicate = rdf:Seq, is a container. In the
above example we could say:

    \tikz { ...

      \scoped [rdf engine = {
        statement = {
          subject   = (safe),
          is a sequence
        },
        ... } ]; }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/is:a:sequence"
      },
      ["rdf engine/statements/is an alternative"] = {
         details = [[
This is a shorthand for predicate = rdf:Alt, is a container.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/is:an:alternative"
      },
      ["rdf engine/statements/object"] = {
         details = [[
Sets the object for the statement. The syntax allowed for the ⟨object⟩
is as follows:

1.  As for subject and predicate you can use a curie here. This is the
    default unless one of the following special cases is used:

2.  As for subject and predicate, you can use the syntax (⟨name of node
    or scope⟩) to create and use a curie for the node or scope.

3.  If the ⟨object⟩ starts with ", it must have the syntax "⟨literals⟩".
    In this case, the object of the statement is not a curie (not a
    normal "resource") but the string of ⟨literals⟩ given.

4.  If the ⟨object⟩ is the text "scope content", the object of the
    statement is actually the whole contents of the scope to which this
    statement is attached.

5.  The two previous cases can be combined in the form of an object of
    the form "⟨literals⟩" and scope content. In this case, the contents
    of the scope is "normally" the object, but this gets "overruled" by
    the ⟨literals⟩. Formally, this means that the object is the
    ⟨literals⟩, but the intended semantics is that the object is the
    scope content, only for further processing it should be considered
    to be ⟨literals⟩. A typical example is the case where the scope
    content is, say, the text "January 1st, 2000" but the ⟨literals⟩ are
    set to 2000-01-01, which is easier for software to process:

        \node [rdf engine = {
          statement = {
            subject = ...,
            predicate = dc:Date,
            object = "2000-01-01" and scope content
          } } ] { January 1st, 2000 };

For the last two cases, only one statement may be given per scope that
has the scope content as its object; if more than one is given, the last
one wins. This is the reason why several uses of predicate are allowed
in a statement.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/object",
         meta = "⟨object⟩"
      },
      ["rdf engine/statements/predicate"] = {
         details = [[
Sets the predicate for the statement. The syntax is exactly the same as
for the subject. Unlike for subjects, you can use the predicate key
several times inside a single statement and the uses will "accumulate"
and several statements are created, namely one statement for each use of
predicate for the subject and object specified inside the use of
statement. This behavior is not very systematic (it violates the rule
"one statement per statement") and you should normally use the statement
once for each use of the predicate key. However, in conjunction with the
object scope content it is necessary to allow this behavior.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/predicate",
         meta = "⟨predicate⟩"
      },
      ["rdf engine/statements/subject"] = {
         details = [[
Sets the subject of the to-be-created statement. The ⟨subject⟩ can be in
one of two possible formats:

1.  A curie (a compact universal resource identifier expression, see the
    RDFA specification for details). Examples are standard URLs like
    http://www.example.org, but also text like # my_ automaton. Note
    that in order to include a hashmark in a curie you should use the
    command \tikzrdfhashmark, which expands to a hash mark (TeX treats
    hash marks in a special way, which is why this command is used
    here).

2.  When the ⟨subject⟩ starts with an opening parenthesis, that is, with
    "(", the ⟨subject⟩ must have the form (⟨node or scope name⟩). In
    this case, the ⟨node or scope name⟩ must be the name of an already
    existing node (the current node or scope is considered as "existing"
    here). Then, the curie # ⟨id⟩ is used as subject, where the ⟨id⟩ is
    a unique internal identifier for the node.

    As an example, suppose you wish to specify that a node has some
    other node as child, you could write the following:

        \tikz [ rdf engine = { prefix = { rels: http://www.example.org/relations/} } ] {
          \node (fritz)          { Fritz };
          \node (heinz) at (2,0) { Heinz };
          \draw [->] (fritz) -- (heinz)
                [rdf engine = {
                  statement = {
                    subject = (fritz),
                    predicate = rels:isSonOf,
                    object  = (heinz)
                  } } ];
        }

You can use a macro as ⟨subject⟩, it will be expanded before the above
syntax check is done.

If you use the subject key several times inside a single statement
command, (only) the last subject is used.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rdf:engine/statements/subject",
         meta = "⟨subject⟩"
      },
      relationship = {
         details = [[
This style works like entity, only it is to be used for relationships.
Again, relationships are actually relationship types.

    \begin{tikzpicture}
      \node[entity] (sheep)  at (0,0)   {Sheep};
      \node[entity] (genome) at (2,0)   {Genome};
      \node[relationship]    at (1,1.5) {has}
        edge (sheep)
        edge (genome);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/relationship"
      },
      relative = {
         details = [[
This option tells TikZ whether the in and out angles should be
considered absolute or relative. Absolute means that an out angle of
30$^\circ$ means that the curve leaves the start coordinate at an angle
of 30$^\circ$ relative to the paper (unless, of course, further
transformations have been installed). A relative angle is, by
comparison, measured relative to a straight line from the start
coordinate to the target coordinate. Thus, a relative angle of
30$^\circ$ means that the curve will bend to the left from the line
going straight from the start to the target. For the target, the
relative coordinate is measured in the same manner, namely relative to
the line going from the start to the target. Thus, an angle of
150$^\circ$ means that the curve will reach target coming slightly from
the left.

    \begin{tikzpicture}[out=45,in=135,relative]
      \draw (0,0) to (1,0)
                  to (2,1)
                  to (2,2);
    \end{tikzpicture}

    \begin{tikzpicture}[out=90,in=90,relative]
      \node [circle,draw] (a) at (0,0) {a};
      \node [circle,draw] (b) at (1,1) {b};
      \node [circle,draw] (c) at (2,2) {c};

      \path (a) edge (b)
                edge (c);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/relative",
         meta = "⟨true or false⟩"
      },
      ["remember picture"] = {
         details = [[
This option tells TikZ that it should attempt to remember the position
of the current picture on the page. This attempt may fail depending on
which backend driver is used. Also, even if remembering works, the
position may only be available on a second run of TeX.

Provided that remembering works, you may consider saying

    \tikzset{every picture/.append style={remember picture}}

to make TikZ remember all pictures. This will add one line in the .aux
file for each picture in your document -- which typically is not very
much. Then, you do not have to worry about remembered pictures at all.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/remember:picture",
         meta = "⟨boolean⟩"
      },
      ["reset cm"] = {
         details = [[
Completely resets the coordinate transformation matrix to the identity
matrix. This will destroy not only the transformations applied in the
current scope, but also all transformations inherited from surrounding
scopes. Do not use this option, unless you really, really know what you
are doing.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/reset:cm"
      },
      resistor = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/resistor",
         meta = "⟨options⟩"
      },
      right = {
         details = [[
Similar to above.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/right",
         meta = "⟨offset⟩"
      },
      ["right color"] = {
         details = [[
Works like left color.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/right:color",
         meta = "⟨color⟩"
      },
      ["right delimiter"] = {
         details = [[
Works as above.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/right:delimiter",
         meta = "⟨delimiter⟩"
      },
      ["right of"] = {
         details = [[

]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/right:of",
         meta = "⟨node⟩"
      },
      ["root concept"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/root:concept"
      },
      rotate = {
         details = [[
Rotates the coordinate system by ⟨degree⟩:

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                 (0,0) -- (1,1) -- (1,0);
      \draw[rotate=40,blue] (0,0) -- (1,1) -- (1,0);
      \draw[rotate=-20,red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rotate",
         meta = "⟨degree⟩"
      },
      ["rotate around"] = {
         details = [[
Rotates the coordinate system by ⟨degree⟩ around the point ⟨coordinate⟩.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                                (0,0) -- (1,1) -- (1,0);
      \draw[rotate around={40:(1,1)},blue] (0,0) -- (1,1) -- (1,0);
      \draw[rotate around={-20:(1,1)},red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rotate:around",
         meta = "{⟨degree⟩:⟨coordinate⟩}"
      },
      ["rotate around x"] = {
         details = [[
This key sets the $x$, $y$ and $z$ vectors of the PGF $xyz$-coordinate
system so that they are rotated by ⟨angle⟩ around the axis corresponding
to the $x$-vector. The rotation is applied so that when looking towards
the origin along this axis, positive angles result in an anticlockwise
rotation.

    \begin{tikzpicture}[>=stealth]
      \draw [->] (0,0,0) -- (2,0,0) node [at end, right] {$x$};
      \draw [->] (0,0,0) -- (0,2,0) node [at end, left]  {$y$};
      \draw [->] (0,0,0) -- (0,0,2) node [at end, left]  {$z$};

      \draw [red,   rotate around x=0]  (0,0,0) -- (1,1,0) -- (1,0,0);
      \draw [green, rotate around x=45] (0,0,0) -- (1,1,0) -- (1,0,0);
      \draw [blue,  rotate around x=90] (0,0,0) -- (1,1,0) -- (1,0,0);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rotate:around:x",
         meta = "⟨angle⟩"
      },
      ["rotate around y"] = {
         details = [[
This key sets the $x$, $y$ and $z$ vectors of the PGF $xyz$-coordinate
system so that they are rotated by ⟨angle⟩ around the axis corresponding
to the $y$-vector. The rotation is applied so that when looking towards
the origin along this axis, positive angles result in an anticlockwise
rotation.

    \begin{tikzpicture}[>=stealth]
      \draw [->] (0,0,0) -- (2,0,0) node [at end, right] {$x$};
      \draw [->] (0,0,0) -- (0,2,0) node [at end, left]  {$y$};
      \draw [->] (0,0,0) -- (0,0,2) node [at end, left]  {$z$};

      \draw [red,   rotate around y=0]   (0,0,0) -- (1,1,0) -- (1,0,0);
      \draw [green, rotate around y=-45] (0,0,0) -- (1,1,0) -- (1,0,0);
      \draw [blue,  rotate around y=-90] (0,0,0) -- (1,1,0) -- (1,0,0);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rotate:around:y",
         meta = "⟨angle⟩"
      },
      ["rotate around z"] = {
         details = [[
This key sets the $x$, $y$ and $z$ vectors of the PGF $xyz$-coordinate
system so that they are rotated by ⟨angle⟩ around the axis corresponding
to the $z$-vector. The rotation is applied so that when looking towards
the origin along this axis, positive angles result in an anticlockwise
rotation.

    \begin{tikzpicture}[>=stealth]
      \draw [->] (0,0,0) -- (2,0,0) node [at end, right] {$x$};
      \draw [->] (0,0,0) -- (0,2,0) node [at end, left]  {$y$};
      \draw [->] (0,0,0) -- (0,0,2) node [at end, left]  {$z$};

      \draw [red,   rotate around z=0]  (0,0) -- (1,1) -- (1,0);
      \draw [green, rotate around z=45] (0,0) -- (1,1) -- (1,0);
      \draw [blue,  rotate around z=90] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rotate:around:z",
         meta = "⟨angle⟩"
      },
      ["rotate fit"] = {
         details = [[
This key fits ⟨coordinates or nodes⟩ inside a node that is rotated by
⟨angle⟩. As a side effect, it also sets the /tikz/rotate key.

    \begin{tikzpicture}[inner sep=0pt,thick,
      dot/.style={fill=blue,circle,minimum size=3pt}]
      \draw[help lines] (0,0) grid (3,2);
      \node[dot] (a) at (1,1) {};
      \node[dot] (b) at (2,2) {};
      \node[dot] (c) at (1,2) {};
      \node[dot] (d) at (1.25,0.25) {};
      \node[dot] (e) at (1.75,1.5) {};
      \node[draw, fit=(a) (b) (c) (d) (e)] {};
      \node[draw=red, rotate fit=30, fit=(a) (b) (c) (d) (e)] {};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rotate:fit",
         meta = "⟨angle⟩"
      },
      ["rounded corners"] = {
         details = [[
When this option is in force, all corners (places where a line is
continued either via line-to or a curve-to operation) are replaced by
little arcs so that the corner becomes smooth.

    \tikz \draw [rounded corners] (0,0) -- (1,1)
               -- (2,0) .. controls (3,1) .. (4,0);

The ⟨inset⟩ describes how big the corner is. Note that the ⟨inset⟩ is
not scaled along if you use a scaling option like scale=2.

    \begin{tikzpicture}
      \draw[color=gray,very thin] (10pt,15pt) circle[radius=10pt];
      \draw[rounded corners=10pt] (0,0) -- (0pt,25pt) -- (40pt,25pt);
    \end{tikzpicture}

You can switch the rounded corners on and off "in the middle of path"
and different corners in the same path can have different corner radii:

    \begin{tikzpicture}
      \draw (0,0) [rounded corners=10pt] -- (1,1) -- (2,1)
                         [sharp corners] -- (2,0)
                   [rounded corners=5pt] -- cycle;
    \end{tikzpicture}

Here is a rectangle with rounded corners:

    \tikz \draw[rounded corners=1ex] (0,0) rectangle (20pt,2ex);

You should be aware, that there are several pitfalls when using this
option. First, the rounded corner will only be an arc (part of a circle)
if the angle is $90^\circ$. In other cases, the rounded corner will
still be round, but "not as nice".

Second, if there are very short line segments in a path, the "rounding"
may cause inadvertent effects. In such case it may be necessary to
temporarily switch off the rounding using sharp corners.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/rounded:corners",
         meta = "⟨inset⟩"
      },
      ["row sep"] = {
         details = [[
This option works like column sep, only for rows. Here, too, you can
specify whether the space is added between the lower end of the first
row and the upper end of the second row, or whether the space is
computed between the origins of the two rows.

    \begin{tikzpicture}
      \matrix [draw,row sep=1cm,nodes=draw]
      {
        \node (a) {123}; & \node {1};   & \node {1}; \\
        \node (b) {12};  & \node {12};  & \node {1}; \\
        \node     {1};   & \node {123}; & \node {1}; \\
      };
      \draw [<->,red,thick] (a.south) -- (b.north) node [right,midway] {1cm};
    \end{tikzpicture}

    \begin{tikzpicture}
      \matrix [draw,row sep={1cm,between origins},nodes=draw]
      {
        \node (a) {123}; & \node {1};   & \node {1}; \\
        \node (b) {12};  & \node {12};  & \node {1}; \\
        \node     {1};   & \node {123}; & \node {1}; \\
      };
      \draw [<->,red,thick] (a.center) -- (b.center) node [right,midway] {1cm};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/row:sep",
         meta = "⟨spacing list⟩"
      },
      ["row ⟨number⟩"] = {
         details = [[
This style is used for every cell in row ⟨number⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/row:⟨number⟩"
      },
      ["row ⟨row number⟩ column ⟨column number⟩"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/row:⟨row:number⟩:column:⟨column:number⟩"
      },
      samples = {
         details = [[
Sets the number of samples used in the plot.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/samples",
         meta = "⟨number⟩"
      },
      ["samples at"] = {
         details = [[
This option specifies a list of positions for which the variable should
be evaluated. For instance, you can say samples at={1,2,8,9,10} to have
the variable evaluated exactly for values $1$, $2$, $8$, $9$, and $10$.
You can use the \foreach syntax, so you can use ... inside the ⟨sample
list⟩.

When this option is used, the samples and domain option are overruled.
The other way round, setting either samples or domain will overrule this
option.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/samples:at",
         meta = "⟨sample list⟩"
      },
      ["save path"] = {
         details = [[
Save the current soft path into ⟨macro⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/save:path",
         meta = "⟨macro⟩"
      },
      scale = {
         details = [[
Multiplies all coordinates by the given ⟨factor⟩. The ⟨factor⟩ should
not be excessively large in absolute terms or very close to zero.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw               (0,0) -- (1,1) -- (1,0);
      \draw[scale=2,blue] (0,0) -- (1,1) -- (1,0);
      \draw[scale=-1,red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/scale",
         meta = "⟨factor⟩"
      },
      ["scale around"] = {
         details = [[
Scales the coordinate system by ⟨factor⟩, with the "origin of scaling"
centered on ⟨coordinate⟩ rather than the origin.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                             (0,0) -- (1,1) -- (1,0);
      \draw[scale=2,blue]               (0,0) -- (1,1) -- (1,0);
      \draw[scale around={2:(1,1)},red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/scale:around",
         meta = "{⟨factor⟩:⟨coordinate⟩}"
      },
      ["scope fading"] = {
         details = [[
In principle, this key works in exactly the same way as the path fading
key. The only difference is, that the effect of the fading will persist
after the current path till the end of the scope. Thus, the ⟨fading⟩ is
applied to all subsequent drawings in the current scope, not just to the
current path. In this regard, the option works very much like the clip
option. (Note, however, that, unlike the clip option, fadings to not
accumulate unless a transparency group is used.)

The keys fit fading and fading transform have the same effect as for
path fading. Also that, just as for path fading, providing the
scope fading option with a {scope} only sets the name of the fading to
be used. You have to explicitly provide the scope fading with a path to
actually install a fading.

    \begin{tikzpicture}
      \fill [black!20] (-2,-2) rectangle (2,2);
      \pattern [pattern=checkerboard,pattern color=black!30]
                       (-2,-2) rectangle (2,2);

      % The bounding box of the shading:
      \draw [red] (-50bp,-50bp) rectangle (50bp,50bp);

      \path [scope fading=south,fit fading=false] (0,0);
      % fading is centered at its natural size

      \fill[red]   ( 90:1) circle (1);
      \fill[green] (210:1) circle (1);
      \fill[blue]  (330:1) circle (1);
    \end{tikzpicture}

In the following example we resize the fading to the size of the whole
picture:

    \begin{tikzpicture}
      \fill [black!20] (-2,-2) rectangle (2,2);
      \pattern [pattern=checkerboard,pattern color=black!30]
                       (-2,-2) rectangle (2,2);

      \path [scope fading=south] (-2,-2) rectangle (2,2);

      \fill[red]   ( 90:1) circle (1);
      \fill[green] (210:1) circle (1);
      \fill[blue]  (330:1) circle (1);
    \end{tikzpicture}

Scope fadings are also needed if you wish to fade a node.

    \tikz \node [scope fading=south,fading angle=45,text width=3.5cm]
    {
      This is some text that will fade out as we go right
      and down. It is pretty hard to achieve this effect in
      other ways.
    };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/scope:fading",
         meta = "⟨fading⟩"
      },
      semithick = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/semithick"
      },
      semitransparent = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/semitransparent"
      },
      set = {
         details = [[
This key can be used as an option with a node command. The ⟨set name⟩
must be the name of a node set that has previously been created inside
some enclosing scope via the new set key. The effect is that the current
node is added to the node set.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/set",
         meta = "⟨set name⟩"
      },
      shade = {
         details = [[
Causes the path to be shaded using the currently selected shading (more
on this later). If this option is used together with the draw option,
then the path is first shaded, then drawn.

It is not an error to use this option together with the fill option, but
it makes no sense.

    \tikz \shade (0,0) circle (1ex);

    \tikz \shadedraw (0,0) circle (1ex);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/shade"
      },
      shading = {
         details = [[
This selects a shading named ⟨name⟩. The following shadings are
predefined: axis, radial, and ball.

    \tikz \shadedraw [shading=axis] (0,0) rectangle (1,1);
    \tikz \shadedraw [shading=radial] (0,0) rectangle (1,1);
    \tikz \shadedraw [shading=ball] (0,0) circle (.5cm);

The shadings as well as additional shadings are described in more detail
in Section ??.

To change the color of a shading, special options are needed like
left color, which sets the color of an axis shading from left to right.
These options implicitly also select the correct shading type, see the
following example

    \tikz \shadedraw [left color=red,right color=blue]
        (0,0) rectangle (1,1);

For a complete list of the possible options see Section ?? once more.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/shading",
         meta = "⟨name⟩"
      },
      ["shading angle"] = {
         details = [[
This option rotates the shading (not the path!) by the given angle. For
example, we can turn a top-to-bottom axis shading into a left-to-right
shading by rotating it by $90^\circ$.

    \tikz \shadedraw [shading=axis,shading angle=90] (0,0) rectangle (1,1);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/shading:angle",
         meta = "⟨degrees⟩"
      },
      ["shadow scale"] = {
         details = [[
Shadows are scaled by ⟨factor⟩.

    \tikz [even odd rule]
      \draw [general shadow={fill=red,shadow scale=1.25}]
        (0,0) circle (.5) (0.5,0) circle (.5);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/shadow:scale",
         meta = "⟨factor⟩"
      },
      ["shadow xshift"] = {
         details = [[
Shadows are shifted horizontally by ⟨dimension⟩.

    \tikz [even odd rule]
      \draw [general shadow={fill=red,shadow xshift=-5pt}]
        (0,0) circle (.5) (0.5,0) circle (.5);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/shadow:xshift",
         meta = "⟨dimension⟩"
      },
      ["shadow yshift"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/shadow:yshift",
         meta = "⟨dimension⟩"
      },
      shape = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/shape",
         meta = "⟨shape name⟩"
      },
      ["sharp corners"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/sharp:corners"
      },
      ["sharp plot"] = {
         details = [[
This is the default and causes the points to be connected by straight
lines. This option is included only so that you can "switch back" if you
"globally" install, say, smooth.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/sharp:plot"
      },
      shift = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/shift",
         meta = "{⟨coordinate⟩}"
      },
      ["shift only"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/shift:only"
      },
      ["shorten <"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/shorten:<",
         meta = "⟨length⟩"
      },
      ["shorten >"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/shorten:>",
         meta = "⟨length⟩"
      },
      ["show background bottom"] = {
         details = [[
Works like the style for the top line.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/show:background:bottom"
      },
      ["show background grid"] = {
         details = [[
This style behaves similarly to the show background rectangle style, but
it will not use a rectangle path, but a grid. The lower left and upper
right corner of the grid is computed in the same way as for the
background rectangle:

    \begin{tikzpicture}[show background grid]
      \draw (0,0) ellipse (10mm and 5mm);
    \end{tikzpicture}

You can influence the background grid by setting the following style:

This option can be combined with the framed option (use the framed
option first):

    \tikzset{background grid/.style={thick,draw=red,step=.5cm},
             background rectangle/.style={rounded corners,fill=yellow}}
    \begin{tikzpicture}[framed,gridded]
      \draw (0,0) ellipse (10mm and 5mm);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/show:background:grid"
      },
      ["show background left"] = {
         details = [[
Works similarly.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/show:background:left"
      },
      ["show background rectangle"] = {
         details = [[
This style causes a rectangle to be drawn behind your graphic. This
style option must be given to the {tikzpicture} environment or to the
\tikz command.

    \begin{tikzpicture}[show background rectangle]
      \draw (0,0) ellipse (10mm and 5mm);
    \end{tikzpicture}

The size of the background rectangle is determined as follows: We start
with the bounding box of the picture. Then, a certain separator distance
is added on the sides. This distance can be different for the $x$- and
$y$-directions and can be set using the following options:

The following two styles make setting the inner separator a bit easier
to remember:

You can influence how the background rectangle is rendered by setting
the following style:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/show:background:rectangle"
      },
      ["show background right"] = {
         details = [[
Works similarly.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/show:background:right"
      },
      ["show background top"] = {
         details = [[
This style causes a single line to be drawn at the top of the background
rectangle. Normally, the line coincides exactly with the top line of the
background rectangle:

    \begin{tikzpicture}[
        background rectangle/.style={fill=yellow},
        framed,show background top]
      \draw (0,0) ellipse (10mm and 5mm);
    \end{tikzpicture}

The following option allows you to lengthen (or shorten) the line:

    \begin{tikzpicture}
      [background rectangle={fill=blue!20},
       outer frame sep=1ex,%
       show background top,%
       show background bottom,%
       show background left,%
       show background right]
      \draw (0,0) ellipse (10mm and 5mm);
    \end{tikzpicture}

You can influence how the line is drawn grid by setting the following
style:
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/show:background:top"
      },
      ["sibling angle"] = {
         details = [[
Sets the angle between siblings in the grow cyclic style.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/sibling:angle",
         meta = "⟨angle⟩"
      },
      ["sibling distance"] = {
         details = [[
This key specifies the distance between the anchors of the children of a
parent node.

    \begin{tikzpicture}
      [level distance=4mm,
       level 1/.style={sibling distance=8mm},
       level 2/.style={sibling distance=4mm},
       level 3/.style={sibling distance=2mm}]
      \coordinate
         child {
           child {child child}
           child {child child}
         }
         child {
           child {child child}
           child {child child}
         };
    \end{tikzpicture}

    \begin{tikzpicture}
      [level distance=10mm,
       every node/.style={fill=red!60,circle,inner sep=1pt},
       level 1/.style={sibling distance=20mm,nodes={fill=red!45}},
       level 2/.style={sibling distance=10mm,nodes={fill=red!30}},
       level 3/.style={sibling distance=5mm,nodes={fill=red!25}}]
      \node {31}
         child {node {30}
           child {node {20}
             child {node {5}}
             child {node {4}}
           }
           child {node {10}
             child {node {9}}
             child {node {1}}
           }
         }
         child {node {20}
           child {node {19}
             child {node {1}}
             child[missing]
           }
           child {node {18}}
         };
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/sibling:distance",
         meta = "⟨distance⟩"
      },
      size = {
         details = [[
Inside a spy scope, this is a shortcut for minimum size.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/size",
         meta = "⟨dimension⟩"
      },
      slice = {
         details = [[
This key works exactly like meet, only the second rule is changed:

1.  the to-be-viewed rectangle has minimal size that it encompasses all
    of the window rectangle.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/slice",
         meta = "⟨to-be-viewed corner⟩ rectangle ⟨to-be-viewed corner⟩ at ⟨window corner⟩ rectangle ⟨window corner⟩"
      },
      sloped = {
         details = [[
This option causes the node to be rotated such that a horizontal line
becomes a tangent to the curve. The rotation is normally done in such a
way that text is never "upside down". To get upside-down text, use can
use [rotate=180] or [allow upside down], see below.

    \tikz \draw (0,0) .. controls +(up:2cm) and +(left:2cm) .. (1,3)
        node foreach \p in {0,0.25,...,1} [sloped,above,pos=\p]{\p};

    \begin{tikzpicture}[->]
      \draw (0,0)   -- (2,0.5) node[midway,sloped,above] {$x$};
      \draw (2,-.5) -- (0,0)   node[midway,sloped,below] {$y$};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/sloped"
      },
      ["small circuit symbols"] = {
         details = [[
This style sets the default circuit symbol unit to 6pt.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/small:circuit:symbols"
      },
      ["small mindmap"] = {
         details = [[
This style includes the mindmap style, but additionally changes the
default size of concepts, fonts and distances so that a medium-sized
mindmap will fit on an A5 page (A5 pages are half as large as A4 pages).
Mindmaps with small mindmap will also fit onto a standard frame of the
beamer package.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/small:mindmap"
      },
      smooth = {
         details = [[
This option causes the points on the path to be connected using a smooth
curve:

    \tikz\draw plot[smooth] file{plots/pgfmanual-sine.table};

Note that the smoothing algorithm is not very intelligent. You will get
the best results if the bending angles are small, that is, less than
about $30^\circ$ and, even more importantly, if the distances between
points are about the same all over the plotting path.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/smooth"
      },
      ["smooth cycle"] = {
         details = [[
This option causes the points on the path to be connected using a closed
smooth curve.

    \tikz[scale=0.5]
      \draw plot[smooth cycle] coordinates{(0,0) (1,0) (2,1) (1,2)}
            plot               coordinates{(0,0) (1,0) (2,1) (1,2)} -- cycle;
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/smooth:cycle"
      },
      solid = {
         details = [[
Shorthand for setting a solid line as "dash pattern". This is the
default.

    \tikz \draw[solid] (0pt,0pt) -- (50pt,0pt);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/solid"
      },
      ["spy connection path"] = {
         details = [[
The ⟨code⟩ is executed after the spy-on and spy-in nodes have just been
created. Inside this ⟨code⟩, the two nodes can be accessed as
tikzspyinnode and tikzspyonnode. For example, the key connect spies sets
this command to

    \draw[thin] (tikzspyonnode) -- (tikzspyinnode);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/spy:connection:path",
         meta = "⟨code⟩"
      },
      ["spy scope"] = {
         details = [[
This option may be used with a {scope} or any environment that creates
such a scope internally (like {tikzpicture}). It has the following
effects:

-   It resets a number of graphic state parameters, including the color,
    line style, and others. This is necessary for technical reasons.

-   It tells TikZ that the content of the scope should be saved
    internally in a special box.

-   It defines the command \spy so that it can be used inside the scope.

-   At the end of the scope, the nodes belonging to the \spy commands
    used inside the scope are created.

-   The ⟨options⟩ are saved in an internal style. Each time \spy is
    used, these ⟨options⟩ will be used.

-   Three keys are defined that provide useful shortcuts:

It is permissible to nest spy scopes. In this case, all \spy commands
inside the inner spy scope only have an effect on material inside the
scope, whereas \spy commands outside the inner spy scope but inside the
outer spy scope allow you to "spy on the spy".

    \begin{tikzpicture}
      [spy using outlines={rectangle, red, magnification=5,
                           size=1.5cm, connect spies}]

      \begin{scope}
        [spy using outlines={circle, blue,
                             magnification=3, size=1.5cm, connect spies}]
        \draw [help lines] (0,0) grid (3,2);

        \draw [decoration=Koch curve type 1]
          decorate{ decorate{ decorate{ (0,0) -- (2,0) }}};

        \spy on (1.6,0.3) in node (zoom) [left] at (3.5,-1.25);
      \end{scope}

      \spy on (zoom.north west) in node [right] at (0,-1.25);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/spy:scope",
         meta = "⟨options⟩"
      },
      ["spy using outlines"] = {
         details = [[
This key creates a spy scope in which the spy-in node is drawn, but not
filled, using a thick line; and the spy-on node is drawn, but not
filled, using a very thin line.

    \begin{tikzpicture}
      [spy using outlines={circle, magnification=3, size=1cm, connect spies}]

      \draw [decoration=Koch curve type 1]
        decorate{ decorate{ decorate{ (0,0) -- (2,0) }}};

      \spy [red] on (1.6,0.3) in node at (3,1);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/spy:using:outlines",
         meta = "⟨options⟩"
      },
      ["spy using overlays"] = {
         details = [[
This key creates a spy scope in which both the spy-in and spy-on nodes
are filled, but with the fill opacity set to 20%.

    \begin{tikzpicture}
      [spy using overlays={circle, magnification=3, size=1cm, connect spies}]

      \draw [decoration=Koch curve type 1]
        decorate{ decorate{ decorate{ (0,0) -- (2,0) }}};

      \spy [green] on (1.6,0.3) in node at (3,1);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/spy:using:overlays",
         meta = "⟨options⟩"
      },
      ["start angle"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/start:angle",
         meta = "⟨degrees⟩"
      },
      ["start branch"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/start:branch",
         meta = "⟨branch name⟩⟨direction⟩"
      },
      ["start chain"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/start:chain",
         meta = "⟨chain name⟩⟨direction⟩"
      },
      state = {
         details = [[
You should redefine it to something else, if you wish to use states of a
different nature.

    \begin{tikzpicture}[state/.style=state with output]
      \node[state]          {$q_0$ \nodepart{lower} $11$};
      \node[state] at (2,0) {$q_1$ \nodepart{lower} $00$};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/state"
      },
      ["state with output"] = {
         details = [[
This node style causes nodes to be drawn as split circles, that is,
using the circle split shape. In the upper part of the shape you have
the name of the style, in the lower part the output is placed. To
specify the output, use the command \nodepart{lower} inside the node.
This style also calls every state.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);

      \node[state without output] {$q_0$};

      \node[state with output] at (2,0) {$q_1$ \nodepart{lower} $00$};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/state:with:output"
      },
      ["state without output"] = {
         details = [[
This node style causes nodes to be drawn as circles. Also, this style
calls every state.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/state:without:output"
      },
      step = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/step",
         meta = "⟨number or dimension or coordinate⟩"
      },
      ["structured tokens"] = {
         details = [[
This option, which must again be passed to a place, gets a list of texts
for tokens. For each text, a new token will be added to the place.

    \tikz  \node[place,structured tokens={$x$,$y$,$z$}] {};

    \begin{tikzpicture}[every place/.style={minimum size=9mm}]

      \foreach \x/\y/\tokennumber in {0/2/1,1/2/2,2/2/3,
                                      0/1/4,1/1/5,2/1/6,
                                      0/0/7,1/0/8,2/0/9}
        \node [place,structured tokens={1,...,\tokennumber}] at (\x,\y) {};
    \end{tikzpicture}

If you use lots of structured tokens, consider redefining the
every token style so that the tokens are larger.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/structured:tokens",
         meta = "⟨token texts⟩"
      },
      ["subgraph nodes"] = {
         details = [[
Sets the every subgraph node style to ⟨style⟩.

    \tikz [subgraph text bottom=text centered,
           subgraph nodes=red]
      \graph [tree layout] {
        a -> { b -> {c, d}, e -> {f, g -> h} };

        left [draw]  // { b, c, d };
        right [draw] // { e, f, g, h};

        left <-> right;
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/subgraph:nodes",
         meta = "⟨style⟩"
      },
      ["subgraph text bottom"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/subgraph:text:bottom",
         meta = "⟨text alignment options⟩"
      },
      ["subgraph text none"] = {
         details = [[
When this option is used, the text of a subgraph node is not shown.
Adding a slash after the node name achieves roughly the same effect, but
this option is useful in situations when subgraph nodes generally should
not have any text inside them.

    \tikz [subgraph text none]
      \graph [tree layout] {
        a -> { b -> {c, d}, e -> {f, g -> h} };

        left [draw]  // { b, c, d };
        right [draw] // { e, f, g, h};

        left <-> right;
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/subgraph:text:none"
      },
      ["subgraph text sep"] = {
         details = [[
Some space added between the inner nodes of a subgraph node and the text
labels.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/subgraph:text:sep",
         meta = "⟨dimension⟩"
      },
      ["subgraph text top"] = {
         details = [[
Specifies that the text of a subgraph node should be placed at the top
of the subgraph node: Still inside the node, but above all nodes inside
the subgraph node.

    \tikz [subgraph text top=text ragged left]
      \graph [tree layout] {
        a -> { b -> {c, d}, e -> {f, g -> h} };

        left [draw]  // { b, c, d };
        right [draw] // { e, f, g, h};

        left <-> right;
      };

You can pass any of the ⟨text alignment options⟩ understood by TikZ,
such as text centered:

    \tikz [subgraph text top=text centered]
      \graph [tree layout] {
        a -> { b -> {c, d}, e -> {f, g -> h} };

        left [draw, circle] // { b, c, d };
      };

To place a label outside the subgraph node, use a label, typically
defined using the quotes library:

    \tikz \graph [tree layout] {
        a -> { b -> {c, d}, e -> {f, g -> h} };

        / ["left", draw]  // { b, c, d } <->
        / ["right", draw] // { e, f, g, h};
      };
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/subgraph:text:top",
         meta = "⟨text alignment options⟩"
      },
      swap = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/swap"
      },
      tension = {
         details = [[
This option influences how "tight" the smoothing is. A lower value will
result in sharper corners, a higher value in more "round" curves. A
value of $1$ results in a circle if four points at quarter-positions on
a circle are given. The default is $0.55$. The "correct" value depends
on the details of plot.

    \begin{tikzpicture}[smooth cycle]
      \draw                 plot[tension=0.2]
        coordinates{(0,0) (1,1) (2,0) (1,-1)};
      \draw[yshift=-2.25cm] plot[tension=0.5]
        coordinates{(0,0) (1,1) (2,0) (1,-1)};
      \draw[yshift=-4.5cm]  plot[tension=1]
        coordinates{(0,0) (1,1) (2,0) (1,-1)};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/tension",
         meta = "⟨value⟩"
      },
      text = {
         details = [[
Sets the color to be used for text labels. A color= option will
immediately override this option.

    \begin{tikzpicture}
      \draw[red]       (0,0) -- +(1,1) node[above]     {red};
      \draw[text=red]  (1,0) -- +(1,1) node[above]     {red};
      \draw            (2,0) -- +(1,1) node[above,red] {red};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/text",
         meta = "⟨color⟩"
      },
      ["text depth"] = {
         details = [[
This option works like text height, only for the depth of the text box.
This option is mostly useful when you need to ensure a uniform depth of
text boxes that need to be aligned.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/text:depth",
         meta = "⟨dimension⟩"
      },
      ["text effects"] = {
         details = [[
Execute every option in {options} with the key path for each option
temporarily set to /pgf/decoration/text effects/.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/text:effects",
         meta = "{options}"
      },
      ["text height"] = {
         details = [[
Sets the height of the text boxes in shapes. Thus, when you write
something like node {text}, the text is first typeset, resulting in some
box of a certain height. This height is then replaced by the height
text height. The resulting box is then used to determine the size of the
shape, which will typically be larger. When you write text height=
without specifying anything, the "natural" size of the text box remains
unchanged.

    \tikz \node[draw]                  {y};
    \tikz \node[draw,text height=10pt] {y};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/text:height",
         meta = "⟨dimension⟩"
      },
      ["text opacity"] = {
         details = [[
Sets the opacity of text labels, overriding the fill opacity setting.

    \begin{tikzpicture}[every node/.style={fill,draw}]
      \draw[line width=2mm,blue!50,line cap=round] (0,0) grid (3,2);

      \node[opacity=0.5] at (1.5,2) {Upper node};
      \node[draw opacity=0.8,fill opacity=0.2,text opacity=1]
        at (1.5,0) {Lower node};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/text:opacity",
         meta = "⟨value⟩"
      },
      ["text width"] = {
         details = [[
This option will put the text of a node in a box of the given width
(something akin to a {minipage} of this width, only portable across
formats). If the node text is not as wide as ⟨dimension⟩, it will
nevertheless be put in a box of this width. If it is larger, line
breaking will be done.

By default, when this option is given, a ragged right border will be
used (align=left). This is sensible since, typically, these boxes are
narrow and justifying the text looks ugly. You can, however, change the
alignment using align or directly using commands line \centering.

    \tikz \draw (0,0) node[fill=yellow!80!black,text width=3cm]
      {This is a demonstration text for showing how line breaking works.};

Setting ⟨dimension⟩ to an empty string causes the automatic line
breaking to be disabled.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/text:width",
         meta = "⟨dimension⟩"
      },
      thick = {
         details = [[
Sets the line width to 0.8pt.

      \tikz \draw[thick] (0,0) -- (1cm,1.5ex);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/thick"
      },
      thin = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/thin"
      },
      ["tight background"] = {
         details = [[
Sets the inner frame separator to 0pt. The background rectangle will
have the size of the bounding box.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/tight:background"
      },
      ["tiny circuit symbols"] = {
         details = [[
This style sets the default circuit symbol unit to 5pt.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/tiny:circuit:symbols"
      },
      ["to path"] = {
         details = [[
Whenever a to operation is used, the ⟨path⟩ is inserted. More precisely,
the following path is added:

  {[every to,⟨options⟩] ⟨path⟩ }

The ⟨options⟩ are the options given to the to operation, the ⟨path⟩ is
the path set by this option to path.

Inside the ⟨path⟩, different macros are used to reference the from- and
to-coordinates. In detail, these are:

-   \tikztostart will expand to the from-coordinate (without the
    parentheses).

-   \tikztotarget will expand to the to-coordinate.

-   \tikztonodes will expand to the nodes between the to operation and
    the coordinate. Furthermore, these nodes will have the pos option
    set implicitly.

Let us have a look at a simple example. The standard straight line for a
to is achieved by the following ⟨path⟩:

  – (\tikztotarget) \tikztonodes

Indeed, this is the default setting for the path. When we write
(a) to (b), the ⟨path⟩ will expand to (a) – (b), when we write

  (a) to[red] node {x} (b)

the ⟨path⟩ will expand to

  (a) – (b) node[red] {x}

It is not possible to specify the path

  – \tikztonodes (\tikztotarget)

since TikZ does not allow one to have a macro after – that expands to a
node.

Now let us have a look at how we can modify the ⟨path⟩ sensibly. The
simplest way is to use a curve.

    \begin{tikzpicture}[to path={
        .. controls +(1,0) and +(1,0) .. (\tikztotarget) \tikztonodes}]

      \node (a) at (0,0) {a};
      \node (b) at (2,1) {b};
      \node (c) at (1,2) {c};

      \draw (a) to node {x} (b)
            (a) to          (c);
    \end{tikzpicture}

Here is another example:

    \tikzset{
      my loop/.style={to path={
        .. controls +(80:1) and +(100:1) .. (\tikztotarget) \tikztonodes}},
      my state/.style={circle,draw}}

    \begin{tikzpicture}[shorten >=2pt]
      \node [my state] (a) at (210:1) {$q_a$};
      \node [my state] (b) at (330:1) {$q_b$};

      \draw[->] (a) to           node[below]       {1} (b)
                    to [my loop] node[above right] {0} (b);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/to:path",
         meta = "⟨path⟩"
      },
      token = {
         details = [[
This style indicates that a node is a token. By default, this causes the
node to be a small black circle. Unlike places and transitions, it does
make sense to provide text for the token node. Such text will be typeset
in a tiny font and in white on black (naturally, you can easily change
this by setting the style every token).

    \begin{tikzpicture}
      \node[place,label=above:$p_1$]             (p1) {};
      \node[token] at (p1) {};

      \node[place,label=above:$p_2$,right=of p1] (p2) {};
      \node[token] at (p2) {$y$};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/token"
      },
      ["token distance"] = {
         details = [[
This specifies the distance between the centers of the tokens in the
arrangements of the option children are tokens.

    \begin{tikzpicture}
      \node[place,label=above:$p_3$] {}
      [children are tokens,token distance=1.1ex]
      child {node [token] {}}
      child {node [token,red] {}}
      child {node [token,blue] {}}
      child {node [token] {}};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/token:distance",
         meta = "⟨distance⟩"
      },
      tokens = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/tokens",
         meta = "⟨number⟩"
      },
      ["top color"] = {
         details = [[
This option sets the color to be used at the top in an axis shading.
When this option is given, several things happen:

1.  The shade option is selected.

2.  The shading=axis option is selected.

3.  The middle color of the axis shading is set to the average of the
    given top color ⟨color⟩ and of whatever color is currently selected
    for the bottom.

4.  The rotation angle of the shading is set to 0.

    \tikz \draw[top color=red] (0,0) rectangle (2,1);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/top:color",
         meta = "⟨color⟩"
      },
      ["transform canvas"] = {
         details = [[
The ⟨options⟩ should contain coordinate transformations options like
scale or xshift. Multiple options can be given, their effects accumulate
in the usual manner. The effect of these ⟨options⟩ (immediately) changes
the current canvas transformation matrix. The coordinate transformation
matrix is not changed. Tracking of the picture size is (locally)
switched off and the node coordinate will no longer be correct.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                                    (0,0) -- (1,1) -- (1,0);
      \draw[transform canvas={scale=2},blue]   (0,0) -- (1,1) -- (1,0);
      \draw[transform canvas={rotate=180},red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/transform:canvas",
         meta = "⟨options⟩"
      },
      ["transform shape"] = {
         details = [[
Causes the current "external" transformation matrix to be applied to the
shape. For example, if you said \tikz[scale=3] and then say
node[transform shape] {X}, you will get a "huge" X in your graphic.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/transform:shape"
      },
      ["transform shape nonlinear"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/transform:shape:nonlinear",
         meta = "⟨true or false⟩"
      },
      transition = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/transition"
      },
      ["transparency group"] = {
         details = [[
This option can be given to a scope. It will have the following effect:
The scope's contents is stroked / filled "ignoring any outside
transparency". This means, all previous transparency settings are
ignored (you can still set transparency inside the group, but never
mind). For instance, in the forbidden sign example, the whole sign is
first painted (conceptually) like the image on the left hand side. Note
that some pixels of the sign are painted multiple times (up to three
times), but only the last color "wins".

Then, when the scope is finished, it is painted as a whole. The fill
transparency settings are now applied to the resulting picture. For
instance, the pixel that has been painted three times is just red at the
end, so this red color will be blended with whatever is "behind" the
group on the page.

    \begin{tikzpicture}
      \pattern[pattern=checkerboard,pattern color=black!15](-1,-1) rectangle (3,1);
      \node at (0,0) [forbidden sign,line width=2ex,draw=red,fill=white] {Smoking};

      \begin{scope}[transparency group,opacity=.5]
        \node at (2,0) [forbidden sign,line width=2ex,draw=red,fill=white]
          {Smoking};
      \end{scope}
    \end{tikzpicture}

Note that in the example, the opacity=.5 is not active inside the
transparency group: The group is only established at beginning of the
scope and all options given to the {scope} environment are set before
the group is established. To change the opacity inside the group, you
need to open another scope inside it or use the opacity key with a
command inside the group:

    \begin{tikzpicture}
      \pattern[pattern=checkerboard,pattern color=black!15](-1,-1) rectangle (3,1);
      \node at (0,0) [forbidden sign,line width=2ex,draw=red,fill=white] {Smoking};

      \begin{scope}[transparency group,opacity=.5]
        \node (s) at (2,0) [forbidden sign,line width=2ex,draw=red,fill=white]
        {Smoking};

        \draw [opacity=.5, line width=2ex, blue] (1.2,0) -- (2.8,0);
      \end{scope}
    \end{tikzpicture}

The ⟨options⟩ are a list of comma-separated options:

-   knockout When this option is given inside the ⟨options⟩, the group
    becomes a so-called knockout group. This means, essentially, that
    inside the group everything is painted as if the "opacity" of a line
    or area were just another color channel. In particular, if you paint
    a pixel with opacity $0$ inside a knockout group, this pixel becomes
    perfectly transparent immediately. In contrast, painting a pixel
    with something of opacity $0$ normally has no effect.

    Not all renderers, let alone printers, will support this. At the
    time of writing, Apple's Preview will not show the following
    correctly (you should see the text TikZ in the middle):

        \begin{tikzpicture}
          \shade [left color=red,right color=blue] (-2,-1) rectangle (2,1);
          \begin{scope}[transparency group=knockout]
            \fill [white] (-1.9,-.9) rectangle (1.9,.9);
            \node [opacity=0,font=\fontencoding{T1}\fontfamily{ptm}\fontsize{45}{45}\bfseries]
                  {Ti\emph{k}Z};
          \end{scope}
        \end{tikzpicture}

    In the example, we first draw a large shading and then, inside the
    transparency group "overwrite" most of this shading by a big white
    rectangle. The interesting part is the text of the node, which has
    opacity 0. Normally, this would mean that nothing is shown. However,
    in a knockout group, we "paint" the text with an "opacity zero"
    color. The effect is that part of the totally opaque white rectangle
    gets overwritten by a perfectly transparent area (namely exactly the
    area taken up by the pixels of the text). When this whole knockout
    group is then placed on top of the shading, the shading will "shine
    through" at the knocked-out pixels.

-   isolated=false A group can be isolated or not. By default, they are
    isolated, since this is typically what you want. For details on what
    isolated groups are, exactly, see Section 7.3.4 of the PDF
    Specification, version 1.7.

Note that when a transparency group is created, TikZ must correctly
determine the size of the material inside the group. Usually, this is no
problem, but when you use things like overlay or transform canvas,
trouble may result. In this case, please consult Section ?? on how to
sidestep this problem in such cases.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/transparency:group",
         meta = "\\oarg{options}"
      },
      transparent = {
         details = [[
Makes everything totally transparent and, hence, invisible.

    \tikz{\fill[red]             (0,0)   rectangle (1,0.5);
          \fill[transparent,red] (0.5,0) rectangle (1.5,0.25); }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/transparent"
      },
      ["trim left"] = {
         details = [[
The trim left key tells PGFto discard everything which is left of the
provided ⟨dimension or coordinate⟩. Here, ⟨dimension⟩ is a single $x$
coordinate of the picture and ⟨coordinate⟩ is a point with $x$ and $y$
coordinates (but only its $x$ coordinate will be used). The effect is
the same as if you issue \hspace{-s} where s is the difference of the
picture's bounding box lower left $x$ coordinate and the $x$ coordinate
specified as ⟨dimension or coordinate⟩:

    Text before image.%
        \begin{tikzpicture}[trim left]
            \draw (-1,-1) grid (3,2);
            \fill (0,0) circle (5pt);
        \end{tikzpicture}%
    Text after image.

Since trim left uses the default trim left=0pt, everything left of $x=0$
is removed from the bounding box.

The following example has once the relative long label $-1$ and once the
shorter label $1$. Horizontal alignment is established with trim left:

    \begin{tikzpicture}
        \draw (0,1) -- (0,0) -- (1,1) -- cycle;
        \fill (0,0) circle (2pt);
        \node[left] at (0,0) {$-1$};
    \end{tikzpicture}
    \par
    \begin{tikzpicture}
        \draw (0,1) -- (0,0) -- (1,1) -- cycle;
        \fill (0,0) circle (2pt);
        \node[left] at (0,0) {$1$};
    \end{tikzpicture}
    \par
    \begin{tikzpicture}[trim left]
        \draw (0,1) -- (0,0) -- (1,1) -- cycle;
        \fill (0,0) circle (2pt);
        \node[left] at (0,0) {$-1$};
    \end{tikzpicture}
    \par
    \begin{tikzpicture}[trim left]
        \draw (0,1) -- (0,0) -- (1,1) -- cycle;
        \fill (0,0) circle (2pt);
        \node[left] at (0,0) {$1$};
    \end{tikzpicture}

Use trim left=default to reset the value.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/trim:left",
         meta = "⟨dimension or coordinate or default⟩"
      },
      ["trim right"] = {
         details = [[
This key is similar to trim left: it discards everything which is right
of the provided ⟨dimension or coordinate⟩. As for trim left, ⟨dimension⟩
denotes a single $x$ coordinate of the picture and ⟨coordinate⟩ a
coordinate with $x$ and $y$ value (although only its $x$ component will
be used).

We use the same example from above and add trim right:

    Text before image.%
        \begin{tikzpicture}[trim left, trim right=2cm, baseline]
            \draw (-1,-1) grid (3,2);
            \fill (0,0) circle (5pt);
        \end{tikzpicture}%
    Text after image.

In addition to trim left=0pt, we also discard everything which is right
of $x$=2cm. Furthermore, the baseline key supports vertical alignment as
well (using the $y$=0cm baseline).

Use trim right=default to reset the value.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/trim:right",
         meta = "⟨dimension or coordinate or default⟩"
      },
      turn = {
         details = [[
This key can be given as an option to a ⟨coordinate⟩ as in the following
example:

    \tikz \draw (0,0) -- (1,1) -- ([turn]-45:1cm) -- ([turn]-30:1cm);

The effect of this key is to locally shift the coordinate system so that
the last point reached is at the origin and the coordinate system is
"turned" so that the $x$-axis points in the direction of a tangent
entering the last point. This means, in effect, that when you use polar
coordinates of the form ⟨relative angle⟩:⟨distance⟩ together with the
turn option, you specify a point that lies at ⟨distance⟩ from the last
point in the direction of the last tangent entering the last point, but
with a rotation of ⟨relative angle⟩.

This key also works with curves ...

    \tikz [delta angle=30, radius=1cm]
      \draw (0,0) arc [start angle=0]  -- ([turn]0:1cm)
                  arc [start angle=30] -- ([turn]0:1cm)
                  arc [start angle=60] -- ([turn]30:1cm);

    \tikz \draw (0,0) to [bend left] (2,1) -- ([turn]0:1cm);

...and with plots ...

    \tikz \draw plot coordinates {(0,0) (1,1) (2,0) (3,0) } -- ([turn]30:1cm);

Although the above examples use polar coordinates with turn, you can
also use any normal coordinate. For instance, ([turn]1,1) will append a
line of length $\sqrt 2$ that is turns by $45^\circ$ relative to the
tangent to the last point.

    \tikz \draw (0.5,0.5) -| (2,1) -- ([turn]1,1)
             .. controls ([turn]0:1cm) .. ([turn]-90:1cm);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/turn"
      },
      turtle = {
         details = [[
This key executes the ⟨keys⟩ with the current key path set to
/tikz/turtle.

    \tikz[turtle/distance=2mm]
      \draw [turtle={home,fd,rt,fd,lt,fd,lt,fd}];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/turtle",
         meta = "⟨keys⟩"
      },
      ["turtle/back"] = {
         details = [[
This has the same effect as a turtle/forward for the negated ⟨distance⟩
value.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/back",
         meta = "⟨distance⟩"
      },
      ["turtle/bk"] = {
         details = [[
An abbreviation for the back key.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/bk"
      },
      ["turtle/distance"] = {
         details = [[
The default distance by which the turtle advances.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/distance",
         meta = "⟨distance⟩"
      },
      ["turtle/fd"] = {
         details = [[
An abbreviation for the forward key.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/fd"
      },
      ["turtle/forward"] = {
         details = [[
Makes the turtle move forward by the given ⟨distance⟩. If no ⟨distance⟩
is specified, the current value of the following key is used:

"Moving forward the turtle" actually means that, relative to the current
last point on the path, a point at the given ⟨distance⟩ in the direction
the turtle is currently heading is computed. Then, the operation
to[turtle/how] is used to extend the path to this point.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/forward",
         meta = "⟨distance⟩"
      },
      ["turtle/home"] = {
         details = [[
Places the turtle at the origin and lets it head upward.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/home"
      },
      ["turtle/how"] = {
         details = [[
This style can set up the to path used by turtles. By setting this style
you can change the to-path:

    \tikz \draw [turtle={how/.style={bend left},home,forward,right,forward}];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/how"
      },
      ["turtle/left"] = {
         details = [[
Turns the turtle left by the given angle.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/left",
         meta = "⟨angle⟩"
      },
      ["turtle/lt"] = {
         details = [[
An abbreviation for the left key.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/lt"
      },
      ["turtle/right"] = {
         details = [[
Turns the turtle right by the given angle.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/right",
         meta = "⟨angle⟩"
      },
      ["turtle/rt"] = {
         details = [[
An abbreviation for the right key.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/turtle/rt"
      },
      ["ultra nearly opaque"] = {
         details = [[
    \tikz{\fill[red]                 (0,0)   rectangle (1,0.5);
          \fill[ultra nearly opaque] (0.5,0) rectangle (1.5,0.25); }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/ultra:nearly:opaque"
      },
      ["ultra nearly transparent"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/ultra:nearly:transparent"
      },
      ["ultra thick"] = {
         details = [[
Sets the line width to 1.6pt.

      \tikz \draw[ultra thick] (0,0) -- (1cm,1.5ex);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/ultra:thick"
      },
      ["ultra thin"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/ultra:thin"
      },
      ["upper left"] = {
         details = [[
Works like lower left.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/upper:left",
         meta = "⟨color⟩"
      },
      ["upper right"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/upper:right",
         meta = "⟨color⟩"
      },
      ["use as bounding box"] = {
         details = [[
Normally, when this option is given on a path, the bounding box of the
present path is used to determine the size of the picture and the size
of all subsequent paths are ignored. However, if there were previous
path operations that have already established a larger bounding box, it
will not be made smaller by this operation (consider the
\pgfresetboundingbox command to reset the previous bounding box).

In a sense, use as bounding box has the same effect as clipping all
subsequent drawing against the current path -- without actually doing
the clipping, only making PGF treat everything as if it were clipped.

The first application of this option is to have a {tikzpicture} overlap
with the main text:

    Left of picture\begin{tikzpicture}
      \draw[use as bounding box] (2,0) rectangle (3,1);
      \draw (1,0) -- (4,.75);
    \end{tikzpicture}right of picture.

In a second application this option can be used to get better control
over the white space around the picture:

    Left of picture
    \begin{tikzpicture}
      \useasboundingbox (0,0) rectangle (3,1);
      \fill (.75,.25) circle (.5cm);
    \end{tikzpicture}
    right of picture.

Note: If this option is used on a path inside a TeX group (scope), the
effect "lasts" only until the end of the scope. Again, this behavior is
the same as for clipping.

Consider using \useasboundingbox together with \pgfresetboundingbox in
order to replace the bounding box with a new one.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/use:as:bounding:box"
      },
      ["use path"] = {
         details = [[
Set the current path to the soft path stored in ⟨macro⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/use:path",
         meta = "⟨macro⟩"
      },
      variable = {
         details = [[
Sets the macro whose value is set to the different values when
⟨coordinate expression⟩ is evaluated.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/variable",
         meta = "⟨macro⟩"
      },
      ["very near end"] = {
         details = [[
Set to pos=0.875.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/very:near:end"
      },
      ["very near start"] = {
         details = [[
Set to pos=0.125.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/very:near:start"
      },
      ["very nearly opaque"] = {
         details = [[
    \tikz{\fill[red]                (0,0)   rectangle (1,0.5);
          \fill[very nearly opaque] (0.5,0) rectangle (1.5,0.25); }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/very:nearly:opaque"
      },
      ["very nearly transparent"] = {
         details = [[
    \tikz{\fill[red]                     (0,0)   rectangle (1,0.5);
          \fill[very nearly transparent] (0.5,0) rectangle (1.5,0.25); }
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/very:nearly:transparent"
      },
      ["very thick"] = {
         details = [[
Sets the line width to 1.2pt.

      \tikz \draw[very thick] (0,0) -- (1cm,1.5ex);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/very:thick"
      },
      ["very thin"] = {
         details = [[
Sets the line width to 0.2pt.

      \tikz \draw[very thin] (0,0) -- (1cm,1.5ex);
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/very:thin"
      },
      view = {
         details = [[
This is an alias for /tikz/meet.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/view"
      },
      ["visualizer color"] = {
         details = [[
This key is used to set the color visualizer color to ⟨color⟩. This
color is used by visualizers to color the data they visualize, rather
than the current "standard color". The reason for not using the normal
current color is simply that it makes many internals of the data
visualization engine a bit simpler.

        data point [x=2, y=2,       set=normal]
        data point [x=0, y=1,       set=heated]
        data point [x=2, y=1,       set=heated]
        data point [x=0.5, y=1.5,   set=critical]
        data point [x=2.25, y=1.75, set=critical]
    };},
    ]
    \pgfdvdeclarestylesheet{my colors}
    {
      default style/.style={visualizer color=black},
      1/.style={visualizer color=black},
      2/.style={visualizer color=red!80!black},
      3/.style={visualizer color=blue!80!black},
    }
    \tikz \datavisualization [
      school book axes,
      visualize as line=normal,
      visualize as line=heated,
      visualize as line=critical,
      style sheet=my colors]
    data group {lines};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/visualizer:color",
         meta = "⟨color⟩"
      },
      ["week list"] = {
         details = [[
This style creates one row for each week in the range. The value of
day xshift is used for the distance between days in each week row, the
value of day yshift is used for the distance between rows. In both
cases, "distance" refers to the distance between the anchors of the
nodes of the days (or, more generally, the distance between the origins
of the little pictures created for each day).

The days inside each week are shifted such that Monday is always at the
first position (to change this, you need to copy and then modify the
code appropriately). If the date range does not start on a Monday, the
first line will not start in the first column, but rather in the column
appropriate for the first date in the range.

At the beginning of each month (except for the first month in the range)
an additional vertical space of month yshift is added. If this is set to
0pt you get a continuous list of days.

    \tikz
      \calendar [dates=2000-01-01 to 2000-02-last,week list];

    \tikz
      \calendar [dates=2000-01-01 to 2000-02-last,week list,
                 month yshift=0pt];
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/week:list"
      },
      width = {
         details = [[
Inside a spy scope, this is a shortcut for minimum width.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/width",
         meta = "⟨dimension⟩"
      },
      x = {
         details = [[
If ⟨value⟩ is a dimension, the $x$-vector of PGF's $xyz$-coordinate
system is set up to point ⟨value⟩ to the right, that is, to
$(⟨value⟩,0pt)$.

    \begin{tikzpicture}
      \draw                  (0,0)   -- +(1,0);
      \draw[x=2cm,color=red] (0,0.1) -- +(1,0);
    \end{tikzpicture}

    \tikz \draw[x=1.5cm] (0,0) grid (2,2);

The last example shows that the size of steppings in grids, just like
all other dimensions, are not affected by the $x$-vector. After all, the
$x$-vector is only used to determine the coordinate of the upper right
corner of the grid.

If ⟨value⟩ is a coordinate, the $x$-vector of PGF's $xyz$-coordinate
system is set to the specified coordinate. If ⟨value⟩ contains a comma,
it must be put in braces.

    \begin{tikzpicture}
      \draw                            (0,0) -- (1,0);
      \draw[x={(2cm,0.5cm)},color=red] (0,0) -- (1,0);
    \end{tikzpicture}

You can use this, for example, to exchange the meaning of the $x$- and
$y$-coordinate.

    \begin{tikzpicture}[smooth]
      \draw plot coordinates{(1,0) (2,0.5) (3,0) (3,1)};
      \draw[x={(0cm,1cm)},y={(1cm,0cm)},color=red]
            plot coordinates{(1,0) (2,0.5) (3,0) (3,1)};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/x",
         meta = "⟨value⟩"
      },
      ["x radius"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/x:radius",
         meta = "⟨value⟩"
      },
      xbar = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/xbar"
      },
      ["xbar interval"] = {
         details = [[
Works like ybar interval, but for horizontal bar plots.

    \begin{tikzpicture}[xbar interval,x=0.5cm,y=0.5cm]
      \draw[color=red,fill=red!80]
        plot coordinates {(3,0) (2,1) (4,1.5) (1,4) (2,6) (2,7)};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/xbar:interval"
      },
      xcomb = {
         details = [[
This option works like ycomb except that the bars are horizontal.

    \tikz \draw plot[xcomb,mark=x] coordinates{(1,0) (0.8,0.2) (0.6,0.4) (0.2,1)};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/xcomb"
      },
      xrange = {
         details = [[
Set the $x$-range. This makes sense only for parametric plots.

    \tikz \draw[scale=0.5,domain=-3.141:3.141,smooth,xrange=0:1]
      plot[parametric,id=parametric-example-cut] function{t*sin(t),t*cos(t)};
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/xrange",
         meta = "⟨start⟩:⟨end⟩"
      },
      xscale = {
         details = [[
Multiplies only the $x$-value of all coordinates by the given ⟨factor⟩.

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                (0,0) -- (1,1) -- (1,0);
      \draw[xscale=2,blue] (0,0) -- (1,1) -- (1,0);
      \draw[xscale=-1,red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/xscale",
         meta = "⟨factor⟩"
      },
      xshift = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/xshift",
         meta = "⟨dimension⟩"
      },
      xslant = {
         details = [[
Slants the coordinate horizontally by the given ⟨factor⟩:

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                (0,0) -- (1,1) -- (1,0);
      \draw[xslant=2,blue] (0,0) -- (1,1) -- (1,0);
      \draw[xslant=-1,red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/xslant",
         meta = "⟨factor⟩"
      },
      xstep = {
         details = [[
Sets the stepping in the $x$-direction.

    \begin{tikzpicture}
      \draw (0,0) grid [xstep=.5,ystep=.75] (3,2);
      \draw[ultra thick] (0,0) grid [ystep=0] (3,2);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/xstep",
         meta = "⟨dimension or number⟩"
      },
      y = {
         details = [[
Works like the x= option, only if ⟨value⟩ is a dimension, the resulting
vector points to $(0,⟨value⟩)$.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/y",
         meta = "⟨value⟩"
      },
      ["y radius"] = {
         details = [[
Works like the x radius.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/y:radius",
         meta = "⟨value⟩"
      },
      ybar = {
         details = [[
This option produces fillable bar plots. It is thus very similar to
ycomb, but it employs rectangular shapes instead of line-to operations.
It thus allows to use any fill or pattern style.

    \tikz\draw[draw=blue,fill=blue!60!black] plot[ybar] file{plots/pgfmanual-sine.table};

    \begin{tikzpicture}[ybar]
      \draw[color=red,fill=red!80,bar width=6pt]
        plot coordinates{(0,1) (.5,1.2) (1,.6) (1.5,.7) (2,.9)};
      \draw[color=red!50,fill=red!20,bar width=4pt,bar shift=3pt]
        plot coordinates{(0,1.2) (.5,1.3) (1,.5) (1.5,.2) (2,.5)};
    \end{tikzpicture}

The use of bar width and bar shift is explained in the plothandlers
library documentation, section ??. Please refer to page ??.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/ybar"
      },
      ["ybar interval"] = {
         details = [[
As /tikz/ybar, this options produces vertical bars. However, bars are
centered at coordinate intervals instead of interval edges, and the
bar's width is also determined relatively to the interval's length:

    \begin{tikzpicture}[ybar interval,x=10pt]
      \draw[color=red,fill=red!80]
        plot coordinates{(0,2) (2,1.2) (3,.3) (5,1.7) (8,.9) (9,.9)};
    \end{tikzpicture}

Since there are $N$ intervals $[x_i,x_{i+1}]$ for given $N+1$
coordinates, you will always have one coordinate more than bars. The
last $y$ value will be ignored.

You can configure relative shifts and relative bar widths, which is
explained in the plothandlers library documentation, section ??. Please
refer to page ??.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/ybar:interval"
      },
      ycomb = {
         details = [[
This option causes the plot operation to interpret the plotting points
differently. Instead of connecting them, for each point of the plot a
straight line is added to the path from the $x$-axis to the point,
resulting in a sort of "comb" or "bar diagram".

    \tikz\draw[ultra thick] plot[ycomb,thin,mark=*] file{plots/pgfmanual-sine.table};

    \begin{tikzpicture}[ycomb]
      \draw[color=red,line width=6pt]
        plot coordinates{(0,1) (.5,1.2) (1,.6) (1.5,.7) (2,.9)};
      \draw[color=red!50,line width=4pt,xshift=3pt]
        plot coordinates{(0,1.2) (.5,1.3) (1,.5) (1.5,.2) (2,.5)};
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/ycomb"
      },
      ["year code"] = {
         details = [[
Works like month code, only for years.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/year:code",
         meta = "⟨code⟩"
      },
      ["year text"] = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/year:text",
         meta = "⟨text⟩"
      },
      yrange = {
         details = [[
Same as range.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/yrange",
         meta = "⟨start⟩:⟨end⟩"
      },
      yscale = {
         details = [[
Multiplies only the $y$-value of all coordinates by ⟨factor⟩.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/yscale",
         meta = "⟨factor⟩"
      },
      yshift = {
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/yshift",
         meta = "⟨dimension⟩"
      },
      yslant = {
         details = [[
Slants the coordinate vertically by the given ⟨factor⟩:

    \begin{tikzpicture}
      \draw[help lines] (0,0) grid (3,2);
      \draw                (0,0) -- (1,1) -- (1,0);
      \draw[yslant=2,blue] (0,0) -- (1,1) -- (1,0);
      \draw[yslant=-1,red] (0,0) -- (1,1) -- (1,0);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/yslant",
         meta = "⟨factor⟩"
      },
      ystep = {
         details = [[
Sets the stepping in the $y$-direction.
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/ystep",
         meta = "⟨dimension or number⟩"
      },
      z = {
         details = [[
Works like the y= option, but now a dimension is the point
$(⟨value⟩,⟨value⟩)$.

    \begin{tikzpicture}[z=-1cm,->,thick]
      \draw[color=red] (0,0,0) -- (1,0,0);
      \draw[color=blue] (0,0,0) -- (0,1,0);
      \draw[color=orange] (0,0,0) -- (0,0,1);
    \end{tikzpicture}
]],
         documentation = "texdoc:generic/pgf/pgfmanual.pdf#pgf./tikz/z",
         meta = "⟨value⟩"
      }
   }
}
